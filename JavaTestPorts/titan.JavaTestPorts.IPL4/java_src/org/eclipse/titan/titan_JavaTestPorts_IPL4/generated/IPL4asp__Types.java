// This Java file was generated by the TITAN Designer eclipse plug-in
// of the TTCN-3 Test Executor version CRL 113 200/6 R5B
// for (elnrnag@elx78355y6x)

// Copyright (c) 2000-2018 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

package org.eclipse.titan.titan_JavaTestPorts_IPL4.generated;

import org.eclipse.titan.runtime.core.AdditionalFunctions;
import org.eclipse.titan.runtime.core.Base_Template;
import org.eclipse.titan.runtime.core.Base_Template.template_sel;
import org.eclipse.titan.runtime.core.Base_Type;
import org.eclipse.titan.runtime.core.Base_Type.TTCN_Typedescriptor;
import org.eclipse.titan.runtime.core.Module_List;
import org.eclipse.titan.runtime.core.Optional;
import org.eclipse.titan.runtime.core.Optional.optional_sel;
import org.eclipse.titan.runtime.core.Param_Types.Module_Param_Name;
import org.eclipse.titan.runtime.core.Param_Types.Module_Parameter;
import org.eclipse.titan.runtime.core.PreGenRecordOf;
import org.eclipse.titan.runtime.core.RAW;
import org.eclipse.titan.runtime.core.RAW.RAW_enc_tr_pos;
import org.eclipse.titan.runtime.core.RAW.RAW_enc_tree;
import org.eclipse.titan.runtime.core.RecordOf_Match;
import org.eclipse.titan.runtime.core.RecordOf_Match.match_function_t;
import org.eclipse.titan.runtime.core.Record_Of_Template;
import org.eclipse.titan.runtime.core.Restricted_Length_Template;
import org.eclipse.titan.runtime.core.TTCN_Buffer;
import org.eclipse.titan.runtime.core.TTCN_EncDec.coding_type;
import org.eclipse.titan.runtime.core.TTCN_EncDec.error_type;
import org.eclipse.titan.runtime.core.TTCN_EncDec.raw_order_t;
import org.eclipse.titan.runtime.core.TTCN_EncDec_ErrorContext;
import org.eclipse.titan.runtime.core.TTCN_Logger;
import org.eclipse.titan.runtime.core.TTCN_Module;
import org.eclipse.titan.runtime.core.Text_Buf;
import org.eclipse.titan.runtime.core.TitanBoolean;
import org.eclipse.titan.runtime.core.TitanBoolean_template;
import org.eclipse.titan.runtime.core.TitanCharString;
import org.eclipse.titan.runtime.core.TitanCharString_template;
import org.eclipse.titan.runtime.core.TitanInteger;
import org.eclipse.titan.runtime.core.TitanInteger_template;
import org.eclipse.titan.runtime.core.TitanNull_Type;
import org.eclipse.titan.runtime.core.TitanOctetString;
import org.eclipse.titan.runtime.core.TitanOctetString_template;
import org.eclipse.titan.runtime.core.TtcnError;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;

public final class IPL4asp__Types extends TTCN_Module {

	public static final TTCN_Typedescriptor TcpKeepAlive_descr_ = new TTCN_Typedescriptor("TcpKeepAlive", null, null);
	public static final TTCN_Typedescriptor TcpKeepAlive_enable_descr_ = new TTCN_Typedescriptor("TcpKeepAlive_enable", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor TcpKeepAlive_count_descr_ = new TTCN_Typedescriptor("TcpKeepAlive_count", RAW.TitanInteger_raw_, null);
	public static final TTCN_Typedescriptor TcpKeepAlive_idle_descr_ = new TTCN_Typedescriptor("TcpKeepAlive_idle", RAW.TitanInteger_raw_, null);
	public static final TTCN_Typedescriptor TcpKeepAlive_interval_descr_ = new TTCN_Typedescriptor("TcpKeepAlive_interval", RAW.TitanInteger_raw_, null);
	public static final TTCN_Typedescriptor ReuseAddress_descr_ = new TTCN_Typedescriptor("ReuseAddress", null, null);
	public static final TTCN_Typedescriptor ReuseAddress_enable_descr_ = new TTCN_Typedescriptor("ReuseAddress_enable", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SctpEventHandle_descr_ = new TTCN_Typedescriptor("SctpEventHandle", null, null);
	public static final TTCN_Typedescriptor SctpEventHandle_sctp__data__io__event_descr_ = new TTCN_Typedescriptor("SctpEventHandle_sctp__data__io__event", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SctpEventHandle_sctp__association__event_descr_ = new TTCN_Typedescriptor("SctpEventHandle_sctp__association__event", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SctpEventHandle_sctp__address__event_descr_ = new TTCN_Typedescriptor("SctpEventHandle_sctp__address__event", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SctpEventHandle_sctp__send__failure__event_descr_ = new TTCN_Typedescriptor("SctpEventHandle_sctp__send__failure__event", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SctpEventHandle_sctp__peer__error__event_descr_ = new TTCN_Typedescriptor("SctpEventHandle_sctp__peer__error__event", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SctpEventHandle_sctp__shutdown__event_descr_ = new TTCN_Typedescriptor("SctpEventHandle_sctp__shutdown__event", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SctpEventHandle_sctp__partial__delivery__event_descr_ = new TTCN_Typedescriptor("SctpEventHandle_sctp__partial__delivery__event", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SctpEventHandle_sctp__adaptation__layer__event_descr_ = new TTCN_Typedescriptor("SctpEventHandle_sctp__adaptation__layer__event", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SctpEventHandle_sctp__authentication__event_descr_ = new TTCN_Typedescriptor("SctpEventHandle_sctp__authentication__event", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SctpEventHandle_sctp__sender__dry__event_descr_ = new TTCN_Typedescriptor("SctpEventHandle_sctp__sender__dry__event", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor Linger__opt_descr_ = new TTCN_Typedescriptor("Linger__opt", null, null);
	public static final TTCN_Typedescriptor Linger__opt_l__onoff_descr_ = new TTCN_Typedescriptor("Linger__opt_l__onoff", RAW.TitanInteger_raw_, null);
	public static final TTCN_Typedescriptor Linger__opt_l__linger_descr_ = new TTCN_Typedescriptor("Linger__opt_l__linger", RAW.TitanInteger_raw_, null);
	public static final TTCN_Typedescriptor SSL__protocols_descr_ = new TTCN_Typedescriptor("SSL__protocols", null, null);
	public static final TTCN_Typedescriptor SSL__protocols_SSLv2__supported_descr_ = new TTCN_Typedescriptor("SSL__protocols_SSLv2__supported", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SSL__protocols_SSLv3__supported_descr_ = new TTCN_Typedescriptor("SSL__protocols_SSLv3__supported", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SSL__protocols_TLSv1__supported_descr_ = new TTCN_Typedescriptor("SSL__protocols_TLSv1__supported", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SSL__protocols_TLSv1__1__supported_descr_ = new TTCN_Typedescriptor("SSL__protocols_TLSv1__1__supported", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SSL__protocols_TLSv1__2__supported_descr_ = new TTCN_Typedescriptor("SSL__protocols_TLSv1__2__supported", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SSL__protocols_DTLSv1__supported_descr_ = new TTCN_Typedescriptor("SSL__protocols_DTLSv1__supported", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SSL__protocols_DTLSv1__2__supported_descr_ = new TTCN_Typedescriptor("SSL__protocols_DTLSv1__2__supported", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor SSL__proto__support_descr_ = new TTCN_Typedescriptor("SSL__proto__support", null, null);
	public static final TTCN_Typedescriptor SSL__cert__options_descr_ = new TTCN_Typedescriptor("SSL__cert__options", null, null);
	public static final TTCN_Typedescriptor SSL__cert__options_ssl__key__file_descr_ = new TTCN_Typedescriptor("SSL__cert__options_ssl__key__file", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor SSL__cert__options_ssl__certificate__file_descr_ = new TTCN_Typedescriptor("SSL__cert__options_ssl__certificate__file", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor SSL__cert__options_ssl__trustedCAlist__file_descr_ = new TTCN_Typedescriptor("SSL__cert__options_ssl__trustedCAlist__file", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor SSL__cert__options_ssl__cipher__list_descr_ = new TTCN_Typedescriptor("SSL__cert__options_ssl__cipher__list", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor SSL__cert__options_ssl__password_descr_ = new TTCN_Typedescriptor("SSL__cert__options_ssl__password", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor PSK__options_descr_ = new TTCN_Typedescriptor("PSK__options", null, null);
	public static final TTCN_Typedescriptor PSK__options_psk__identity_descr_ = new TTCN_Typedescriptor("PSK__options_psk__identity", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor PSK__options_psk__identity__hint_descr_ = new TTCN_Typedescriptor("PSK__options_psk__identity__hint", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor PSK__options_psk__key_descr_ = new TTCN_Typedescriptor("PSK__options_psk__key", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor MTU__discover_descr_ = new TTCN_Typedescriptor("MTU__discover", null, null);
	public static final TTCN_Typedescriptor Option_descr_ = new TTCN_Typedescriptor("Option", null, null);
	public static final TTCN_Typedescriptor HostList_descr_ = new TTCN_Typedescriptor("HostList", null, null);
	public static final TTCN_Typedescriptor Option_sctpEINConfigGroup_descr_ = new TTCN_Typedescriptor("Option_sctpEINConfigGroup", RAW.TitanInteger_raw_, null);
	public static final TTCN_Typedescriptor Option_no__delay_descr_ = new TTCN_Typedescriptor("Option_no__delay", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor Option_dtlsSrtpProfiles_descr_ = new TTCN_Typedescriptor("Option_dtlsSrtpProfiles", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor Option_freebind_descr_ = new TTCN_Typedescriptor("Option_freebind", RAW.TitanBoolean_raw_, null);
	public static final TTCN_Typedescriptor Option_alpn__list_descr_ = new TTCN_Typedescriptor("Option_alpn__list", null, null);
	public static final TTCN_Typedescriptor Option_alpn__list_0_descr_ = new TTCN_Typedescriptor("Option_alpn__list_0", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor Option_tls__hostname_descr_ = new TTCN_Typedescriptor("Option_tls__hostname", RAW.TitanCharString_raw_, null);
	public static final TTCN_Typedescriptor UDP__ENCAP__Param_descr_ = new TTCN_Typedescriptor("UDP__ENCAP__Param", null, null);
	public static final TTCN_Typedescriptor Option_dscp_descr_ = new TTCN_Typedescriptor("Option_dscp", RAW.TitanInteger_raw_, null);
	public static final TTCN_Typedescriptor OptionList_descr_ = new TTCN_Typedescriptor("OptionList", null, null);
	public static final TTCN_Typedescriptor ASP__Send_descr_ = new TTCN_Typedescriptor("ASP__Send", null, null);
	public static final TTCN_Typedescriptor ASP__Send_msg_descr_ = new TTCN_Typedescriptor("ASP__Send_msg", RAW.TitanOctetString_raw_, null);
	public static final TTCN_Typedescriptor ASP__SendTo_descr_ = new TTCN_Typedescriptor("ASP__SendTo", null, null);
	public static final TTCN_Typedescriptor ASP__SendTo_msg_descr_ = new TTCN_Typedescriptor("ASP__SendTo_msg", RAW.TitanOctetString_raw_, null);
	public static final TTCN_Typedescriptor ASP__RecvFrom_descr_ = new TTCN_Typedescriptor("ASP__RecvFrom", null, null);
	public static final TTCN_Typedescriptor ASP__RecvFrom_msg_descr_ = new TTCN_Typedescriptor("ASP__RecvFrom_msg", RAW.TitanOctetString_raw_, null);
	public static final TTCN_Typedescriptor ASP__ConnId__ReadyToRelease_descr_ = new TTCN_Typedescriptor("ASP__ConnId__ReadyToRelease", null, null);
public static final Socket__API__Definitions.PortError IPL4__ERROR__GENERAL = new Socket__API__Definitions.PortError();
public static final Socket__API__Definitions.PortError IPL4__ERROR__INSUFFICIENT__MEMORY = new Socket__API__Definitions.PortError();
public static final Socket__API__Definitions.PortError IPL4__ERROR__INVALID__INPUT__PARAMETER = new Socket__API__Definitions.PortError();
public static final Socket__API__Definitions.PortError IPL4__ERROR__UNSUPPORTED__TRANSPORT = new Socket__API__Definitions.PortError();
public static final Socket__API__Definitions.PortError IPL4__ERROR__SOCKET = new Socket__API__Definitions.PortError();
public static final Socket__API__Definitions.PortError IPL4__ERROR__HOSTNAME = new Socket__API__Definitions.PortError();
public static final Socket__API__Definitions.PortError IPL4__ERROR__INVALID__CONNECTION = new Socket__API__Definitions.PortError();
public static final Socket__API__Definitions.PortError IPL4__ERROR__TEMPORARILY__UNAVAILABLE = new Socket__API__Definitions.PortError();
public static final Socket__API__Definitions.PortError IPL4__ERROR__AVAILABLE = new Socket__API__Definitions.PortError();
	public static final TTCN_Typedescriptor IPL4__Param_descr_ = new TTCN_Typedescriptor("IPL4__Param", null, null);
	public static final TTCN_Typedescriptor IPL4__ParamResult_descr_ = new TTCN_Typedescriptor("IPL4__ParamResult", null, null);
	public static final TTCN_Typedescriptor IPL4__ParamResult_userData_descr_ = new TTCN_Typedescriptor("IPL4__ParamResult_userData", RAW.TitanInteger_raw_, null);
	public static final TTCN_Typedescriptor IPL4__IPAddressType_descr_ = new TTCN_Typedescriptor("IPL4__IPAddressType", null, null);
	public static final TTCN_Typedescriptor IPL4__SrtpKeysAndSalts_descr_ = new TTCN_Typedescriptor("IPL4__SrtpKeysAndSalts", null, null);
	public static final TTCN_Typedescriptor IPL4__SrtpKeysAndSalts_localKey_descr_ = new TTCN_Typedescriptor("IPL4__SrtpKeysAndSalts_localKey", RAW.TitanOctetString_raw_, null);
	public static final TTCN_Typedescriptor IPL4__SrtpKeysAndSalts_remoteKey_descr_ = new TTCN_Typedescriptor("IPL4__SrtpKeysAndSalts_remoteKey", RAW.TitanOctetString_raw_, null);
	public static final TTCN_Typedescriptor IPL4__SrtpKeysAndSalts_localSalt_descr_ = new TTCN_Typedescriptor("IPL4__SrtpKeysAndSalts_localSalt", RAW.TitanOctetString_raw_, null);
	public static final TTCN_Typedescriptor IPL4__SrtpKeysAndSalts_remoteSalt_descr_ = new TTCN_Typedescriptor("IPL4__SrtpKeysAndSalts_remoteSalt", RAW.TitanOctetString_raw_, null);
	public static final TTCN_Typedescriptor IPL4__DigestMethods_descr_ = new TTCN_Typedescriptor("IPL4__DigestMethods", null, null);
public static final TitanCharString c__IPL4__DTLS__SRTP__AES128__CM__SHA1__32__Profile = new TitanCharString();
public static final TitanCharString c__IPL4__DTLS__SRTP__AES128__CM__SHA1__80__Profile = new TitanCharString();
public static final TitanCharString c__IPL4__DTLS__SRTP__AES128__F8__SHA1__80__Profile = new TitanCharString();
public static final TitanCharString c__IPL4__DTLS__SRTP__AES128__F8__SHA1__32__Profile = new TitanCharString();
public static final TitanCharString c__IPL4__DTLS__SRTP__NULL__SHA1__80__Profile = new TitanCharString();
public static final TitanCharString c__IPL4__DTLS__SRTP__NULL__SHA1__32__Profile = new TitanCharString();
public static final TitanCharString c__IPL4__DTLS__SRTP__ALL__KNOWN__Profile = new TitanCharString();
	public static final TTCN_Typedescriptor anytype_descr_ = new TTCN_Typedescriptor("anytype", null, null);

	public IPL4asp__Types() {
		super("IPL4asp_Types", module_type_enum.TTCN3_MODULE, new byte[] {(byte)19, (byte)166, (byte)31, (byte)124, (byte)103, (byte)43, (byte)159, (byte)94, (byte)244, (byte)243, (byte)198, (byte)15, (byte)17, (byte)119, (byte)206, (byte)30});
	}

	public static class SSL__protocols extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_SSLv2__supported,  ALT_SSLv3__supported,  ALT_TLSv1__supported,  ALT_TLSv1__1__supported,  ALT_TLSv1__2__supported,  ALT_DTLSv1__supported,  ALT_DTLSv1__2__supported };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;

		public SSL__protocols() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};

		public SSL__protocols(final SSL__protocols otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final SSL__protocols other_value) {
			switch (other_value.union_selection){
			case ALT_SSLv2__supported:
				field = new TitanBoolean((TitanBoolean)other_value.field);
				break;
			case ALT_SSLv3__supported:
				field = new TitanBoolean((TitanBoolean)other_value.field);
				break;
			case ALT_TLSv1__supported:
				field = new TitanBoolean((TitanBoolean)other_value.field);
				break;
			case ALT_TLSv1__1__supported:
				field = new TitanBoolean((TitanBoolean)other_value.field);
				break;
			case ALT_TLSv1__2__supported:
				field = new TitanBoolean((TitanBoolean)other_value.field);
				break;
			case ALT_DTLSv1__supported:
				field = new TitanBoolean((TitanBoolean)other_value.field);
				break;
			case ALT_DTLSv1__2__supported:
				field = new TitanBoolean((TitanBoolean)other_value.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @IPL4asp_Types.SSL_protocols.");
			}
			union_selection = other_value.union_selection;
		}

		public SSL__protocols operator_assign( final SSL__protocols otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_value(otherValue);
			}

			return this;
		}

		@Override
		public SSL__protocols operator_assign( final Base_Type otherValue ) {
			if (otherValue instanceof SSL__protocols) {
				return operator_assign((SSL__protocols)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.SSL_protocols.");
		}

		@Override
		public void clean_up() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean ischosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.SSL_protocols.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean is_bound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean is_value() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_SSLv2__supported:
				return field.is_value();
			case ALT_SSLv3__supported:
				return field.is_value();
			case ALT_TLSv1__supported:
				return field.is_value();
			case ALT_TLSv1__1__supported:
				return field.is_value();
			case ALT_TLSv1__2__supported:
				return field.is_value();
			case ALT_DTLSv1__supported:
				return field.is_value();
			case ALT_DTLSv1__2__supported:
				return field.is_value();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		public boolean operator_equals( final SSL__protocols otherValue ) {
			must_bound( "The left operand of comparison is an unbound value of union type @IPL4asp_Types.SSL_protocols." );
			otherValue.must_bound( "The right operand of comparison is an unbound value of union type @IPL4asp_Types.SSL_protocols." );
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_SSLv2__supported:
				return ((TitanBoolean)field).operator_equals((TitanBoolean)otherValue.field);
			case ALT_SSLv3__supported:
				return ((TitanBoolean)field).operator_equals((TitanBoolean)otherValue.field);
			case ALT_TLSv1__supported:
				return ((TitanBoolean)field).operator_equals((TitanBoolean)otherValue.field);
			case ALT_TLSv1__1__supported:
				return ((TitanBoolean)field).operator_equals((TitanBoolean)otherValue.field);
			case ALT_TLSv1__2__supported:
				return ((TitanBoolean)field).operator_equals((TitanBoolean)otherValue.field);
			case ALT_DTLSv1__supported:
				return ((TitanBoolean)field).operator_equals((TitanBoolean)otherValue.field);
			case ALT_DTLSv1__2__supported:
				return ((TitanBoolean)field).operator_equals((TitanBoolean)otherValue.field);
			default:
				return false;
			}
		}

		@Override
		public boolean operator_equals( final Base_Type otherValue ) {
			if (otherValue instanceof SSL__protocols) {
				return operator_equals((SSL__protocols)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.SSL_protocols.");
		}

		public boolean operator_not_equals( final SSL__protocols otherValue ) {
			return !operator_equals(otherValue);
		}

		public TitanBoolean get_field_SSLv2__supported() {
			if (union_selection != union_selection_type.ALT_SSLv2__supported) {
				clean_up();
				field = new TitanBoolean();
				union_selection = union_selection_type.ALT_SSLv2__supported;
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean constGet_field_SSLv2__supported() {
			if (union_selection != union_selection_type.ALT_SSLv2__supported) {
				throw new TtcnError("Using non-selected field SSLv2_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean get_field_SSLv3__supported() {
			if (union_selection != union_selection_type.ALT_SSLv3__supported) {
				clean_up();
				field = new TitanBoolean();
				union_selection = union_selection_type.ALT_SSLv3__supported;
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean constGet_field_SSLv3__supported() {
			if (union_selection != union_selection_type.ALT_SSLv3__supported) {
				throw new TtcnError("Using non-selected field SSLv3_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean get_field_TLSv1__supported() {
			if (union_selection != union_selection_type.ALT_TLSv1__supported) {
				clean_up();
				field = new TitanBoolean();
				union_selection = union_selection_type.ALT_TLSv1__supported;
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean constGet_field_TLSv1__supported() {
			if (union_selection != union_selection_type.ALT_TLSv1__supported) {
				throw new TtcnError("Using non-selected field TLSv1_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean get_field_TLSv1__1__supported() {
			if (union_selection != union_selection_type.ALT_TLSv1__1__supported) {
				clean_up();
				field = new TitanBoolean();
				union_selection = union_selection_type.ALT_TLSv1__1__supported;
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean constGet_field_TLSv1__1__supported() {
			if (union_selection != union_selection_type.ALT_TLSv1__1__supported) {
				throw new TtcnError("Using non-selected field TLSv1_1_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean get_field_TLSv1__2__supported() {
			if (union_selection != union_selection_type.ALT_TLSv1__2__supported) {
				clean_up();
				field = new TitanBoolean();
				union_selection = union_selection_type.ALT_TLSv1__2__supported;
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean constGet_field_TLSv1__2__supported() {
			if (union_selection != union_selection_type.ALT_TLSv1__2__supported) {
				throw new TtcnError("Using non-selected field TLSv1_2_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean get_field_DTLSv1__supported() {
			if (union_selection != union_selection_type.ALT_DTLSv1__supported) {
				clean_up();
				field = new TitanBoolean();
				union_selection = union_selection_type.ALT_DTLSv1__supported;
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean constGet_field_DTLSv1__supported() {
			if (union_selection != union_selection_type.ALT_DTLSv1__supported) {
				throw new TtcnError("Using non-selected field DTLSv1_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean get_field_DTLSv1__2__supported() {
			if (union_selection != union_selection_type.ALT_DTLSv1__2__supported) {
				clean_up();
				field = new TitanBoolean();
				union_selection = union_selection_type.ALT_DTLSv1__2__supported;
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean constGet_field_DTLSv1__2__supported() {
			if (union_selection != union_selection_type.ALT_DTLSv1__2__supported) {
				throw new TtcnError("Using non-selected field DTLSv1_2_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}

		@Override
		public void log() {
			switch (union_selection) {
			case ALT_SSLv2__supported:
				TTCN_Logger.log_event_str("{ SSLv2_supported := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_SSLv3__supported:
				TTCN_Logger.log_event_str("{ SSLv3_supported := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_TLSv1__supported:
				TTCN_Logger.log_event_str("{ TLSv1_supported := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_TLSv1__1__supported:
				TTCN_Logger.log_event_str("{ TLSv1_1_supported := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_TLSv1__2__supported:
				TTCN_Logger.log_event_str("{ TLSv1_2_supported := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_DTLSv1__supported:
				TTCN_Logger.log_event_str("{ DTLSv1_supported := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_DTLSv1__2__supported:
				TTCN_Logger.log_event_str("{ DTLSv1_2_supported := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("SSLv2_supported".equals(last_name)) {
				get_field_SSLv2__supported().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("SSLv3_supported".equals(last_name)) {
				get_field_SSLv3__supported().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("TLSv1_supported".equals(last_name)) {
				get_field_TLSv1__supported().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("TLSv1_1_supported".equals(last_name)) {
				get_field_TLSv1__1__supported().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("TLSv1_2_supported".equals(last_name)) {
				get_field_TLSv1__2__supported().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("DTLSv1_supported".equals(last_name)) {
				get_field_DTLSv1__supported().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("DTLSv1_2_supported".equals(last_name)) {
				get_field_DTLSv1__2__supported().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @IPL4asp_Types.SSL_protocols.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_SSLv2__supported:
			case ALT_SSLv3__supported:
			case ALT_TLSv1__supported:
			case ALT_TLSv1__1__supported:
			case ALT_TLSv1__2__supported:
			case ALT_DTLSv1__supported:
			case ALT_DTLSv1__2__supported:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_SSLv2__supported:
				text_buf.push_int(1);
				break;
			case ALT_SSLv3__supported:
				text_buf.push_int(2);
				break;
			case ALT_TLSv1__supported:
				text_buf.push_int(3);
				break;
			case ALT_TLSv1__1__supported:
				text_buf.push_int(4);
				break;
			case ALT_TLSv1__2__supported:
				text_buf.push_int(5);
				break;
			case ALT_DTLSv1__supported:
				text_buf.push_int(6);
				break;
			case ALT_DTLSv1__2__supported:
				text_buf.push_int(7);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @IPL4asp_Types.SSL_protocols.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().get_int();
			switch (temp) {
			case 1:
				get_field_SSLv2__supported().decode_text(text_buf);
				break;
			case 2:
				get_field_SSLv3__supported().decode_text(text_buf);
				break;
			case 3:
				get_field_TLSv1__supported().decode_text(text_buf);
				break;
			case 4:
				get_field_TLSv1__1__supported().decode_text(text_buf);
				break;
			case 5:
				get_field_TLSv1__2__supported().decode_text(text_buf);
				break;
			case 6:
				get_field_DTLSv1__supported().decode_text(text_buf);
				break;
			case 7:
				get_field_DTLSv1__2__supported().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @IPL4asp_Types.SSL_protocols.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class SSL__protocols_template extends Base_Template {
		//if single value which value?
		private SSL__protocols.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<SSL__protocols_template> value_list;

		private void copy_value(final SSL__protocols other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_SSLv2__supported:
				single_value = new TitanBoolean_template(other_value.constGet_field_SSLv2__supported());
				break;
			case ALT_SSLv3__supported:
				single_value = new TitanBoolean_template(other_value.constGet_field_SSLv3__supported());
				break;
			case ALT_TLSv1__supported:
				single_value = new TitanBoolean_template(other_value.constGet_field_TLSv1__supported());
				break;
			case ALT_TLSv1__1__supported:
				single_value = new TitanBoolean_template(other_value.constGet_field_TLSv1__1__supported());
				break;
			case ALT_TLSv1__2__supported:
				single_value = new TitanBoolean_template(other_value.constGet_field_TLSv1__2__supported());
				break;
			case ALT_DTLSv1__supported:
				single_value = new TitanBoolean_template(other_value.constGet_field_DTLSv1__supported());
				break;
			case ALT_DTLSv1__2__supported:
				single_value = new TitanBoolean_template(other_value.constGet_field_DTLSv1__2__supported());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @IPL4asp_Types.SSL_protocols.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final SSL__protocols_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_SSLv2__supported:
					single_value = new TitanBoolean_template(other_value.constGet_field_SSLv2__supported());
					break;
				case ALT_SSLv3__supported:
					single_value = new TitanBoolean_template(other_value.constGet_field_SSLv3__supported());
					break;
				case ALT_TLSv1__supported:
					single_value = new TitanBoolean_template(other_value.constGet_field_TLSv1__supported());
					break;
				case ALT_TLSv1__1__supported:
					single_value = new TitanBoolean_template(other_value.constGet_field_TLSv1__1__supported());
					break;
				case ALT_TLSv1__2__supported:
					single_value = new TitanBoolean_template(other_value.constGet_field_TLSv1__2__supported());
					break;
				case ALT_DTLSv1__supported:
					single_value = new TitanBoolean_template(other_value.constGet_field_DTLSv1__supported());
					break;
				case ALT_DTLSv1__2__supported:
					single_value = new TitanBoolean_template(other_value.constGet_field_DTLSv1__2__supported());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @IPL4asp_Types.SSL_protocols.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<SSL__protocols_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final SSL__protocols_template temp = new SSL__protocols_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @IPL4asp_Types.SSL_protocols.");
			}
			set_selection(other_value);
		}

		public SSL__protocols_template() {
			// do nothing
		}
		public SSL__protocols_template(final template_sel other_value) {
			super(other_value);
			check_single_selection(other_value);
		}
		public SSL__protocols_template(final SSL__protocols other_value) {
			copy_value(other_value);
		}
		public SSL__protocols_template(final SSL__protocols_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_SSLv2__supported:
					((TitanBoolean_template)single_value).clean_up();
					break;
				case ALT_SSLv3__supported:
					((TitanBoolean_template)single_value).clean_up();
					break;
				case ALT_TLSv1__supported:
					((TitanBoolean_template)single_value).clean_up();
					break;
				case ALT_TLSv1__1__supported:
					((TitanBoolean_template)single_value).clean_up();
					break;
				case ALT_TLSv1__2__supported:
					((TitanBoolean_template)single_value).clean_up();
					break;
				case ALT_DTLSv1__supported:
					((TitanBoolean_template)single_value).clean_up();
					break;
				case ALT_DTLSv1__2__supported:
					((TitanBoolean_template)single_value).clean_up();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		@Override
		public SSL__protocols_template operator_assign(final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public SSL__protocols_template operator_assign(final SSL__protocols otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public SSL__protocols_template operator_assign(final SSL__protocols_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public SSL__protocols_template operator_assign(final Base_Type otherValue ) {
			if (otherValue instanceof SSL__protocols) {
				return operator_assign((SSL__protocols)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to SSL__protocols.");
		}

		@Override
		public SSL__protocols_template operator_assign(final Base_Template otherValue ) {
			if (otherValue instanceof SSL__protocols_template) {
				return operator_assign((SSL__protocols_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to SSL__protocols_template.");
		}

		public boolean match(final SSL__protocols other_value) {
			return match(other_value, false);
		}

		public boolean match(final SSL__protocols other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final SSL__protocols.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == SSL__protocols.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_SSLv2__supported:
					return ((TitanBoolean_template)single_value).match(other_value.get_field_SSLv2__supported(), legacy);
				case ALT_SSLv3__supported:
					return ((TitanBoolean_template)single_value).match(other_value.get_field_SSLv3__supported(), legacy);
				case ALT_TLSv1__supported:
					return ((TitanBoolean_template)single_value).match(other_value.get_field_TLSv1__supported(), legacy);
				case ALT_TLSv1__1__supported:
					return ((TitanBoolean_template)single_value).match(other_value.get_field_TLSv1__1__supported(), legacy);
				case ALT_TLSv1__2__supported:
					return ((TitanBoolean_template)single_value).match(other_value.get_field_TLSv1__2__supported(), legacy);
				case ALT_DTLSv1__supported:
					return ((TitanBoolean_template)single_value).match(other_value.get_field_DTLSv1__supported(), legacy);
				case ALT_DTLSv1__2__supported:
					return ((TitanBoolean_template)single_value).match(other_value.get_field_DTLSv1__2__supported(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @IPL4asp_Types.SSL_protocols.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof SSL__protocols) {
				return match((SSL__protocols)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type SSL__protocols.");
		}

		public boolean ischosen(final SSL__protocols.union_selection_type checked_selection) {
			if(checked_selection == SSL__protocols.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.SSL_protocols.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == SSL__protocols.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @IPL4asp_Types.SSL_protocols.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @IPL4asp_Types.SSL_protocols containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).ischosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_SSLv2__supported:
				return ((TitanBoolean_template)single_value).is_value();
			case ALT_SSLv3__supported:
				return ((TitanBoolean_template)single_value).is_value();
			case ALT_TLSv1__supported:
				return ((TitanBoolean_template)single_value).is_value();
			case ALT_TLSv1__1__supported:
				return ((TitanBoolean_template)single_value).is_value();
			case ALT_TLSv1__2__supported:
				return ((TitanBoolean_template)single_value).is_value();
			case ALT_DTLSv1__supported:
				return ((TitanBoolean_template)single_value).is_value();
			case ALT_DTLSv1__2__supported:
				return ((TitanBoolean_template)single_value).is_value();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @IPL4asp_Types.SSL_protocols.");
			}
		}

		@Override
		public SSL__protocols valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
			}
			final SSL__protocols ret_val = new SSL__protocols();
			switch (single_value_union_selection) {
			case ALT_SSLv2__supported:
				ret_val.get_field_SSLv2__supported().operator_assign(((TitanBoolean_template)single_value).valueof());
				break;
			case ALT_SSLv3__supported:
				ret_val.get_field_SSLv3__supported().operator_assign(((TitanBoolean_template)single_value).valueof());
				break;
			case ALT_TLSv1__supported:
				ret_val.get_field_TLSv1__supported().operator_assign(((TitanBoolean_template)single_value).valueof());
				break;
			case ALT_TLSv1__1__supported:
				ret_val.get_field_TLSv1__1__supported().operator_assign(((TitanBoolean_template)single_value).valueof());
				break;
			case ALT_TLSv1__2__supported:
				ret_val.get_field_TLSv1__2__supported().operator_assign(((TitanBoolean_template)single_value).valueof());
				break;
			case ALT_DTLSv1__supported:
				ret_val.get_field_DTLSv1__supported().operator_assign(((TitanBoolean_template)single_value).valueof());
				break;
			case ALT_DTLSv1__2__supported:
				ret_val.get_field_DTLSv1__2__supported().operator_assign(((TitanBoolean_template)single_value).valueof());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @IPL4asp_Types.SSL_protocols.");
			}
			return ret_val;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @IPL4asp_Types.SSL_protocols.");
			}
			clean_up();
			set_selection(template_type);
			value_list = new ArrayList<SSL__protocols_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new SSL__protocols_template());
			}
		}

		@Override
		public SSL__protocols_template list_item(final int list_index)  {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @IPL4asp_Types.SSL_protocols.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.SSL_protocols using a negative index ({0}).", list_index));
			} else if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @IPL4asp_Types.SSL_protocols.");
			}
			return value_list.get(list_index);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public TitanBoolean_template get_field_SSLv2__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != SSL__protocols.union_selection_type.ALT_SSLv2__supported) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanBoolean_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanBoolean_template();
				}
				single_value_union_selection = SSL__protocols.union_selection_type.ALT_SSLv2__supported;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template constGet_field_SSLv2__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field SSLv2_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
			}
			if (single_value_union_selection != SSL__protocols.union_selection_type.ALT_SSLv2__supported) {
				throw new TtcnError("Accessing non-selected field SSLv2_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template get_field_SSLv3__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != SSL__protocols.union_selection_type.ALT_SSLv3__supported) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanBoolean_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanBoolean_template();
				}
				single_value_union_selection = SSL__protocols.union_selection_type.ALT_SSLv3__supported;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template constGet_field_SSLv3__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field SSLv3_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
			}
			if (single_value_union_selection != SSL__protocols.union_selection_type.ALT_SSLv3__supported) {
				throw new TtcnError("Accessing non-selected field SSLv3_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template get_field_TLSv1__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != SSL__protocols.union_selection_type.ALT_TLSv1__supported) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanBoolean_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanBoolean_template();
				}
				single_value_union_selection = SSL__protocols.union_selection_type.ALT_TLSv1__supported;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template constGet_field_TLSv1__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field TLSv1_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
			}
			if (single_value_union_selection != SSL__protocols.union_selection_type.ALT_TLSv1__supported) {
				throw new TtcnError("Accessing non-selected field TLSv1_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template get_field_TLSv1__1__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != SSL__protocols.union_selection_type.ALT_TLSv1__1__supported) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanBoolean_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanBoolean_template();
				}
				single_value_union_selection = SSL__protocols.union_selection_type.ALT_TLSv1__1__supported;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template constGet_field_TLSv1__1__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field TLSv1_1_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
			}
			if (single_value_union_selection != SSL__protocols.union_selection_type.ALT_TLSv1__1__supported) {
				throw new TtcnError("Accessing non-selected field TLSv1_1_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template get_field_TLSv1__2__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != SSL__protocols.union_selection_type.ALT_TLSv1__2__supported) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanBoolean_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanBoolean_template();
				}
				single_value_union_selection = SSL__protocols.union_selection_type.ALT_TLSv1__2__supported;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template constGet_field_TLSv1__2__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field TLSv1_2_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
			}
			if (single_value_union_selection != SSL__protocols.union_selection_type.ALT_TLSv1__2__supported) {
				throw new TtcnError("Accessing non-selected field TLSv1_2_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template get_field_DTLSv1__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != SSL__protocols.union_selection_type.ALT_DTLSv1__supported) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanBoolean_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanBoolean_template();
				}
				single_value_union_selection = SSL__protocols.union_selection_type.ALT_DTLSv1__supported;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template constGet_field_DTLSv1__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field DTLSv1_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
			}
			if (single_value_union_selection != SSL__protocols.union_selection_type.ALT_DTLSv1__supported) {
				throw new TtcnError("Accessing non-selected field DTLSv1_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template get_field_DTLSv1__2__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != SSL__protocols.union_selection_type.ALT_DTLSv1__2__supported) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanBoolean_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanBoolean_template();
				}
				single_value_union_selection = SSL__protocols.union_selection_type.ALT_DTLSv1__2__supported;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template constGet_field_DTLSv1__2__supported() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field DTLSv1_2_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
			}
			if (single_value_union_selection != SSL__protocols.union_selection_type.ALT_DTLSv1__2__supported) {
				throw new TtcnError("Accessing non-selected field DTLSv1_2_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
			}
			return (TitanBoolean_template)single_value;
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof SSL__protocols) {
				log_match((SSL__protocols)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.SSL_protocols.");
		}

		public void log_match(final SSL__protocols match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_SSLv2__supported:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".SSLv2_supported");
						single_value.log_match(match_value.get_field_SSLv2__supported(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ SSLv2_supported := ");
						single_value.log_match(match_value.get_field_SSLv2__supported(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_SSLv3__supported:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".SSLv3_supported");
						single_value.log_match(match_value.get_field_SSLv3__supported(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ SSLv3_supported := ");
						single_value.log_match(match_value.get_field_SSLv3__supported(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_TLSv1__supported:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".TLSv1_supported");
						single_value.log_match(match_value.get_field_TLSv1__supported(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ TLSv1_supported := ");
						single_value.log_match(match_value.get_field_TLSv1__supported(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_TLSv1__1__supported:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".TLSv1_1_supported");
						single_value.log_match(match_value.get_field_TLSv1__1__supported(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ TLSv1_1_supported := ");
						single_value.log_match(match_value.get_field_TLSv1__1__supported(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_TLSv1__2__supported:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".TLSv1_2_supported");
						single_value.log_match(match_value.get_field_TLSv1__2__supported(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ TLSv1_2_supported := ");
						single_value.log_match(match_value.get_field_TLSv1__2__supported(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_DTLSv1__supported:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".DTLSv1_supported");
						single_value.log_match(match_value.get_field_DTLSv1__supported(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ DTLSv1_supported := ");
						single_value.log_match(match_value.get_field_DTLSv1__supported(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_DTLSv1__2__supported:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".DTLSv1_2_supported");
						single_value.log_match(match_value.get_field_DTLSv1__2__supported(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ DTLSv1_2_supported := ");
						single_value.log_match(match_value.get_field_DTLSv1__2__supported(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
					break;
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @IPL4asp_Types.SSL_protocols.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().get_int();
				switch (temp) {
				case 0:
					single_value = new TitanBoolean_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new TitanBoolean_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new TitanBoolean_template();
					single_value.decode_text(text_buf);
					break;
				case 3:
					single_value = new TitanBoolean_template();
					single_value.decode_text(text_buf);
					break;
				case 4:
					single_value = new TitanBoolean_template();
					single_value.decode_text(text_buf);
					break;
				case 5:
					single_value = new TitanBoolean_template();
					single_value.decode_text(text_buf);
					break;
				case 6:
					single_value = new TitanBoolean_template();
					single_value.decode_text(text_buf);
					break;
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				value_list = new ArrayList<SSL__protocols_template>(size);
				for (int i = 0; i < size; i++) {
					final SSL__protocols_template temp2 = new SSL__protocols_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @IPL4asp_Types.SSL_protocols.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@IPL4asp_Types.SSL_protocols");
				}
				if("SSLv2_supported".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("SSLv3_supported".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("TLSv1_supported".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("TLSv1_1_supported".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("TLSv1_2_supported".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("DTLSv1_supported".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("DTLSv1_2_supported".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@IPL4asp_Types.SSL_protocols");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("SSLv2_supported".equals(last_name)) {
					get_field_SSLv2__supported().set_param(mp_last);
					break;
				}
				if("SSLv3_supported".equals(last_name)) {
					get_field_SSLv3__supported().set_param(mp_last);
					break;
				}
				if("TLSv1_supported".equals(last_name)) {
					get_field_TLSv1__supported().set_param(mp_last);
					break;
				}
				if("TLSv1_1_supported".equals(last_name)) {
					get_field_TLSv1__1__supported().set_param(mp_last);
					break;
				}
				if("TLSv1_2_supported".equals(last_name)) {
					get_field_TLSv1__2__supported().set_param(mp_last);
					break;
				}
				if("DTLSv1_supported".equals(last_name)) {
					get_field_DTLSv1__supported().set_param(mp_last);
					break;
				}
				if("DTLSv1_2_supported".equals(last_name)) {
					get_field_DTLSv1__2__supported().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @IPL4asp_Types.SSL_protocols.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@IPL4asp_Types.SSL_protocols");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_SSLv2__supported:
					((TitanBoolean_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_protocols" : name, legacy);
					return;
				case ALT_SSLv3__supported:
					((TitanBoolean_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_protocols" : name, legacy);
					return;
				case ALT_TLSv1__supported:
					((TitanBoolean_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_protocols" : name, legacy);
					return;
				case ALT_TLSv1__1__supported:
					((TitanBoolean_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_protocols" : name, legacy);
					return;
				case ALT_TLSv1__2__supported:
					((TitanBoolean_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_protocols" : name, legacy);
					return;
				case ALT_DTLSv1__supported:
					((TitanBoolean_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_protocols" : name, legacy);
					return;
				case ALT_DTLSv1__2__supported:
					((TitanBoolean_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_protocols" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @IPL4asp_Types.SSL_protocols.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.SSL_protocols" : name));
		}
	}
	public static class IPL4__ParamResult extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_local,  ALT_remote,  ALT_proto,  ALT_userData,  ALT_parentIdx };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;

		public IPL4__ParamResult() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};

		public IPL4__ParamResult(final IPL4__ParamResult otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final IPL4__ParamResult other_value) {
			switch (other_value.union_selection){
			case ALT_local:
				field = new Socket__API__Definitions.Socket((Socket__API__Definitions.Socket)other_value.field);
				break;
			case ALT_remote:
				field = new Socket__API__Definitions.Socket((Socket__API__Definitions.Socket)other_value.field);
				break;
			case ALT_proto:
				field = new Socket__API__Definitions.ProtoTuple((Socket__API__Definitions.ProtoTuple)other_value.field);
				break;
			case ALT_userData:
				field = new TitanInteger((TitanInteger)other_value.field);
				break;
			case ALT_parentIdx:
				field = new TitanInteger((TitanInteger)other_value.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @IPL4asp_Types.IPL4_ParamResult.");
			}
			union_selection = other_value.union_selection;
		}

		public IPL4__ParamResult operator_assign( final IPL4__ParamResult otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_value(otherValue);
			}

			return this;
		}

		@Override
		public IPL4__ParamResult operator_assign( final Base_Type otherValue ) {
			if (otherValue instanceof IPL4__ParamResult) {
				return operator_assign((IPL4__ParamResult)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.IPL4_ParamResult.");
		}

		@Override
		public void clean_up() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean ischosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean is_bound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean is_value() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_local:
				return field.is_value();
			case ALT_remote:
				return field.is_value();
			case ALT_proto:
				return field.is_value();
			case ALT_userData:
				return field.is_value();
			case ALT_parentIdx:
				return field.is_value();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		public boolean operator_equals( final IPL4__ParamResult otherValue ) {
			must_bound( "The left operand of comparison is an unbound value of union type @IPL4asp_Types.IPL4_ParamResult." );
			otherValue.must_bound( "The right operand of comparison is an unbound value of union type @IPL4asp_Types.IPL4_ParamResult." );
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_local:
				return ((Socket__API__Definitions.Socket)field).operator_equals((Socket__API__Definitions.Socket)otherValue.field);
			case ALT_remote:
				return ((Socket__API__Definitions.Socket)field).operator_equals((Socket__API__Definitions.Socket)otherValue.field);
			case ALT_proto:
				return ((Socket__API__Definitions.ProtoTuple)field).operator_equals((Socket__API__Definitions.ProtoTuple)otherValue.field);
			case ALT_userData:
				return ((TitanInteger)field).operator_equals((TitanInteger)otherValue.field);
			case ALT_parentIdx:
				return ((TitanInteger)field).operator_equals((TitanInteger)otherValue.field);
			default:
				return false;
			}
		}

		@Override
		public boolean operator_equals( final Base_Type otherValue ) {
			if (otherValue instanceof IPL4__ParamResult) {
				return operator_equals((IPL4__ParamResult)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.IPL4_ParamResult.");
		}

		public boolean operator_not_equals( final IPL4__ParamResult otherValue ) {
			return !operator_equals(otherValue);
		}

		public Socket__API__Definitions.Socket get_field_local() {
			if (union_selection != union_selection_type.ALT_local) {
				clean_up();
				field = new Socket__API__Definitions.Socket();
				union_selection = union_selection_type.ALT_local;
			}
			return (Socket__API__Definitions.Socket)field;
		}

		public Socket__API__Definitions.Socket constGet_field_local() {
			if (union_selection != union_selection_type.ALT_local) {
				throw new TtcnError("Using non-selected field local in a value of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return (Socket__API__Definitions.Socket)field;
		}

		public Socket__API__Definitions.Socket get_field_remote() {
			if (union_selection != union_selection_type.ALT_remote) {
				clean_up();
				field = new Socket__API__Definitions.Socket();
				union_selection = union_selection_type.ALT_remote;
			}
			return (Socket__API__Definitions.Socket)field;
		}

		public Socket__API__Definitions.Socket constGet_field_remote() {
			if (union_selection != union_selection_type.ALT_remote) {
				throw new TtcnError("Using non-selected field remote in a value of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return (Socket__API__Definitions.Socket)field;
		}

		public Socket__API__Definitions.ProtoTuple get_field_proto() {
			if (union_selection != union_selection_type.ALT_proto) {
				clean_up();
				field = new Socket__API__Definitions.ProtoTuple();
				union_selection = union_selection_type.ALT_proto;
			}
			return (Socket__API__Definitions.ProtoTuple)field;
		}

		public Socket__API__Definitions.ProtoTuple constGet_field_proto() {
			if (union_selection != union_selection_type.ALT_proto) {
				throw new TtcnError("Using non-selected field proto in a value of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return (Socket__API__Definitions.ProtoTuple)field;
		}

		public TitanInteger get_field_userData() {
			if (union_selection != union_selection_type.ALT_userData) {
				clean_up();
				field = new TitanInteger();
				union_selection = union_selection_type.ALT_userData;
			}
			return (TitanInteger)field;
		}

		public TitanInteger constGet_field_userData() {
			if (union_selection != union_selection_type.ALT_userData) {
				throw new TtcnError("Using non-selected field userData in a value of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return (TitanInteger)field;
		}

		public TitanInteger get_field_parentIdx() {
			if (union_selection != union_selection_type.ALT_parentIdx) {
				clean_up();
				field = new TitanInteger();
				union_selection = union_selection_type.ALT_parentIdx;
			}
			return (TitanInteger)field;
		}

		public TitanInteger constGet_field_parentIdx() {
			if (union_selection != union_selection_type.ALT_parentIdx) {
				throw new TtcnError("Using non-selected field parentIdx in a value of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return (TitanInteger)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}

		@Override
		public void log() {
			switch (union_selection) {
			case ALT_local:
				TTCN_Logger.log_event_str("{ local := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_remote:
				TTCN_Logger.log_event_str("{ remote := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_proto:
				TTCN_Logger.log_event_str("{ proto := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_userData:
				TTCN_Logger.log_event_str("{ userData := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_parentIdx:
				TTCN_Logger.log_event_str("{ parentIdx := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("local".equals(last_name)) {
				get_field_local().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("remote".equals(last_name)) {
				get_field_remote().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("proto".equals(last_name)) {
				get_field_proto().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("userData".equals(last_name)) {
				get_field_userData().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("parentIdx".equals(last_name)) {
				get_field_parentIdx().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @IPL4asp_Types.IPL4_ParamResult.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_local:
			case ALT_remote:
			case ALT_proto:
			case ALT_userData:
			case ALT_parentIdx:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_local:
				text_buf.push_int(1);
				break;
			case ALT_remote:
				text_buf.push_int(2);
				break;
			case ALT_proto:
				text_buf.push_int(3);
				break;
			case ALT_userData:
				text_buf.push_int(4);
				break;
			case ALT_parentIdx:
				text_buf.push_int(5);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().get_int();
			switch (temp) {
			case 1:
				get_field_local().decode_text(text_buf);
				break;
			case 2:
				get_field_remote().decode_text(text_buf);
				break;
			case 3:
				get_field_proto().decode_text(text_buf);
				break;
			case 4:
				get_field_userData().decode_text(text_buf);
				break;
			case 5:
				get_field_parentIdx().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @IPL4asp_Types.IPL4_ParamResult.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class IPL4__ParamResult_template extends Base_Template {
		//if single value which value?
		private IPL4__ParamResult.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<IPL4__ParamResult_template> value_list;

		private void copy_value(final IPL4__ParamResult other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_local:
				single_value = new Socket__API__Definitions.Socket_template(other_value.constGet_field_local());
				break;
			case ALT_remote:
				single_value = new Socket__API__Definitions.Socket_template(other_value.constGet_field_remote());
				break;
			case ALT_proto:
				single_value = new Socket__API__Definitions.ProtoTuple_template(other_value.constGet_field_proto());
				break;
			case ALT_userData:
				single_value = new TitanInteger_template(other_value.constGet_field_userData());
				break;
			case ALT_parentIdx:
				single_value = new TitanInteger_template(other_value.constGet_field_parentIdx());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @IPL4asp_Types.IPL4_ParamResult.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final IPL4__ParamResult_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_local:
					single_value = new Socket__API__Definitions.Socket_template(other_value.constGet_field_local());
					break;
				case ALT_remote:
					single_value = new Socket__API__Definitions.Socket_template(other_value.constGet_field_remote());
					break;
				case ALT_proto:
					single_value = new Socket__API__Definitions.ProtoTuple_template(other_value.constGet_field_proto());
					break;
				case ALT_userData:
					single_value = new TitanInteger_template(other_value.constGet_field_userData());
					break;
				case ALT_parentIdx:
					single_value = new TitanInteger_template(other_value.constGet_field_parentIdx());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @IPL4asp_Types.IPL4_ParamResult.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<IPL4__ParamResult_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final IPL4__ParamResult_template temp = new IPL4__ParamResult_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			set_selection(other_value);
		}

		public IPL4__ParamResult_template() {
			// do nothing
		}
		public IPL4__ParamResult_template(final template_sel other_value) {
			super(other_value);
			check_single_selection(other_value);
		}
		public IPL4__ParamResult_template(final IPL4__ParamResult other_value) {
			copy_value(other_value);
		}
		public IPL4__ParamResult_template(final IPL4__ParamResult_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_local:
					((Socket__API__Definitions.Socket_template)single_value).clean_up();
					break;
				case ALT_remote:
					((Socket__API__Definitions.Socket_template)single_value).clean_up();
					break;
				case ALT_proto:
					((Socket__API__Definitions.ProtoTuple_template)single_value).clean_up();
					break;
				case ALT_userData:
					((TitanInteger_template)single_value).clean_up();
					break;
				case ALT_parentIdx:
					((TitanInteger_template)single_value).clean_up();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		@Override
		public IPL4__ParamResult_template operator_assign(final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public IPL4__ParamResult_template operator_assign(final IPL4__ParamResult otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public IPL4__ParamResult_template operator_assign(final IPL4__ParamResult_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public IPL4__ParamResult_template operator_assign(final Base_Type otherValue ) {
			if (otherValue instanceof IPL4__ParamResult) {
				return operator_assign((IPL4__ParamResult)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to IPL4__ParamResult.");
		}

		@Override
		public IPL4__ParamResult_template operator_assign(final Base_Template otherValue ) {
			if (otherValue instanceof IPL4__ParamResult_template) {
				return operator_assign((IPL4__ParamResult_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to IPL4__ParamResult_template.");
		}

		public boolean match(final IPL4__ParamResult other_value) {
			return match(other_value, false);
		}

		public boolean match(final IPL4__ParamResult other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final IPL4__ParamResult.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == IPL4__ParamResult.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_local:
					return ((Socket__API__Definitions.Socket_template)single_value).match(other_value.get_field_local(), legacy);
				case ALT_remote:
					return ((Socket__API__Definitions.Socket_template)single_value).match(other_value.get_field_remote(), legacy);
				case ALT_proto:
					return ((Socket__API__Definitions.ProtoTuple_template)single_value).match(other_value.get_field_proto(), legacy);
				case ALT_userData:
					return ((TitanInteger_template)single_value).match(other_value.get_field_userData(), legacy);
				case ALT_parentIdx:
					return ((TitanInteger_template)single_value).match(other_value.get_field_parentIdx(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @IPL4asp_Types.IPL4_ParamResult.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof IPL4__ParamResult) {
				return match((IPL4__ParamResult)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type IPL4__ParamResult.");
		}

		public boolean ischosen(final IPL4__ParamResult.union_selection_type checked_selection) {
			if(checked_selection == IPL4__ParamResult.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == IPL4__ParamResult.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @IPL4asp_Types.IPL4_ParamResult.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @IPL4asp_Types.IPL4_ParamResult containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).ischosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_local:
				return ((Socket__API__Definitions.Socket_template)single_value).is_value();
			case ALT_remote:
				return ((Socket__API__Definitions.Socket_template)single_value).is_value();
			case ALT_proto:
				return ((Socket__API__Definitions.ProtoTuple_template)single_value).is_value();
			case ALT_userData:
				return ((TitanInteger_template)single_value).is_value();
			case ALT_parentIdx:
				return ((TitanInteger_template)single_value).is_value();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
		}

		@Override
		public IPL4__ParamResult valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			final IPL4__ParamResult ret_val = new IPL4__ParamResult();
			switch (single_value_union_selection) {
			case ALT_local:
				ret_val.get_field_local().operator_assign(((Socket__API__Definitions.Socket_template)single_value).valueof());
				break;
			case ALT_remote:
				ret_val.get_field_remote().operator_assign(((Socket__API__Definitions.Socket_template)single_value).valueof());
				break;
			case ALT_proto:
				ret_val.get_field_proto().operator_assign(((Socket__API__Definitions.ProtoTuple_template)single_value).valueof());
				break;
			case ALT_userData:
				ret_val.get_field_userData().operator_assign(((TitanInteger_template)single_value).valueof());
				break;
			case ALT_parentIdx:
				ret_val.get_field_parentIdx().operator_assign(((TitanInteger_template)single_value).valueof());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return ret_val;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			clean_up();
			set_selection(template_type);
			value_list = new ArrayList<IPL4__ParamResult_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new IPL4__ParamResult_template());
			}
		}

		@Override
		public IPL4__ParamResult_template list_item(final int list_index)  {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.IPL4_ParamResult using a negative index ({0}).", list_index));
			} else if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return value_list.get(list_index);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public Socket__API__Definitions.Socket_template get_field_local() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != IPL4__ParamResult.union_selection_type.ALT_local) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Socket__API__Definitions.Socket_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Socket__API__Definitions.Socket_template();
				}
				single_value_union_selection = IPL4__ParamResult.union_selection_type.ALT_local;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Socket__API__Definitions.Socket_template)single_value;
		}

		public Socket__API__Definitions.Socket_template constGet_field_local() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field local in a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			if (single_value_union_selection != IPL4__ParamResult.union_selection_type.ALT_local) {
				throw new TtcnError("Accessing non-selected field local in a template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return (Socket__API__Definitions.Socket_template)single_value;
		}

		public Socket__API__Definitions.Socket_template get_field_remote() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != IPL4__ParamResult.union_selection_type.ALT_remote) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Socket__API__Definitions.Socket_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Socket__API__Definitions.Socket_template();
				}
				single_value_union_selection = IPL4__ParamResult.union_selection_type.ALT_remote;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Socket__API__Definitions.Socket_template)single_value;
		}

		public Socket__API__Definitions.Socket_template constGet_field_remote() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field remote in a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			if (single_value_union_selection != IPL4__ParamResult.union_selection_type.ALT_remote) {
				throw new TtcnError("Accessing non-selected field remote in a template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return (Socket__API__Definitions.Socket_template)single_value;
		}

		public Socket__API__Definitions.ProtoTuple_template get_field_proto() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != IPL4__ParamResult.union_selection_type.ALT_proto) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Socket__API__Definitions.ProtoTuple_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Socket__API__Definitions.ProtoTuple_template();
				}
				single_value_union_selection = IPL4__ParamResult.union_selection_type.ALT_proto;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Socket__API__Definitions.ProtoTuple_template)single_value;
		}

		public Socket__API__Definitions.ProtoTuple_template constGet_field_proto() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field proto in a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			if (single_value_union_selection != IPL4__ParamResult.union_selection_type.ALT_proto) {
				throw new TtcnError("Accessing non-selected field proto in a template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return (Socket__API__Definitions.ProtoTuple_template)single_value;
		}

		public TitanInteger_template get_field_userData() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != IPL4__ParamResult.union_selection_type.ALT_userData) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanInteger_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanInteger_template();
				}
				single_value_union_selection = IPL4__ParamResult.union_selection_type.ALT_userData;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanInteger_template)single_value;
		}

		public TitanInteger_template constGet_field_userData() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field userData in a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			if (single_value_union_selection != IPL4__ParamResult.union_selection_type.ALT_userData) {
				throw new TtcnError("Accessing non-selected field userData in a template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return (TitanInteger_template)single_value;
		}

		public TitanInteger_template get_field_parentIdx() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != IPL4__ParamResult.union_selection_type.ALT_parentIdx) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanInteger_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanInteger_template();
				}
				single_value_union_selection = IPL4__ParamResult.union_selection_type.ALT_parentIdx;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanInteger_template)single_value;
		}

		public TitanInteger_template constGet_field_parentIdx() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field parentIdx in a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			if (single_value_union_selection != IPL4__ParamResult.union_selection_type.ALT_parentIdx) {
				throw new TtcnError("Accessing non-selected field parentIdx in a template of union type @IPL4asp_Types.IPL4_ParamResult.");
			}
			return (TitanInteger_template)single_value;
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof IPL4__ParamResult) {
				log_match((IPL4__ParamResult)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.IPL4_ParamResult.");
		}

		public void log_match(final IPL4__ParamResult match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_local:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".local");
						single_value.log_match(match_value.get_field_local(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ local := ");
						single_value.log_match(match_value.get_field_local(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_remote:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".remote");
						single_value.log_match(match_value.get_field_remote(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ remote := ");
						single_value.log_match(match_value.get_field_remote(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_proto:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".proto");
						single_value.log_match(match_value.get_field_proto(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ proto := ");
						single_value.log_match(match_value.get_field_proto(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_userData:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".userData");
						single_value.log_match(match_value.get_field_userData(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ userData := ");
						single_value.log_match(match_value.get_field_userData(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_parentIdx:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".parentIdx");
						single_value.log_match(match_value.get_field_parentIdx(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ parentIdx := ");
						single_value.log_match(match_value.get_field_parentIdx(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
					break;
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @IPL4asp_Types.IPL4_ParamResult.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().get_int();
				switch (temp) {
				case 0:
					single_value = new Socket__API__Definitions.Socket_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new Socket__API__Definitions.Socket_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new Socket__API__Definitions.ProtoTuple_template();
					single_value.decode_text(text_buf);
					break;
				case 3:
					single_value = new TitanInteger_template();
					single_value.decode_text(text_buf);
					break;
				case 4:
					single_value = new TitanInteger_template();
					single_value.decode_text(text_buf);
					break;
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				value_list = new ArrayList<IPL4__ParamResult_template>(size);
				for (int i = 0; i < size; i++) {
					final IPL4__ParamResult_template temp2 = new IPL4__ParamResult_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @IPL4asp_Types.IPL4_ParamResult.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@IPL4asp_Types.IPL4_ParamResult");
				}
				if("local".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("remote".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("proto".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("userData".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("parentIdx".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@IPL4asp_Types.IPL4_ParamResult");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("local".equals(last_name)) {
					get_field_local().set_param(mp_last);
					break;
				}
				if("remote".equals(last_name)) {
					get_field_remote().set_param(mp_last);
					break;
				}
				if("proto".equals(last_name)) {
					get_field_proto().set_param(mp_last);
					break;
				}
				if("userData".equals(last_name)) {
					get_field_userData().set_param(mp_last);
					break;
				}
				if("parentIdx".equals(last_name)) {
					get_field_parentIdx().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @IPL4asp_Types.IPL4_ParamResult.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@IPL4asp_Types.IPL4_ParamResult");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_local:
					((Socket__API__Definitions.Socket_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.IPL4_ParamResult" : name, legacy);
					return;
				case ALT_remote:
					((Socket__API__Definitions.Socket_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.IPL4_ParamResult" : name, legacy);
					return;
				case ALT_proto:
					((Socket__API__Definitions.ProtoTuple_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.IPL4_ParamResult" : name, legacy);
					return;
				case ALT_userData:
					((TitanInteger_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.IPL4_ParamResult" : name, legacy);
					return;
				case ALT_parentIdx:
					((TitanInteger_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.IPL4_ParamResult" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @IPL4asp_Types.IPL4_ParamResult.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.IPL4_ParamResult" : name));
		}
	}
	public static class SSL__cert__options extends Base_Type {
		private final Optional<TitanCharString> ssl__key__file;
		private final Optional<TitanCharString> ssl__certificate__file;
		private final Optional<TitanCharString> ssl__trustedCAlist__file;
		private final Optional<TitanCharString> ssl__cipher__list;
		private final Optional<TitanCharString> ssl__password;

		public SSL__cert__options() {
			this.ssl__key__file = new Optional<TitanCharString>(TitanCharString.class);
			this.ssl__certificate__file = new Optional<TitanCharString>(TitanCharString.class);
			this.ssl__trustedCAlist__file = new Optional<TitanCharString>(TitanCharString.class);
			this.ssl__cipher__list = new Optional<TitanCharString>(TitanCharString.class);
			this.ssl__password = new Optional<TitanCharString>(TitanCharString.class);
		}

		public SSL__cert__options(final Optional<TitanCharString> ssl__key__file, final Optional<TitanCharString> ssl__certificate__file, final Optional<TitanCharString> ssl__trustedCAlist__file, final Optional<TitanCharString> ssl__cipher__list, final Optional<TitanCharString> ssl__password ) {
			this.ssl__key__file = new Optional<TitanCharString>(TitanCharString.class);
			this.ssl__key__file.operator_assign( ssl__key__file );
			this.ssl__certificate__file = new Optional<TitanCharString>(TitanCharString.class);
			this.ssl__certificate__file.operator_assign( ssl__certificate__file );
			this.ssl__trustedCAlist__file = new Optional<TitanCharString>(TitanCharString.class);
			this.ssl__trustedCAlist__file.operator_assign( ssl__trustedCAlist__file );
			this.ssl__cipher__list = new Optional<TitanCharString>(TitanCharString.class);
			this.ssl__cipher__list.operator_assign( ssl__cipher__list );
			this.ssl__password = new Optional<TitanCharString>(TitanCharString.class);
			this.ssl__password.operator_assign( ssl__password );
		}

		public SSL__cert__options( final SSL__cert__options otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.SSL_cert_options.");
			ssl__key__file = new Optional<TitanCharString>(TitanCharString.class);
			ssl__certificate__file = new Optional<TitanCharString>(TitanCharString.class);
			ssl__trustedCAlist__file = new Optional<TitanCharString>(TitanCharString.class);
			ssl__cipher__list = new Optional<TitanCharString>(TitanCharString.class);
			ssl__password = new Optional<TitanCharString>(TitanCharString.class);
			operator_assign( otherValue );
		}

		public SSL__cert__options operator_assign(final SSL__cert__options otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.SSL_cert_options");
			if (otherValue != this) {
				if ( otherValue.get_field_ssl__key__file().is_bound() ) {
					this.ssl__key__file.operator_assign( otherValue.get_field_ssl__key__file() );
				} else {
					this.ssl__key__file.clean_up();
				}
				if ( otherValue.get_field_ssl__certificate__file().is_bound() ) {
					this.ssl__certificate__file.operator_assign( otherValue.get_field_ssl__certificate__file() );
				} else {
					this.ssl__certificate__file.clean_up();
				}
				if ( otherValue.get_field_ssl__trustedCAlist__file().is_bound() ) {
					this.ssl__trustedCAlist__file.operator_assign( otherValue.get_field_ssl__trustedCAlist__file() );
				} else {
					this.ssl__trustedCAlist__file.clean_up();
				}
				if ( otherValue.get_field_ssl__cipher__list().is_bound() ) {
					this.ssl__cipher__list.operator_assign( otherValue.get_field_ssl__cipher__list() );
				} else {
					this.ssl__cipher__list.clean_up();
				}
				if ( otherValue.get_field_ssl__password().is_bound() ) {
					this.ssl__password.operator_assign( otherValue.get_field_ssl__password() );
				} else {
					this.ssl__password.clean_up();
				}
			}

			return this;
		}

		@Override
		public SSL__cert__options operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof SSL__cert__options ) {
				return operator_assign((SSL__cert__options) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.SSL_cert_options", otherValue));
		}

		@Override
		public void clean_up() {
			ssl__key__file.clean_up();
			ssl__certificate__file.clean_up();
			ssl__trustedCAlist__file.clean_up();
			ssl__cipher__list.clean_up();
			ssl__password.clean_up();
		}

		@Override
		public boolean is_bound() {
			return optional_sel.OPTIONAL_OMIT.equals(ssl__key__file.get_selection()) || ssl__key__file.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(ssl__certificate__file.get_selection()) || ssl__certificate__file.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(ssl__trustedCAlist__file.get_selection()) || ssl__trustedCAlist__file.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(ssl__cipher__list.get_selection()) || ssl__cipher__list.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(ssl__password.get_selection()) || ssl__password.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return (optional_sel.OPTIONAL_OMIT.equals(ssl__key__file.get_selection()) || ssl__key__file.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(ssl__certificate__file.get_selection()) || ssl__certificate__file.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(ssl__trustedCAlist__file.get_selection()) || ssl__trustedCAlist__file.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(ssl__cipher__list.get_selection()) || ssl__cipher__list.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(ssl__password.get_selection()) || ssl__password.is_value());
		}

		public boolean operator_equals( final SSL__cert__options other_value) {
			return ssl__key__file.operator_equals( other_value.ssl__key__file )
					&& ssl__certificate__file.operator_equals( other_value.ssl__certificate__file )
					&& ssl__trustedCAlist__file.operator_equals( other_value.ssl__trustedCAlist__file )
					&& ssl__cipher__list.operator_equals( other_value.ssl__cipher__list )
					&& ssl__password.operator_equals( other_value.ssl__password );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof SSL__cert__options ) {
				return operator_equals((SSL__cert__options) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.SSL_cert_options", other_value));
		}

		public Optional<TitanCharString> get_field_ssl__key__file() {
			return ssl__key__file;
		}

		public Optional<TitanCharString> constGet_field_ssl__key__file() {
			return ssl__key__file;
		}

		public Optional<TitanCharString> get_field_ssl__certificate__file() {
			return ssl__certificate__file;
		}

		public Optional<TitanCharString> constGet_field_ssl__certificate__file() {
			return ssl__certificate__file;
		}

		public Optional<TitanCharString> get_field_ssl__trustedCAlist__file() {
			return ssl__trustedCAlist__file;
		}

		public Optional<TitanCharString> constGet_field_ssl__trustedCAlist__file() {
			return ssl__trustedCAlist__file;
		}

		public Optional<TitanCharString> get_field_ssl__cipher__list() {
			return ssl__cipher__list;
		}

		public Optional<TitanCharString> constGet_field_ssl__cipher__list() {
			return ssl__cipher__list;
		}

		public Optional<TitanCharString> get_field_ssl__password() {
			return ssl__password;
		}

		public Optional<TitanCharString> constGet_field_ssl__password() {
			return ssl__password;
		}

		public TitanInteger size_of() {
			int sizeof = 0;
			if (ssl__key__file.ispresent()) {
				sizeof++;
			}
			if (ssl__certificate__file.ispresent()) {
				sizeof++;
			}
			if (ssl__trustedCAlist__file.ispresent()) {
				sizeof++;
			}
			if (ssl__cipher__list.ispresent()) {
				sizeof++;
			}
			if (ssl__password.ispresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" ssl_key_file := ");
			ssl__key__file.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ssl_certificate_file := ");
			ssl__certificate__file.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ssl_trustedCAlist_file := ");
			ssl__trustedCAlist__file.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ssl_cipher_list := ");
			ssl__cipher__list.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ssl_password := ");
			ssl__password.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.SSL_cert_options has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_ssl__key__file().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_ssl__certificate__file().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_ssl__trustedCAlist__file().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_ssl__cipher__list().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_ssl__password().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ssl_key_file".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_ssl__key__file().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ssl_certificate_file".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_ssl__certificate__file().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ssl_trustedCAlist_file".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_ssl__trustedCAlist__file().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ssl_cipher_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_ssl__cipher__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ssl_password".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_ssl__password().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.SSL_cert_options: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.SSL_cert_options");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (ssl__key__file.is_bound()) {
				ssl__key__file.set_implicit_omit();
			} else {
				ssl__key__file.operator_assign(template_sel.OMIT_VALUE);
			}
			if (ssl__certificate__file.is_bound()) {
				ssl__certificate__file.set_implicit_omit();
			} else {
				ssl__certificate__file.operator_assign(template_sel.OMIT_VALUE);
			}
			if (ssl__trustedCAlist__file.is_bound()) {
				ssl__trustedCAlist__file.set_implicit_omit();
			} else {
				ssl__trustedCAlist__file.operator_assign(template_sel.OMIT_VALUE);
			}
			if (ssl__cipher__list.is_bound()) {
				ssl__cipher__list.set_implicit_omit();
			} else {
				ssl__cipher__list.operator_assign(template_sel.OMIT_VALUE);
			}
			if (ssl__password.is_bound()) {
				ssl__password.set_implicit_omit();
			} else {
				ssl__password.operator_assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			ssl__key__file.encode_text(text_buf);
			ssl__certificate__file.encode_text(text_buf);
			ssl__trustedCAlist__file.encode_text(text_buf);
			ssl__cipher__list.encode_text(text_buf);
			ssl__password.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			ssl__key__file.decode_text(text_buf);
			ssl__certificate__file.decode_text(text_buf);
			ssl__trustedCAlist__file.decode_text(text_buf);
			ssl__cipher__list.decode_text(text_buf);
			ssl__password.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class SSL__cert__options_template extends Base_Template {
		private TitanCharString_template ssl__key__file;
		private TitanCharString_template ssl__certificate__file;
		private TitanCharString_template ssl__trustedCAlist__file;
		private TitanCharString_template ssl__cipher__list;
		private TitanCharString_template ssl__password;
		//originally value_list/list_value
		private List<SSL__cert__options_template> list_value;


		public SSL__cert__options_template() {
			// do nothing
		}

		public SSL__cert__options_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public SSL__cert__options_template( final SSL__cert__options otherValue ) {
			copy_value(otherValue);
		}

		public SSL__cert__options_template( final SSL__cert__options_template otherValue ) {
			copy_template( otherValue );
		}

		public SSL__cert__options_template( final Optional<SSL__cert__options> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.SSL_cert_options from an unbound optional field.");
			}
		}

		@Override
		public SSL__cert__options_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public SSL__cert__options_template operator_assign( final SSL__cert__options otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public SSL__cert__options_template operator_assign( final SSL__cert__options_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public SSL__cert__options_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof SSL__cert__options) {
				return operator_assign((SSL__cert__options) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `SSL__cert__options' can not be cast to {1}", otherValue));
		}

		@Override
		public SSL__cert__options_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof SSL__cert__options_template) {
				return operator_assign((SSL__cert__options_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `SSL__cert__options' can not be cast to {1}_template", otherValue));
		}

		public SSL__cert__options_template operator_assign( final Optional<SSL__cert__options> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.SSL_cert_options.");
			}
			return this;
		}

		private void copy_value(final SSL__cert__options other_value) {
			if (other_value.get_field_ssl__key__file().is_bound()) {
				if (other_value.get_field_ssl__key__file().ispresent()) {
					get_field_ssl__key__file().operator_assign(other_value.get_field_ssl__key__file().get());
				} else {
					get_field_ssl__key__file().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_ssl__key__file().clean_up();
			}
			if (other_value.get_field_ssl__certificate__file().is_bound()) {
				if (other_value.get_field_ssl__certificate__file().ispresent()) {
					get_field_ssl__certificate__file().operator_assign(other_value.get_field_ssl__certificate__file().get());
				} else {
					get_field_ssl__certificate__file().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_ssl__certificate__file().clean_up();
			}
			if (other_value.get_field_ssl__trustedCAlist__file().is_bound()) {
				if (other_value.get_field_ssl__trustedCAlist__file().ispresent()) {
					get_field_ssl__trustedCAlist__file().operator_assign(other_value.get_field_ssl__trustedCAlist__file().get());
				} else {
					get_field_ssl__trustedCAlist__file().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_ssl__trustedCAlist__file().clean_up();
			}
			if (other_value.get_field_ssl__cipher__list().is_bound()) {
				if (other_value.get_field_ssl__cipher__list().ispresent()) {
					get_field_ssl__cipher__list().operator_assign(other_value.get_field_ssl__cipher__list().get());
				} else {
					get_field_ssl__cipher__list().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_ssl__cipher__list().clean_up();
			}
			if (other_value.get_field_ssl__password().is_bound()) {
				if (other_value.get_field_ssl__password().ispresent()) {
					get_field_ssl__password().operator_assign(other_value.get_field_ssl__password().get());
				} else {
					get_field_ssl__password().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_ssl__password().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final SSL__cert__options_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_ssl__key__file().get_selection()) {
					get_field_ssl__key__file().clean_up();
				} else {
					get_field_ssl__key__file().operator_assign(other_value.get_field_ssl__key__file());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_ssl__certificate__file().get_selection()) {
					get_field_ssl__certificate__file().clean_up();
				} else {
					get_field_ssl__certificate__file().operator_assign(other_value.get_field_ssl__certificate__file());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_ssl__trustedCAlist__file().get_selection()) {
					get_field_ssl__trustedCAlist__file().clean_up();
				} else {
					get_field_ssl__trustedCAlist__file().operator_assign(other_value.get_field_ssl__trustedCAlist__file());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_ssl__cipher__list().get_selection()) {
					get_field_ssl__cipher__list().clean_up();
				} else {
					get_field_ssl__cipher__list().operator_assign(other_value.get_field_ssl__cipher__list());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_ssl__password().get_selection()) {
					get_field_ssl__password().clean_up();
				} else {
					get_field_ssl__password().operator_assign(other_value.get_field_ssl__password());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<SSL__cert__options_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final SSL__cert__options_template temp = new SSL__cert__options_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.SSL_cert_options.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.SSL_cert_options.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<SSL__cert__options_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new SSL__cert__options_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return ssl__key__file.is_omit() || ssl__key__file.is_bound()
					|| ssl__certificate__file.is_omit() || ssl__certificate__file.is_bound()
					|| ssl__trustedCAlist__file.is_omit() || ssl__trustedCAlist__file.is_bound()
					|| ssl__cipher__list.is_omit() || ssl__cipher__list.is_bound()
					|| ssl__password.is_omit() || ssl__password.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return (ssl__key__file.is_omit() || ssl__key__file.is_value())
					&& (ssl__certificate__file.is_omit() || ssl__certificate__file.is_value())
					&& (ssl__trustedCAlist__file.is_omit() || ssl__trustedCAlist__file.is_value())
					&& (ssl__cipher__list.is_omit() || ssl__cipher__list.is_value())
					&& (ssl__password.is_omit() || ssl__password.is_value());
		}
		public TitanCharString_template get_field_ssl__key__file() {
			set_specific();
			return ssl__key__file;
		}

		public TitanCharString_template constGet_field_ssl__key__file() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ssl_key_file of a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
			}
			return ssl__key__file;
		}

		public TitanCharString_template get_field_ssl__certificate__file() {
			set_specific();
			return ssl__certificate__file;
		}

		public TitanCharString_template constGet_field_ssl__certificate__file() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ssl_certificate_file of a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
			}
			return ssl__certificate__file;
		}

		public TitanCharString_template get_field_ssl__trustedCAlist__file() {
			set_specific();
			return ssl__trustedCAlist__file;
		}

		public TitanCharString_template constGet_field_ssl__trustedCAlist__file() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ssl_trustedCAlist_file of a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
			}
			return ssl__trustedCAlist__file;
		}

		public TitanCharString_template get_field_ssl__cipher__list() {
			set_specific();
			return ssl__cipher__list;
		}

		public TitanCharString_template constGet_field_ssl__cipher__list() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ssl_cipher_list of a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
			}
			return ssl__cipher__list;
		}

		public TitanCharString_template get_field_ssl__password() {
			set_specific();
			return ssl__password;
		}

		public TitanCharString_template constGet_field_ssl__password() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ssl_password of a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
			}
			return ssl__password;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					ssl__key__file = new TitanCharString_template(template_sel.ANY_OR_OMIT);
					ssl__certificate__file = new TitanCharString_template(template_sel.ANY_OR_OMIT);
					ssl__trustedCAlist__file = new TitanCharString_template(template_sel.ANY_OR_OMIT);
					ssl__cipher__list = new TitanCharString_template(template_sel.ANY_OR_OMIT);
					ssl__password = new TitanCharString_template(template_sel.ANY_OR_OMIT);
				} else {
					ssl__key__file = new TitanCharString_template();
					ssl__certificate__file = new TitanCharString_template();
					ssl__trustedCAlist__file = new TitanCharString_template();
					ssl__cipher__list = new TitanCharString_template();
					ssl__password = new TitanCharString_template();
				}
			}
		}
		public boolean match(final SSL__cert__options other_value) {
			return match(other_value, false);
		}

		public boolean match(final SSL__cert__options other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_ssl__key__file().is_bound()) {
					return false;
				}
				if((other_value.get_field_ssl__key__file().ispresent() ? !ssl__key__file.match(other_value.get_field_ssl__key__file().get(), legacy) : !ssl__key__file.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_ssl__certificate__file().is_bound()) {
					return false;
				}
				if((other_value.get_field_ssl__certificate__file().ispresent() ? !ssl__certificate__file.match(other_value.get_field_ssl__certificate__file().get(), legacy) : !ssl__certificate__file.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_ssl__trustedCAlist__file().is_bound()) {
					return false;
				}
				if((other_value.get_field_ssl__trustedCAlist__file().ispresent() ? !ssl__trustedCAlist__file.match(other_value.get_field_ssl__trustedCAlist__file().get(), legacy) : !ssl__trustedCAlist__file.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_ssl__cipher__list().is_bound()) {
					return false;
				}
				if((other_value.get_field_ssl__cipher__list().ispresent() ? !ssl__cipher__list.match(other_value.get_field_ssl__cipher__list().get(), legacy) : !ssl__cipher__list.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_ssl__password().is_bound()) {
					return false;
				}
				if((other_value.get_field_ssl__password().ispresent() ? !ssl__password.match(other_value.get_field_ssl__password().get(), legacy) : !ssl__password.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.SSL_cert_options.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof SSL__cert__options) {
				return match((SSL__cert__options)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type SSL__cert__options.");
		}


		@Override
		public SSL__cert__options valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
			}
			final SSL__cert__options ret_val = new SSL__cert__options();
			if (ssl__key__file.is_omit()) {
				ret_val.get_field_ssl__key__file().operator_assign(template_sel.OMIT_VALUE);
			} else if (ssl__key__file.is_bound()) {
				ret_val.get_field_ssl__key__file().operator_assign(ssl__key__file.valueof());
			}
			if (ssl__certificate__file.is_omit()) {
				ret_val.get_field_ssl__certificate__file().operator_assign(template_sel.OMIT_VALUE);
			} else if (ssl__certificate__file.is_bound()) {
				ret_val.get_field_ssl__certificate__file().operator_assign(ssl__certificate__file.valueof());
			}
			if (ssl__trustedCAlist__file.is_omit()) {
				ret_val.get_field_ssl__trustedCAlist__file().operator_assign(template_sel.OMIT_VALUE);
			} else if (ssl__trustedCAlist__file.is_bound()) {
				ret_val.get_field_ssl__trustedCAlist__file().operator_assign(ssl__trustedCAlist__file.valueof());
			}
			if (ssl__cipher__list.is_omit()) {
				ret_val.get_field_ssl__cipher__list().operator_assign(template_sel.OMIT_VALUE);
			} else if (ssl__cipher__list.is_bound()) {
				ret_val.get_field_ssl__cipher__list().operator_assign(ssl__cipher__list.valueof());
			}
			if (ssl__password.is_omit()) {
				ret_val.get_field_ssl__password().operator_assign(template_sel.OMIT_VALUE);
			} else if (ssl__password.is_bound()) {
				ret_val.get_field_ssl__password().operator_assign(ssl__password.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				int sizeof = 0;
				if (ssl__key__file.is_present()) {
					sizeof++;
				}
				if (ssl__certificate__file.is_present()) {
					sizeof++;
				}
				if (ssl__trustedCAlist__file.is_present()) {
					sizeof++;
				}
				if (ssl__cipher__list.is_present()) {
					sizeof++;
				}
				if (ssl__password.is_present()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.SSL_cert_options.");
			}
		}

		@Override
		public SSL__cert__options_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.SSL_cert_options.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.SSL_cert_options using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.SSL_cert_options.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" ssl_key_file := ");
				ssl__key__file.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ssl_certificate_file := ");
				ssl__certificate__file.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ssl_trustedCAlist_file := ");
				ssl__trustedCAlist__file.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ssl_cipher_list := ");
				ssl__cipher__list.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ssl_password := ");
				ssl__password.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final SSL__cert__options match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof SSL__cert__options) {
				log_match((SSL__cert__options)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.SSL_cert_options.");
		}

		public void log_match(final SSL__cert__options match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if (match_value.constGet_field_ssl__key__file().ispresent()) {
							if( !ssl__key__file.match(match_value.constGet_field_ssl__key__file().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".ssl_key_file");
								ssl__key__file.log_match(match_value.constGet_field_ssl__key__file().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!ssl__key__file.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".ssl_key_file := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								ssl__key__file.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_ssl__certificate__file().ispresent()) {
							if( !ssl__certificate__file.match(match_value.constGet_field_ssl__certificate__file().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".ssl_certificate_file");
								ssl__certificate__file.log_match(match_value.constGet_field_ssl__certificate__file().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!ssl__certificate__file.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".ssl_certificate_file := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								ssl__certificate__file.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_ssl__trustedCAlist__file().ispresent()) {
							if( !ssl__trustedCAlist__file.match(match_value.constGet_field_ssl__trustedCAlist__file().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".ssl_trustedCAlist_file");
								ssl__trustedCAlist__file.log_match(match_value.constGet_field_ssl__trustedCAlist__file().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!ssl__trustedCAlist__file.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".ssl_trustedCAlist_file := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								ssl__trustedCAlist__file.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_ssl__cipher__list().ispresent()) {
							if( !ssl__cipher__list.match(match_value.constGet_field_ssl__cipher__list().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".ssl_cipher_list");
								ssl__cipher__list.log_match(match_value.constGet_field_ssl__cipher__list().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!ssl__cipher__list.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".ssl_cipher_list := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								ssl__cipher__list.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_ssl__password().ispresent()) {
							if( !ssl__password.match(match_value.constGet_field_ssl__password().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".ssl_password");
								ssl__password.log_match(match_value.constGet_field_ssl__password().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!ssl__password.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".ssl_password := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								ssl__password.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ ssl_key_file := ");
				ssl__key__file.log_match(match_value.constGet_field_ssl__key__file(), legacy);
				TTCN_Logger.log_event_str("{ ssl_certificate_file := ");
				ssl__certificate__file.log_match(match_value.constGet_field_ssl__certificate__file(), legacy);
				TTCN_Logger.log_event_str("{ ssl_trustedCAlist_file := ");
				ssl__trustedCAlist__file.log_match(match_value.constGet_field_ssl__trustedCAlist__file(), legacy);
				TTCN_Logger.log_event_str("{ ssl_cipher_list := ");
				ssl__cipher__list.log_match(match_value.constGet_field_ssl__cipher__list(), legacy);
				TTCN_Logger.log_event_str("{ ssl_password := ");
				ssl__password.log_match(match_value.constGet_field_ssl__password(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				ssl__key__file.encode_text(text_buf);
				ssl__certificate__file.encode_text(text_buf);
				ssl__trustedCAlist__file.encode_text(text_buf);
				ssl__cipher__list.encode_text(text_buf);
				ssl__password.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.SSL_cert_options.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				ssl__key__file = new TitanCharString_template();
				ssl__key__file.decode_text(text_buf);
				ssl__certificate__file = new TitanCharString_template();
				ssl__certificate__file.decode_text(text_buf);
				ssl__trustedCAlist__file = new TitanCharString_template();
				ssl__trustedCAlist__file.decode_text(text_buf);
				ssl__cipher__list = new TitanCharString_template();
				ssl__cipher__list.decode_text(text_buf);
				ssl__password = new TitanCharString_template();
				ssl__password.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<SSL__cert__options_template>(size);
				for (int i = 0; i < size; i++) {
					final SSL__cert__options_template temp = new SSL__cert__options_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.SSL_cert_options.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.SSL_cert_options has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_ssl__key__file().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_ssl__certificate__file().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_ssl__trustedCAlist__file().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_ssl__cipher__list().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_ssl__password().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ssl_key_file".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_ssl__key__file().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ssl_certificate_file".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_ssl__certificate__file().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ssl_trustedCAlist_file".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_ssl__trustedCAlist__file().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ssl_cipher_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_ssl__cipher__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ssl_password".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_ssl__password().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.SSL_cert_options: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.SSL_cert_options");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.ssl__key__file.check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_cert_options" : name, legacy);
				this.ssl__certificate__file.check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_cert_options" : name, legacy);
				this.ssl__trustedCAlist__file.check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_cert_options" : name, legacy);
				this.ssl__cipher__list.check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_cert_options" : name, legacy);
				this.ssl__password.check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_cert_options" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.SSL_cert_options" : name));
		}
	}
	public static class UdpTuple extends Socket__API__Definitions.UdpTuple { }
	public static class UdpTuple_template extends Socket__API__Definitions.UdpTuple_template { }
	public static class ASP__RecvFrom extends Base_Type {
		private final TitanInteger connId;
		private final TitanCharString remName;
		private final TitanInteger remPort;
		private final TitanCharString locName;
		private final TitanInteger locPort;
		private final Socket__API__Definitions.ProtoTuple proto;
		private final TitanInteger userData;
		private final TitanOctetString msg;

		public ASP__RecvFrom() {
			this.connId = new TitanInteger();
			this.remName = new TitanCharString();
			this.remPort = new TitanInteger();
			this.locName = new TitanCharString();
			this.locPort = new TitanInteger();
			this.proto = new Socket__API__Definitions.ProtoTuple();
			this.userData = new TitanInteger();
			this.msg = new TitanOctetString();
		}

		public ASP__RecvFrom(final TitanInteger connId, final TitanCharString remName, final TitanInteger remPort, final TitanCharString locName, final TitanInteger locPort, final Socket__API__Definitions.ProtoTuple proto, final TitanInteger userData, final TitanOctetString msg ) {
			this.connId = new TitanInteger( connId );
			this.remName = new TitanCharString( remName );
			this.remPort = new TitanInteger( remPort );
			this.locName = new TitanCharString( locName );
			this.locPort = new TitanInteger( locPort );
			this.proto = new Socket__API__Definitions.ProtoTuple( proto );
			this.userData = new TitanInteger( userData );
			this.msg = new TitanOctetString( msg );
		}

		public ASP__RecvFrom( final ASP__RecvFrom otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.ASP_RecvFrom.");
			connId = new TitanInteger();
			remName = new TitanCharString();
			remPort = new TitanInteger();
			locName = new TitanCharString();
			locPort = new TitanInteger();
			proto = new Socket__API__Definitions.ProtoTuple();
			userData = new TitanInteger();
			msg = new TitanOctetString();
			operator_assign( otherValue );
		}

		public ASP__RecvFrom operator_assign(final ASP__RecvFrom otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.ASP_RecvFrom");
			if (otherValue != this) {
				if ( otherValue.get_field_connId().is_bound() ) {
					this.connId.operator_assign( otherValue.get_field_connId() );
				} else {
					this.connId.clean_up();
				}
				if ( otherValue.get_field_remName().is_bound() ) {
					this.remName.operator_assign( otherValue.get_field_remName() );
				} else {
					this.remName.clean_up();
				}
				if ( otherValue.get_field_remPort().is_bound() ) {
					this.remPort.operator_assign( otherValue.get_field_remPort() );
				} else {
					this.remPort.clean_up();
				}
				if ( otherValue.get_field_locName().is_bound() ) {
					this.locName.operator_assign( otherValue.get_field_locName() );
				} else {
					this.locName.clean_up();
				}
				if ( otherValue.get_field_locPort().is_bound() ) {
					this.locPort.operator_assign( otherValue.get_field_locPort() );
				} else {
					this.locPort.clean_up();
				}
				if ( otherValue.get_field_proto().is_bound() ) {
					this.proto.operator_assign( otherValue.get_field_proto() );
				} else {
					this.proto.clean_up();
				}
				if ( otherValue.get_field_userData().is_bound() ) {
					this.userData.operator_assign( otherValue.get_field_userData() );
				} else {
					this.userData.clean_up();
				}
				if ( otherValue.get_field_msg().is_bound() ) {
					this.msg.operator_assign( otherValue.get_field_msg() );
				} else {
					this.msg.clean_up();
				}
			}

			return this;
		}

		@Override
		public ASP__RecvFrom operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof ASP__RecvFrom ) {
				return operator_assign((ASP__RecvFrom) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.ASP_RecvFrom", otherValue));
		}

		@Override
		public void clean_up() {
			connId.clean_up();
			remName.clean_up();
			remPort.clean_up();
			locName.clean_up();
			locPort.clean_up();
			proto.clean_up();
			userData.clean_up();
			msg.clean_up();
		}

		@Override
		public boolean is_bound() {
			return connId.is_bound()
					|| remName.is_bound()
					|| remPort.is_bound()
					|| locName.is_bound()
					|| locPort.is_bound()
					|| proto.is_bound()
					|| userData.is_bound()
					|| msg.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return connId.is_value()
					&& remName.is_value()
					&& remPort.is_value()
					&& locName.is_value()
					&& locPort.is_value()
					&& proto.is_value()
					&& userData.is_value()
					&& msg.is_value();
		}

		public boolean operator_equals( final ASP__RecvFrom other_value) {
			return connId.operator_equals( other_value.connId )
					&& remName.operator_equals( other_value.remName )
					&& remPort.operator_equals( other_value.remPort )
					&& locName.operator_equals( other_value.locName )
					&& locPort.operator_equals( other_value.locPort )
					&& proto.operator_equals( other_value.proto )
					&& userData.operator_equals( other_value.userData )
					&& msg.operator_equals( other_value.msg );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof ASP__RecvFrom ) {
				return operator_equals((ASP__RecvFrom) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.ASP_RecvFrom", other_value));
		}

		public TitanInteger get_field_connId() {
			return connId;
		}

		public TitanInteger constGet_field_connId() {
			return connId;
		}

		public TitanCharString get_field_remName() {
			return remName;
		}

		public TitanCharString constGet_field_remName() {
			return remName;
		}

		public TitanInteger get_field_remPort() {
			return remPort;
		}

		public TitanInteger constGet_field_remPort() {
			return remPort;
		}

		public TitanCharString get_field_locName() {
			return locName;
		}

		public TitanCharString constGet_field_locName() {
			return locName;
		}

		public TitanInteger get_field_locPort() {
			return locPort;
		}

		public TitanInteger constGet_field_locPort() {
			return locPort;
		}

		public Socket__API__Definitions.ProtoTuple get_field_proto() {
			return proto;
		}

		public Socket__API__Definitions.ProtoTuple constGet_field_proto() {
			return proto;
		}

		public TitanInteger get_field_userData() {
			return userData;
		}

		public TitanInteger constGet_field_userData() {
			return userData;
		}

		public TitanOctetString get_field_msg() {
			return msg;
		}

		public TitanOctetString constGet_field_msg() {
			return msg;
		}

		public TitanInteger size_of() {
			return new TitanInteger(8);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" connId := ");
			connId.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" remName := ");
			remName.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" remPort := ");
			remPort.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" locName := ");
			locName.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" locPort := ");
			locPort.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" proto := ");
			proto.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" userData := ");
			userData.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msg := ");
			msg.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 8) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.ASP_RecvFrom has 8 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_connId().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remName().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remPort().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_locName().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_locPort().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_proto().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_userData().set_param(param.get_elem(6));
				}
				if (param.get_size() > 7 && param.get_elem(7).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_msg().set_param(param.get_elem(7));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("connId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_connId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remName".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remName().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remPort".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remPort().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("locName".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_locName().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("locPort".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_locPort().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("proto".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_proto().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("userData".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_userData().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msg".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_msg().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.ASP_RecvFrom: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.ASP_RecvFrom");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (connId.is_bound()) {
				connId.set_implicit_omit();
			}
			if (remName.is_bound()) {
				remName.set_implicit_omit();
			}
			if (remPort.is_bound()) {
				remPort.set_implicit_omit();
			}
			if (locName.is_bound()) {
				locName.set_implicit_omit();
			}
			if (locPort.is_bound()) {
				locPort.set_implicit_omit();
			}
			if (proto.is_bound()) {
				proto.set_implicit_omit();
			}
			if (userData.is_bound()) {
				userData.set_implicit_omit();
			}
			if (msg.is_bound()) {
				msg.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			connId.encode_text(text_buf);
			remName.encode_text(text_buf);
			remPort.encode_text(text_buf);
			locName.encode_text(text_buf);
			locPort.encode_text(text_buf);
			proto.encode_text(text_buf);
			userData.encode_text(text_buf);
			msg.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			connId.decode_text(text_buf);
			remName.decode_text(text_buf);
			remPort.decode_text(text_buf);
			locName.decode_text(text_buf);
			locPort.decode_text(text_buf);
			proto.decode_text(text_buf);
			userData.decode_text(text_buf);
			msg.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class ASP__RecvFrom_template extends Base_Template {
		private TitanInteger_template connId;
		private TitanCharString_template remName;
		private TitanInteger_template remPort;
		private TitanCharString_template locName;
		private TitanInteger_template locPort;
		private Socket__API__Definitions.ProtoTuple_template proto;
		private TitanInteger_template userData;
		private TitanOctetString_template msg;
		//originally value_list/list_value
		private List<ASP__RecvFrom_template> list_value;


		public ASP__RecvFrom_template() {
			// do nothing
		}

		public ASP__RecvFrom_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public ASP__RecvFrom_template( final ASP__RecvFrom otherValue ) {
			copy_value(otherValue);
		}

		public ASP__RecvFrom_template( final ASP__RecvFrom_template otherValue ) {
			copy_template( otherValue );
		}

		public ASP__RecvFrom_template( final Optional<ASP__RecvFrom> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.ASP_RecvFrom from an unbound optional field.");
			}
		}

		@Override
		public ASP__RecvFrom_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public ASP__RecvFrom_template operator_assign( final ASP__RecvFrom otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public ASP__RecvFrom_template operator_assign( final ASP__RecvFrom_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public ASP__RecvFrom_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof ASP__RecvFrom) {
				return operator_assign((ASP__RecvFrom) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ASP__RecvFrom' can not be cast to {1}", otherValue));
		}

		@Override
		public ASP__RecvFrom_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof ASP__RecvFrom_template) {
				return operator_assign((ASP__RecvFrom_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ASP__RecvFrom' can not be cast to {1}_template", otherValue));
		}

		public ASP__RecvFrom_template operator_assign( final Optional<ASP__RecvFrom> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			return this;
		}

		private void copy_value(final ASP__RecvFrom other_value) {
			if (other_value.get_field_connId().is_bound()) {
				get_field_connId().operator_assign(other_value.get_field_connId());
			} else {
				get_field_connId().clean_up();
			}
			if (other_value.get_field_remName().is_bound()) {
				get_field_remName().operator_assign(other_value.get_field_remName());
			} else {
				get_field_remName().clean_up();
			}
			if (other_value.get_field_remPort().is_bound()) {
				get_field_remPort().operator_assign(other_value.get_field_remPort());
			} else {
				get_field_remPort().clean_up();
			}
			if (other_value.get_field_locName().is_bound()) {
				get_field_locName().operator_assign(other_value.get_field_locName());
			} else {
				get_field_locName().clean_up();
			}
			if (other_value.get_field_locPort().is_bound()) {
				get_field_locPort().operator_assign(other_value.get_field_locPort());
			} else {
				get_field_locPort().clean_up();
			}
			if (other_value.get_field_proto().is_bound()) {
				get_field_proto().operator_assign(other_value.get_field_proto());
			} else {
				get_field_proto().clean_up();
			}
			if (other_value.get_field_userData().is_bound()) {
				get_field_userData().operator_assign(other_value.get_field_userData());
			} else {
				get_field_userData().clean_up();
			}
			if (other_value.get_field_msg().is_bound()) {
				get_field_msg().operator_assign(other_value.get_field_msg());
			} else {
				get_field_msg().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final ASP__RecvFrom_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_connId().get_selection()) {
					get_field_connId().clean_up();
				} else {
					get_field_connId().operator_assign(other_value.get_field_connId());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_remName().get_selection()) {
					get_field_remName().clean_up();
				} else {
					get_field_remName().operator_assign(other_value.get_field_remName());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_remPort().get_selection()) {
					get_field_remPort().clean_up();
				} else {
					get_field_remPort().operator_assign(other_value.get_field_remPort());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_locName().get_selection()) {
					get_field_locName().clean_up();
				} else {
					get_field_locName().operator_assign(other_value.get_field_locName());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_locPort().get_selection()) {
					get_field_locPort().clean_up();
				} else {
					get_field_locPort().operator_assign(other_value.get_field_locPort());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_proto().get_selection()) {
					get_field_proto().clean_up();
				} else {
					get_field_proto().operator_assign(other_value.get_field_proto());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_userData().get_selection()) {
					get_field_userData().clean_up();
				} else {
					get_field_userData().operator_assign(other_value.get_field_userData());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_msg().get_selection()) {
					get_field_msg().clean_up();
				} else {
					get_field_msg().operator_assign(other_value.get_field_msg());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ASP__RecvFrom_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ASP__RecvFrom_template temp = new ASP__RecvFrom_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<ASP__RecvFrom_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ASP__RecvFrom_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return connId.is_bound()
					|| remName.is_bound()
					|| remPort.is_bound()
					|| locName.is_bound()
					|| locPort.is_bound()
					|| proto.is_bound()
					|| userData.is_bound()
					|| msg.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return connId.is_value()
					&& remName.is_value()
					&& remPort.is_value()
					&& locName.is_value()
					&& locPort.is_value()
					&& proto.is_value()
					&& userData.is_value()
					&& msg.is_value();
		}
		public TitanInteger_template get_field_connId() {
			set_specific();
			return connId;
		}

		public TitanInteger_template constGet_field_connId() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field connId of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			return connId;
		}

		public TitanCharString_template get_field_remName() {
			set_specific();
			return remName;
		}

		public TitanCharString_template constGet_field_remName() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field remName of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			return remName;
		}

		public TitanInteger_template get_field_remPort() {
			set_specific();
			return remPort;
		}

		public TitanInteger_template constGet_field_remPort() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field remPort of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			return remPort;
		}

		public TitanCharString_template get_field_locName() {
			set_specific();
			return locName;
		}

		public TitanCharString_template constGet_field_locName() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field locName of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			return locName;
		}

		public TitanInteger_template get_field_locPort() {
			set_specific();
			return locPort;
		}

		public TitanInteger_template constGet_field_locPort() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field locPort of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			return locPort;
		}

		public Socket__API__Definitions.ProtoTuple_template get_field_proto() {
			set_specific();
			return proto;
		}

		public Socket__API__Definitions.ProtoTuple_template constGet_field_proto() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field proto of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			return proto;
		}

		public TitanInteger_template get_field_userData() {
			set_specific();
			return userData;
		}

		public TitanInteger_template constGet_field_userData() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field userData of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			return userData;
		}

		public TitanOctetString_template get_field_msg() {
			set_specific();
			return msg;
		}

		public TitanOctetString_template constGet_field_msg() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field msg of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			return msg;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					connId = new TitanInteger_template(template_sel.ANY_VALUE);
					remName = new TitanCharString_template(template_sel.ANY_VALUE);
					remPort = new TitanInteger_template(template_sel.ANY_VALUE);
					locName = new TitanCharString_template(template_sel.ANY_VALUE);
					locPort = new TitanInteger_template(template_sel.ANY_VALUE);
					proto = new Socket__API__Definitions.ProtoTuple_template(template_sel.ANY_VALUE);
					userData = new TitanInteger_template(template_sel.ANY_VALUE);
					msg = new TitanOctetString_template(template_sel.ANY_VALUE);
				} else {
					connId = new TitanInteger_template();
					remName = new TitanCharString_template();
					remPort = new TitanInteger_template();
					locName = new TitanCharString_template();
					locPort = new TitanInteger_template();
					proto = new Socket__API__Definitions.ProtoTuple_template();
					userData = new TitanInteger_template();
					msg = new TitanOctetString_template();
				}
			}
		}
		public boolean match(final ASP__RecvFrom other_value) {
			return match(other_value, false);
		}

		public boolean match(final ASP__RecvFrom other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_connId().is_bound()) {
					return false;
				}
				if(!connId.match(other_value.get_field_connId(), legacy)) {
					return false;
				}
				if(!other_value.get_field_remName().is_bound()) {
					return false;
				}
				if(!remName.match(other_value.get_field_remName(), legacy)) {
					return false;
				}
				if(!other_value.get_field_remPort().is_bound()) {
					return false;
				}
				if(!remPort.match(other_value.get_field_remPort(), legacy)) {
					return false;
				}
				if(!other_value.get_field_locName().is_bound()) {
					return false;
				}
				if(!locName.match(other_value.get_field_locName(), legacy)) {
					return false;
				}
				if(!other_value.get_field_locPort().is_bound()) {
					return false;
				}
				if(!locPort.match(other_value.get_field_locPort(), legacy)) {
					return false;
				}
				if(!other_value.get_field_proto().is_bound()) {
					return false;
				}
				if(!proto.match(other_value.get_field_proto(), legacy)) {
					return false;
				}
				if(!other_value.get_field_userData().is_bound()) {
					return false;
				}
				if(!userData.match(other_value.get_field_userData(), legacy)) {
					return false;
				}
				if(!other_value.get_field_msg().is_bound()) {
					return false;
				}
				if(!msg.match(other_value.get_field_msg(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ASP__RecvFrom) {
				return match((ASP__RecvFrom)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ASP__RecvFrom.");
		}


		@Override
		public ASP__RecvFrom valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			final ASP__RecvFrom ret_val = new ASP__RecvFrom();
			if (connId.is_bound()) {
				ret_val.get_field_connId().operator_assign(connId.valueof());
			}
			if (remName.is_bound()) {
				ret_val.get_field_remName().operator_assign(remName.valueof());
			}
			if (remPort.is_bound()) {
				ret_val.get_field_remPort().operator_assign(remPort.valueof());
			}
			if (locName.is_bound()) {
				ret_val.get_field_locName().operator_assign(locName.valueof());
			}
			if (locPort.is_bound()) {
				ret_val.get_field_locPort().operator_assign(locPort.valueof());
			}
			if (proto.is_bound()) {
				ret_val.get_field_proto().operator_assign(proto.valueof());
			}
			if (userData.is_bound()) {
				ret_val.get_field_userData().operator_assign(userData.valueof());
			}
			if (msg.is_bound()) {
				ret_val.get_field_msg().operator_assign(msg.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(8);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
		}

		@Override
		public ASP__RecvFrom_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.ASP_RecvFrom using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" connId := ");
				connId.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" remName := ");
				remName.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" remPort := ");
				remPort.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" locName := ");
				locName.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" locPort := ");
				locPort.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" proto := ");
				proto.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" userData := ");
				userData.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msg := ");
				msg.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ASP__RecvFrom match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ASP__RecvFrom) {
				log_match((ASP__RecvFrom)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.ASP_RecvFrom.");
		}

		public void log_match(final ASP__RecvFrom match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !connId.match(match_value.constGet_field_connId(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".connId");
							connId.log_match(match_value.constGet_field_connId(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !remName.match(match_value.constGet_field_remName(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".remName");
							remName.log_match(match_value.constGet_field_remName(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !remPort.match(match_value.constGet_field_remPort(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".remPort");
							remPort.log_match(match_value.constGet_field_remPort(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !locName.match(match_value.constGet_field_locName(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".locName");
							locName.log_match(match_value.constGet_field_locName(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !locPort.match(match_value.constGet_field_locPort(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".locPort");
							locPort.log_match(match_value.constGet_field_locPort(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !proto.match(match_value.constGet_field_proto(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".proto");
							proto.log_match(match_value.constGet_field_proto(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !userData.match(match_value.constGet_field_userData(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".userData");
							userData.log_match(match_value.constGet_field_userData(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !msg.match(match_value.constGet_field_msg(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msg");
							msg.log_match(match_value.constGet_field_msg(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ connId := ");
				connId.log_match(match_value.constGet_field_connId(), legacy);
				TTCN_Logger.log_event_str("{ remName := ");
				remName.log_match(match_value.constGet_field_remName(), legacy);
				TTCN_Logger.log_event_str("{ remPort := ");
				remPort.log_match(match_value.constGet_field_remPort(), legacy);
				TTCN_Logger.log_event_str("{ locName := ");
				locName.log_match(match_value.constGet_field_locName(), legacy);
				TTCN_Logger.log_event_str("{ locPort := ");
				locPort.log_match(match_value.constGet_field_locPort(), legacy);
				TTCN_Logger.log_event_str("{ proto := ");
				proto.log_match(match_value.constGet_field_proto(), legacy);
				TTCN_Logger.log_event_str("{ userData := ");
				userData.log_match(match_value.constGet_field_userData(), legacy);
				TTCN_Logger.log_event_str("{ msg := ");
				msg.log_match(match_value.constGet_field_msg(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				connId.encode_text(text_buf);
				remName.encode_text(text_buf);
				remPort.encode_text(text_buf);
				locName.encode_text(text_buf);
				locPort.encode_text(text_buf);
				proto.encode_text(text_buf);
				userData.encode_text(text_buf);
				msg.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				connId = new TitanInteger_template();
				connId.decode_text(text_buf);
				remName = new TitanCharString_template();
				remName.decode_text(text_buf);
				remPort = new TitanInteger_template();
				remPort.decode_text(text_buf);
				locName = new TitanCharString_template();
				locName.decode_text(text_buf);
				locPort = new TitanInteger_template();
				locPort.decode_text(text_buf);
				proto = new Socket__API__Definitions.ProtoTuple_template();
				proto.decode_text(text_buf);
				userData = new TitanInteger_template();
				userData.decode_text(text_buf);
				msg = new TitanOctetString_template();
				msg.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<ASP__RecvFrom_template>(size);
				for (int i = 0; i < size; i++) {
					final ASP__RecvFrom_template temp = new ASP__RecvFrom_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.ASP_RecvFrom.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 8) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.ASP_RecvFrom has 8 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_connId().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remName().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remPort().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_locName().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_locPort().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_proto().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_userData().set_param(param.get_elem(6));
				}
				if (param.get_size() > 7 && param.get_elem(7).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_msg().set_param(param.get_elem(7));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("connId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_connId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remName".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remName().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remPort".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remPort().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("locName".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_locName().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("locPort".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_locPort().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("proto".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_proto().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("userData".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_userData().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msg".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_msg().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.ASP_RecvFrom: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.ASP_RecvFrom");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.connId.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_RecvFrom" : name, legacy);
				this.remName.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_RecvFrom" : name, legacy);
				this.remPort.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_RecvFrom" : name, legacy);
				this.locName.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_RecvFrom" : name, legacy);
				this.locPort.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_RecvFrom" : name, legacy);
				this.proto.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_RecvFrom" : name, legacy);
				this.userData.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_RecvFrom" : name, legacy);
				this.msg.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_RecvFrom" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.ASP_RecvFrom" : name));
		}
	}
	public static class IPL4__DigestMethods extends Base_Type {
		public enum enum_type {
			NULL__method (0),
			MD4 (1),
			MD5 (2),
			SHA (3),
			SHA1 (4),
			DSS (5),
			DSS1 (6),
			ECDSA (7),
			SHA224 (8),
			SHA256 (9),
			SHA384 (10),
			SHA512 (11),
			MDC2 (12),
			RIPEMD160 (13),
			WHIRLPOOL (14),
			UNKNOWN_VALUE(15),
			UNBOUND_VALUE(16);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return NULL__method;
				case 1:  return MD4;
				case 2:  return MD5;
				case 3:  return SHA;
				case 4:  return SHA1;
				case 5:  return DSS;
				case 6:  return DSS1;
				case 7:  return ECDSA;
				case 8:  return SHA224;
				case 9:  return SHA256;
				case 10:  return SHA384;
				case 11:  return SHA512;
				case 12:  return MDC2;
				case 13:  return RIPEMD160;
				case 14:  return WHIRLPOOL;
				case 15:  return UNKNOWN_VALUE;
				case 16:  return UNBOUND_VALUE;

				default:
					return null;
				}
			}

			}

		public enum_type enum_value;
		//===Constructors===;
		public IPL4__DigestMethods() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public IPL4__DigestMethods(final IPL4__DigestMethods otherValue) {
			enum_value = otherValue.enum_value;
		}

		public IPL4__DigestMethods(final IPL4__DigestMethods.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public IPL4__DigestMethods(final int otherValue) {
			if (!is_valid_enum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `IPL4__DigestMethods' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		public IPL4__DigestMethods operator_assign(final IPL4__DigestMethods otherValue){
			otherValue.must_bound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public IPL4__DigestMethods operator_assign(final Base_Type otherValue){
			if( otherValue instanceof IPL4__DigestMethods ) {
				return operator_assign((IPL4__DigestMethods) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `IPL4__DigestMethods' can not be cast to {1}", otherValue));
		}

		public IPL4__DigestMethods operator_assign(final IPL4__DigestMethods.enum_type otherValue){
			return operator_assign( new IPL4__DigestMethods(otherValue) );
		}

		public IPL4__DigestMethods operator_assign(final int otherValue){
			if (!is_valid_enum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `IPL4__DigestMethods'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		public boolean operator_equals(final IPL4__DigestMethods otherValue){
			return enum_value == otherValue.enum_value;
		}

		public boolean operator_equals(final Base_Type otherValue){
			if (otherValue instanceof IPL4__DigestMethods) {
				return operator_equals( (IPL4__DigestMethods) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.IPL4_DigestMethods.");
			}
		}

		public boolean operator_equals(final IPL4__DigestMethods.enum_type otherValue){
			return enum_value == otherValue;
		}

		public boolean operator_not_equals(final IPL4__DigestMethods otherValue){
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals(final Base_Type otherValue){
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals(final IPL4__DigestMethods.enum_type otherValue){
			return !operator_equals(otherValue);
		}

		public boolean is_less_than(final IPL4__DigestMethods.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			return enum_value.enum_num < otherValue.enum_num;
		}

		public boolean is_less_than(final IPL4__DigestMethods otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		public boolean is_less_than_or_equal(final IPL4__DigestMethods.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			return enum_value.enum_num <= otherValue.enum_num;
		}

		public boolean is_less_than_or_equal(final IPL4__DigestMethods otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			return enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		public boolean is_greater_than(final IPL4__DigestMethods.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			return enum_value.enum_num > otherValue.enum_num;
		}

		public boolean is_greater_than(final IPL4__DigestMethods otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			return enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		public boolean is_greater_than_or_equal(final IPL4__DigestMethods.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			return enum_value.enum_num >= otherValue.enum_num;
		}

		public boolean is_greater_than_or_equal(final IPL4__DigestMethods otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__DigestMethods. ");
			return enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		@Override
		public boolean is_value() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		@Override
		public void clean_up() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean is_valid_enum(final int other_value) {
			final enum_type helper =  enum_type.getValue(other_value);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean is_valid_enum(final enum_type other_value) {
			return other_value != enum_type.UNKNOWN_VALUE && other_value != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!is_valid_enum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!is_valid_enum(intValue.get_int())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.get_int()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.get_int());
		}

		public static int enum2int(final IPL4__DigestMethods.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final IPL4__DigestMethods enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("NULL__method".equals(strPar) || "NULL_method".equals(strPar)) {
				return enum_type.NULL__method;
			}
			if ("MD4".equals(strPar)) {
				return enum_type.MD4;
			}
			if ("MD5".equals(strPar)) {
				return enum_type.MD5;
			}
			if ("SHA".equals(strPar)) {
				return enum_type.SHA;
			}
			if ("SHA1".equals(strPar)) {
				return enum_type.SHA1;
			}
			if ("DSS".equals(strPar)) {
				return enum_type.DSS;
			}
			if ("DSS1".equals(strPar)) {
				return enum_type.DSS1;
			}
			if ("ECDSA".equals(strPar)) {
				return enum_type.ECDSA;
			}
			if ("SHA224".equals(strPar)) {
				return enum_type.SHA224;
			}
			if ("SHA256".equals(strPar)) {
				return enum_type.SHA256;
			}
			if ("SHA384".equals(strPar)) {
				return enum_type.SHA384;
			}
			if ("SHA512".equals(strPar)) {
				return enum_type.SHA512;
			}
			if ("MDC2".equals(strPar)) {
				return enum_type.MDC2;
			}
			if ("RIPEMD160".equals(strPar)) {
				return enum_type.RIPEMD160;
			}
			if ("WHIRLPOOL".equals(strPar)) {
				return enum_type.WHIRLPOOL;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum_to_str(final enum_type enumPar) {
			return enumPar.name();
		}

		public int as_int() {
			return enum2int(enum_value);
		}

		public void from_int(final int intValue) {
			enum_value = enum_type.getValue(intValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		@Override
		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum_to_str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@IPL4asp_Types.IPL4_DigestMethods");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!is_valid_enum(enum_value)) {
				param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_DigestMethods.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().get_int();
			if (!is_valid_enum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @IPL4asp_Types.IPL4_DigestMethods.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class IPL4__DigestMethods_template extends Base_Template {
		// single_value
		private IPL4__DigestMethods.enum_type single_value;
		// value_list part
		private ArrayList<IPL4__DigestMethods_template> value_list;

		private void copy_value(final IPL4__DigestMethods other_value) {
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = other_value.enum_value;
		}

		private void copy_template(final IPL4__DigestMethods_template otherValue) {
			set_selection(otherValue);
			switch (otherValue.template_selection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<IPL4__DigestMethods_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final IPL4__DigestMethods_template temp = new IPL4__DigestMethods_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
			}
		}

		public IPL4__DigestMethods_template() {
			// do nothing
		}

		public IPL4__DigestMethods_template(final template_sel otherValue) {
			super(otherValue);
			check_single_selection(otherValue);
		}

		public IPL4__DigestMethods_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!IPL4__DigestMethods.is_valid_enum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods with unknown numeric value "+ otherValue +".");
			}
			single_value = IPL4__DigestMethods.enum_type.getValue(otherValue);
		}

		public IPL4__DigestMethods_template(final IPL4__DigestMethods otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			otherValue.must_bound("Creating a template from an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods. ");
			single_value = otherValue.enum_value;
		}

		public IPL4__DigestMethods_template( final Optional<IPL4__DigestMethods> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.IPL4_DigestMethods from an unbound optional field.");
			}
		}

		public IPL4__DigestMethods_template(final IPL4__DigestMethods_template otherValue) {
			copy_template(otherValue);
		}

		public IPL4__DigestMethods_template(final IPL4__DigestMethods.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		@Override
		public void clean_up() {
			if (template_selection == template_sel.VALUE_LIST || template_selection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		@Override
		public boolean is_bound() {
			return template_selection != template_sel.UNINITIALIZED_TEMPLATE || is_ifPresent;
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != IPL4__DigestMethods.enum_type.UNBOUND_VALUE;
		}

		@Override
		public IPL4__DigestMethods_template operator_assign(final template_sel otherValue) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public IPL4__DigestMethods_template operator_assign(final int otherValue) {
			if (!IPL4__DigestMethods.is_valid_enum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
			}
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		public IPL4__DigestMethods_template operator_assign(final IPL4__DigestMethods.enum_type otherValue){
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		public IPL4__DigestMethods_template operator_assign(final IPL4__DigestMethods_template otherValue){
			// otherValue.must_bound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public IPL4__DigestMethods_template operator_assign(final IPL4__DigestMethods otherValue){
			otherValue.must_bound("Assignment of an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods to a template. ");
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public IPL4__DigestMethods_template operator_assign(final Base_Type otherValue){
			if( otherValue instanceof IPL4__DigestMethods ) {
				return operator_assign((IPL4__DigestMethods) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.IPL4_DigestMethods' can not be cast to {1}", otherValue));
		}

		@Override
		public IPL4__DigestMethods_template operator_assign(final Base_Template otherValue){
			if( otherValue instanceof IPL4__DigestMethods_template ) {
				return operator_assign((IPL4__DigestMethods_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.IPL4_DigestMethods'_template can not be cast to {1}", otherValue));
		}

		public boolean match(final IPL4__DigestMethods.enum_type otherValue) {
			return match(otherValue, false);
		}

		public boolean match(final IPL4__DigestMethods.enum_type otherValue, final boolean legacy) {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
			}
		}

		public boolean match(final IPL4__DigestMethods otherValue) {
			return match(otherValue.enum_value, false);
		}

		public boolean match(final IPL4__DigestMethods otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof IPL4__DigestMethods ) {
				return match((IPL4__DigestMethods) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.IPL4_DigestMethods' can not be cast to {1}", otherValue));
		}

		@Override
		public IPL4__DigestMethods valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
			}
			return new IPL4__DigestMethods(single_value);
		}

		@Override
		public void set_type(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
			}
			clean_up();
			set_selection(templateType);
			value_list = new ArrayList<IPL4__DigestMethods_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new IPL4__DigestMethods_template());
			}
		}

		@Override
		public IPL4__DigestMethods_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type IPL4__DigestMethods using a negative index ({0}).", list_index));
			} else if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
			}
			return value_list.get(list_index);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(IPL4__DigestMethods.enum_to_str(single_value), IPL4__DigestMethods.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof IPL4__DigestMethods) {
				log_match((IPL4__DigestMethods)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.IPL4_DigestMethods.");
		}

		public void log_match(final IPL4__DigestMethods match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final IPL4__DigestMethods.enum_type enum_value = IPL4__DigestMethods.str_to_enum(param.get_enumerated());
				if (!IPL4__DigestMethods.is_valid_enum(enum_value)) {
					param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_DigestMethods.");
				}
				operator_assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@IPL4asp_Types.IPL4_DigestMethods");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().get_int();
				if (!IPL4__DigestMethods.is_valid_enum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @IPL4asp_Types.IPL4_DigestMethods.", temp));
				}
				single_value = IPL4__DigestMethods.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				value_list = new ArrayList<IPL4__DigestMethods_template>(size);
				for (int i = 0; i < size; i++) {
					final IPL4__DigestMethods_template temp = new IPL4__DigestMethods_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && template_selection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (template_selection == template_sel.OMIT_VALUE || template_selection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.IPL4_DigestMethods" : name));
		}
	}
	public static class SctpPeerAddrChange extends Socket__API__Definitions.SctpPeerAddrChange { }
	public static class SctpPeerAddrChange_template extends Socket__API__Definitions.SctpPeerAddrChange_template { }
	public static class ReuseAddress extends Base_Type {
		private final Optional<TitanBoolean> enable;

		public ReuseAddress() {
			this.enable = new Optional<TitanBoolean>(TitanBoolean.class);
		}

		public ReuseAddress(final Optional<TitanBoolean> enable ) {
			this.enable = new Optional<TitanBoolean>(TitanBoolean.class);
			this.enable.operator_assign( enable );
		}

		public ReuseAddress( final ReuseAddress otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.ReuseAddress.");
			enable = new Optional<TitanBoolean>(TitanBoolean.class);
			operator_assign( otherValue );
		}

		public ReuseAddress operator_assign(final ReuseAddress otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.ReuseAddress");
			if (otherValue != this) {
				if ( otherValue.get_field_enable().is_bound() ) {
					this.enable.operator_assign( otherValue.get_field_enable() );
				} else {
					this.enable.clean_up();
				}
			}

			return this;
		}

		@Override
		public ReuseAddress operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof ReuseAddress ) {
				return operator_assign((ReuseAddress) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.ReuseAddress", otherValue));
		}

		@Override
		public void clean_up() {
			enable.clean_up();
		}

		@Override
		public boolean is_bound() {
			return optional_sel.OPTIONAL_OMIT.equals(enable.get_selection()) || enable.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return (optional_sel.OPTIONAL_OMIT.equals(enable.get_selection()) || enable.is_value());
		}

		public boolean operator_equals( final ReuseAddress other_value) {
			return enable.operator_equals( other_value.enable );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof ReuseAddress ) {
				return operator_equals((ReuseAddress) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.ReuseAddress", other_value));
		}

		public Optional<TitanBoolean> get_field_enable() {
			return enable;
		}

		public Optional<TitanBoolean> constGet_field_enable() {
			return enable;
		}

		public TitanInteger size_of() {
			int sizeof = 0;
			if (enable.ispresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" enable := ");
			enable.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.ReuseAddress has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_enable().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("enable".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_enable().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.ReuseAddress: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.ReuseAddress");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (enable.is_bound()) {
				enable.set_implicit_omit();
			} else {
				enable.operator_assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			enable.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			enable.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class ReuseAddress_template extends Base_Template {
		private TitanBoolean_template enable;
		//originally value_list/list_value
		private List<ReuseAddress_template> list_value;


		public ReuseAddress_template() {
			// do nothing
		}

		public ReuseAddress_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public ReuseAddress_template( final ReuseAddress otherValue ) {
			copy_value(otherValue);
		}

		public ReuseAddress_template( final ReuseAddress_template otherValue ) {
			copy_template( otherValue );
		}

		public ReuseAddress_template( final Optional<ReuseAddress> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.ReuseAddress from an unbound optional field.");
			}
		}

		@Override
		public ReuseAddress_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public ReuseAddress_template operator_assign( final ReuseAddress otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public ReuseAddress_template operator_assign( final ReuseAddress_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public ReuseAddress_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof ReuseAddress) {
				return operator_assign((ReuseAddress) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ReuseAddress' can not be cast to {1}", otherValue));
		}

		@Override
		public ReuseAddress_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof ReuseAddress_template) {
				return operator_assign((ReuseAddress_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ReuseAddress' can not be cast to {1}_template", otherValue));
		}

		public ReuseAddress_template operator_assign( final Optional<ReuseAddress> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.ReuseAddress.");
			}
			return this;
		}

		private void copy_value(final ReuseAddress other_value) {
			if (other_value.get_field_enable().is_bound()) {
				if (other_value.get_field_enable().ispresent()) {
					get_field_enable().operator_assign(other_value.get_field_enable().get());
				} else {
					get_field_enable().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_enable().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final ReuseAddress_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_enable().get_selection()) {
					get_field_enable().clean_up();
				} else {
					get_field_enable().operator_assign(other_value.get_field_enable());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ReuseAddress_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ReuseAddress_template temp = new ReuseAddress_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.ReuseAddress.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.ReuseAddress.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<ReuseAddress_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ReuseAddress_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return enable.is_omit() || enable.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return (enable.is_omit() || enable.is_value());
		}
		public TitanBoolean_template get_field_enable() {
			set_specific();
			return enable;
		}

		public TitanBoolean_template constGet_field_enable() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field enable of a non-specific template of type @IPL4asp_Types.ReuseAddress.");
			}
			return enable;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					enable = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
				} else {
					enable = new TitanBoolean_template();
				}
			}
		}
		public boolean match(final ReuseAddress other_value) {
			return match(other_value, false);
		}

		public boolean match(final ReuseAddress other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_enable().is_bound()) {
					return false;
				}
				if((other_value.get_field_enable().ispresent() ? !enable.match(other_value.get_field_enable().get(), legacy) : !enable.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.ReuseAddress.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ReuseAddress) {
				return match((ReuseAddress)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ReuseAddress.");
		}


		@Override
		public ReuseAddress valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.ReuseAddress.");
			}
			final ReuseAddress ret_val = new ReuseAddress();
			if (enable.is_omit()) {
				ret_val.get_field_enable().operator_assign(template_sel.OMIT_VALUE);
			} else if (enable.is_bound()) {
				ret_val.get_field_enable().operator_assign(enable.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				int sizeof = 0;
				if (enable.is_present()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.ReuseAddress.");
			}
		}

		@Override
		public ReuseAddress_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.ReuseAddress.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.ReuseAddress using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.ReuseAddress.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" enable := ");
				enable.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ReuseAddress match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ReuseAddress) {
				log_match((ReuseAddress)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.ReuseAddress.");
		}

		public void log_match(final ReuseAddress match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if (match_value.constGet_field_enable().ispresent()) {
							if( !enable.match(match_value.constGet_field_enable().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".enable");
								enable.log_match(match_value.constGet_field_enable().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!enable.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".enable := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								enable.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ enable := ");
				enable.log_match(match_value.constGet_field_enable(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				enable.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.ReuseAddress.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				enable = new TitanBoolean_template();
				enable.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<ReuseAddress_template>(size);
				for (int i = 0; i < size; i++) {
					final ReuseAddress_template temp = new ReuseAddress_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.ReuseAddress.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.ReuseAddress has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_enable().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("enable".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_enable().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.ReuseAddress: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.ReuseAddress");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.enable.check_restriction(restriction, name == null ? "@IPL4asp_Types.ReuseAddress" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.ReuseAddress" : name));
		}
	}
	public static class Extended__Result extends Socket__API__Definitions.Extended__Result { }
	public static class Extended__Result_template extends Socket__API__Definitions.Extended__Result_template { }
	public static class SSL__proto__support extends Base_Type {

		protected List<SSL__protocols> valueElements;

		public SSL__proto__support() {
			// do nothing
		}

		public SSL__proto__support( final SSL__proto__support otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @IPL4asp_Types.SSL_proto_support.");
			valueElements = copy_list( otherValue.valueElements );
		}


		public SSL__proto__support(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<SSL__protocols>();
		}

		private static final List<SSL__protocols> copy_list( final List<SSL__protocols> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<SSL__protocols> newList = new ArrayList<SSL__protocols>( srcList.size() );
			for (final SSL__protocols srcElem : srcList) {
				final SSL__protocols newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			for (int i=0; i < valueElements.size(); i++) {
				final SSL__protocols elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type otherValue) {
			if (otherValue instanceof SSL__proto__support) {
				return operator_equals((SSL__proto__support)otherValue);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type SSL__proto__support.");
		}

		public boolean operator_equals( final SSL__proto__support otherValue ) {
			must_bound("The left operand of comparison is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
			otherValue.must_bound("The right operand of comparison is an unbound value of type @IPL4asp_Types.SSL_proto_support.");

			final int size = valueElements.size();
			if ( size != otherValue.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final SSL__protocols leftElem = valueElements.get( i );
				final SSL__protocols rightElem = otherValue.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public SSL__proto__support operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof SSL__proto__support) {
				return operator_assign((SSL__proto__support)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type SSL__proto__support.");
		}

		public SSL__proto__support operator_assign( final SSL__proto__support otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @IPL4asp_Types.SSL_proto_support." );

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		public SSL__proto__support operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<SSL__protocols>();
			return this;
		}

		public SSL__proto__support operator_concatenate(final SSL__proto__support other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @IPL4asp_Types.SSL_proto_support concatenation.");
			}
			final SSL__proto__support ret_val = new SSL__proto__support(TitanNull_Type.NULL_VALUE);
			for (int i=0; i < valueElements.size(); i++) {
				final SSL__protocols elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new SSL__protocols(elem));
				}
			}
			for (int i = 0; i < other_value.valueElements.size(); i++) {
				final SSL__protocols elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new SSL__protocols(elem));
				}
			}
			return ret_val;
		}

		public SSL__proto__support operator_concatenate(final TitanNull_Type null_value) {
			return new SSL__proto__support(this);
		}

		public SSL__proto__support rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		public SSL__proto__support rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		public SSL__proto__support rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		public SSL__proto__support rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @IPL4asp_Types.SSL_proto_support.");
			final int size = valueElements.size();
			if (size == 0) {
				return new SSL__proto__support(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new SSL__proto__support(this);
			}
			final SSL__proto__support ret_val = new SSL__proto__support(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final SSL__protocols elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new SSL__protocols(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final SSL__protocols elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new SSL__protocols(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		public SSL__protocols get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @IPL4asp_Types.SSL_proto_support using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			if ( valueElements.get( index_value ) == null ) {
				final SSL__protocols newElem = get_unbound_elem();
				valueElements.set( index_value, newElem );
			}
			return valueElements.get( index_value );
		}

		public SSL__protocols get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @IPL4asp_Types.SSL_proto_support." );
			return get_at( index_value.get_int() );
		}

		public SSL__protocols constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @IPL4asp_Types.SSL_proto_support." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @IPL4asp_Types.SSL_proto_support using a negative index: "+index_value+".");
			}
			final int nofElements = n_elem().get_int();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @IPL4asp_Types.SSL_proto_support: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final SSL__protocols elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		public SSL__protocols constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @IPL4asp_Types.SSL_proto_support." );
			return constGet_at( index_value.get_int() );
		}

		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @IPL4asp_Types.SSL_proto_support.");
			return new TitanInteger(valueElements.size());
		}

		public TitanInteger n_elem() {
			return size_of();
		}

		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @IPL4asp_Types.SSL_proto_support.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final SSL__protocols elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @IPL4asp_Types.SSL_proto_support.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<SSL__protocols>(newSize);
			}
			if (newSize > valueElements.size()) {
				for ( int i = valueElements.size(); i < newSize; i++ ) {
					valueElements.add( new SSL__protocols() );
				}
			} else if (newSize < valueElements.size()) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static SSL__protocols get_unbound_elem() {
			return new SSL__protocols();
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		public SSL__proto__support substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@IPL4asp_Types.SSL_proto_support","element");
			final SSL__proto__support ret_val = new SSL__proto__support(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new SSL__protocols(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		public SSL__proto__support replace(final int index, final int len, final SSL__proto__support repl) {
			must_bound("The first argument of replace() is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@IPL4asp_Types.SSL_proto_support","element");
			final SSL__proto__support ret_val = new SSL__proto__support(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final SSL__protocols elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new SSL__protocols(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final SSL__protocols elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new SSL__protocols(elem));
				}
			}
			for (int i = 0; i < valueElements.size() - index - len; i++) {
				final SSL__protocols elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new SSL__protocols(elem));
				}
			}
			return ret_val;
		}

		public SSL__proto__support replace(final int index, final int len, final SSL__proto__support_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		public SSL__proto__support replace(final int index, final TitanInteger len, final SSL__proto__support_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		public SSL__proto__support replace(final TitanInteger index, final int len, final SSL__proto__support_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		public SSL__proto__support replace(final TitanInteger index, final TitanInteger len, final SSL__proto__support_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				valueElements.get(i).log();
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@IPL4asp_Types.SSL_proto_support");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@IPL4asp_Types.SSL_proto_support");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @IPL4asp_Types.SSL_proto_support.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<SSL__protocols>(temp);
			for (int i = 0; i < temp; i++) {
				final SSL__protocols temp2 = new SSL__protocols();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class SSL__proto__support_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<SSL__protocols_template> value_elements;

		//originally value_list/list_value
		protected List<SSL__proto__support_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((SSL__proto__support)value_ptr, value_index, (SSL__proto__support_template)template_ptr, template_index, legacy);
			}
		};

		public SSL__proto__support_template() {
			// do nothing
		}

		public SSL__proto__support_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public SSL__proto__support_template( final SSL__proto__support otherValue ) {
			copy_value( otherValue );
		}

		public SSL__proto__support_template( final SSL__proto__support_template otherValue ) {
			copy_template( otherValue );
		}

		public SSL__proto__support_template( final Optional<SSL__proto__support> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.SSL_proto_support from an unbound optional field.");
			}
		}

		public SSL__proto__support_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<SSL__protocols_template>();
		}

		protected void copy_value(final SSL__proto__support other_value) {
			other_value.must_bound("Initialization of a template of type @IPL4asp_Types.SSL_proto_support with an unbound value.");
			value_elements = new ArrayList<SSL__protocols_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new SSL__protocols_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new SSL__protocols_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final SSL__proto__support_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<SSL__protocols_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new SSL__protocols_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new SSL__protocols_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<SSL__proto__support_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final SSL__proto__support_template temp = new SSL__proto__support_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.SSL_proto_support.");
			}
			set_selection(other_value);
		}

		public boolean match(final SSL__proto__support other_value) {
			return match(other_value, false);
		}

		public boolean match(final SSL__proto__support other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < list_value.size(); i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @IPL4asp_Types.SSL_proto_support.");
			}
		}

		private boolean match_index(final SSL__proto__support value_ptr, final int value_index, final SSL__proto__support_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof SSL__proto__support) {
				return match((SSL__proto__support)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type SSL__proto__support.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < list_value.size(); i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public SSL__proto__support_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public SSL__proto__support_template operator_assign( final SSL__proto__support otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public SSL__proto__support_template operator_assign( final SSL__proto__support_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public SSL__proto__support_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof SSL__proto__support) {
				return operator_assign((SSL__proto__support)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type SSL__proto__support.");
		}

		@Override
		public SSL__proto__support_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof SSL__proto__support_template) {
				return operator_assign((SSL__proto__support_template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type SSL__proto__support_template.");
		}

		public SSL__proto__support_template operator_assign( final Optional<SSL__proto__support> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.SSL_proto_support.");
			}
			return this;
		}
		public SSL__proto__support_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<SSL__protocols_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public SSL__proto__support replace(final int index, final int len, final SSL__proto__support_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		public SSL__proto__support replace(final TitanInteger index, final TitanInteger len, final SSL__proto__support_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		public SSL__proto__support replace(final int index, final int len, final SSL__proto__support repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		public SSL__proto__support replace(final TitanInteger index, final TitanInteger len, final SSL__proto__support repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		public SSL__protocols_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @IPL4asp_Types.SSL_proto_support using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @IPL4asp_Types.SSL_proto_support.");
			}
			return value_elements.get(index_value);
		}

		public SSL__protocols_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @IPL4asp_Types.SSL_proto_support.");

			return get_at(index_value.get_int());
		}

		public SSL__protocols_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @IPL4asp_Types.SSL_proto_support using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @IPL4asp_Types.SSL_proto_support.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @IPL4asp_Types.SSL_proto_support: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		public SSL__protocols_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @IPL4asp_Types.SSL_proto_support.");

			return constGet_at(index_value.get_int());
		}

		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @IPL4asp_Types.SSL_proto_support.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<SSL__protocols_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new SSL__protocols_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new SSL__protocols_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		public TitanInteger size_of() {
			return sizeOf(true);
		}

		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.SSL_proto_support which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.SSL_proto_support containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.SSL_proto_support containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.SSL_proto_support containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				for (int i = 1; i < list_value.size(); i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.SSL_proto_support containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.SSL_proto_support containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type SSL__proto__support.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "SSL__protocols_template"));
		}

		public TitanInteger n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(value_elements.size());
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type SSL__proto__support containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type SSL__proto__support.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<SSL__proto__support_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new SSL__proto__support_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @IPL4asp_Types.SSL_proto_support.");
			}
			set_selection(template_type);
		}

		@Override
		public SSL__proto__support_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.SSL_proto_support.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.SSL_proto_support using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.SSL_proto_support.");
			}
			return list_value.get(list_index);
		}

		public SSL__proto__support_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @IPL4asp_Types.SSL_proto_support.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.SSL_proto_support using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @IPL4asp_Types.SSL_proto_support.");
			}
			return list_value.get( list_index );
		}

		@Override
		public SSL__proto__support valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.SSL_proto_support.");
			}
			final SSL__proto__support ret_val = new SSL__proto__support(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).is_bound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueof() );
				}
			}
			return ret_val;
		}

		public SSL__proto__support substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		public void log_match(final SSL__proto__support match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof SSL__proto__support) {
				log_match((SSL__proto__support)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.SSL_proto_support.");
		}

		public void log_match(final SSL__proto__support match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(value_elements.size());
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(value_elements.size());
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.SSL_proto_support.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @IPL4asp_Types.SSL_proto_support.");
				}
				value_elements = new ArrayList<SSL__protocols_template>(temp);
				for (int i = 0; i < temp; i++) {
					final SSL__protocols_template temp2 = new SSL__protocols_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<SSL__proto__support_template>(size);
				for (int i = 0; i < size; i++) {
					final SSL__proto__support_template temp2 = new SSL__proto__support_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @IPL4asp_Types.SSL_proto_support.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@IPL4asp_Types.SSL_proto_support");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE:
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				for (int i=0; i<value_elements.size(); i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@IPL4asp_Types.SSL_proto_support" : name, false);
				}
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.SSL_proto_support" : name));
		}
	}
	public static class ASP__SendTo extends Base_Type {
		private final TitanInteger connId;
		private final TitanCharString remName;
		private final TitanInteger remPort;
		private final Optional<Socket__API__Definitions.ProtoTuple> proto;
		private final TitanOctetString msg;

		public ASP__SendTo() {
			this.connId = new TitanInteger();
			this.remName = new TitanCharString();
			this.remPort = new TitanInteger();
			this.proto = new Optional<Socket__API__Definitions.ProtoTuple>(Socket__API__Definitions.ProtoTuple.class);
			this.msg = new TitanOctetString();
		}

		public ASP__SendTo(final TitanInteger connId, final TitanCharString remName, final TitanInteger remPort, final Optional<Socket__API__Definitions.ProtoTuple> proto, final TitanOctetString msg ) {
			this.connId = new TitanInteger( connId );
			this.remName = new TitanCharString( remName );
			this.remPort = new TitanInteger( remPort );
			this.proto = new Optional<Socket__API__Definitions.ProtoTuple>(Socket__API__Definitions.ProtoTuple.class);
			this.proto.operator_assign( proto );
			this.msg = new TitanOctetString( msg );
		}

		public ASP__SendTo( final ASP__SendTo otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.ASP_SendTo.");
			connId = new TitanInteger();
			remName = new TitanCharString();
			remPort = new TitanInteger();
			proto = new Optional<Socket__API__Definitions.ProtoTuple>(Socket__API__Definitions.ProtoTuple.class);
			msg = new TitanOctetString();
			operator_assign( otherValue );
		}

		public ASP__SendTo operator_assign(final ASP__SendTo otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.ASP_SendTo");
			if (otherValue != this) {
				if ( otherValue.get_field_connId().is_bound() ) {
					this.connId.operator_assign( otherValue.get_field_connId() );
				} else {
					this.connId.clean_up();
				}
				if ( otherValue.get_field_remName().is_bound() ) {
					this.remName.operator_assign( otherValue.get_field_remName() );
				} else {
					this.remName.clean_up();
				}
				if ( otherValue.get_field_remPort().is_bound() ) {
					this.remPort.operator_assign( otherValue.get_field_remPort() );
				} else {
					this.remPort.clean_up();
				}
				if ( otherValue.get_field_proto().is_bound() ) {
					this.proto.operator_assign( otherValue.get_field_proto() );
				} else {
					this.proto.clean_up();
				}
				if ( otherValue.get_field_msg().is_bound() ) {
					this.msg.operator_assign( otherValue.get_field_msg() );
				} else {
					this.msg.clean_up();
				}
			}

			return this;
		}

		@Override
		public ASP__SendTo operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof ASP__SendTo ) {
				return operator_assign((ASP__SendTo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.ASP_SendTo", otherValue));
		}

		@Override
		public void clean_up() {
			connId.clean_up();
			remName.clean_up();
			remPort.clean_up();
			proto.clean_up();
			msg.clean_up();
		}

		@Override
		public boolean is_bound() {
			return connId.is_bound()
					|| remName.is_bound()
					|| remPort.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(proto.get_selection()) || proto.is_bound()
					|| msg.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return connId.is_value()
					&& remName.is_value()
					&& remPort.is_value()
					&& (optional_sel.OPTIONAL_OMIT.equals(proto.get_selection()) || proto.is_value())
					&& msg.is_value();
		}

		public boolean operator_equals( final ASP__SendTo other_value) {
			return connId.operator_equals( other_value.connId )
					&& remName.operator_equals( other_value.remName )
					&& remPort.operator_equals( other_value.remPort )
					&& proto.operator_equals( other_value.proto )
					&& msg.operator_equals( other_value.msg );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof ASP__SendTo ) {
				return operator_equals((ASP__SendTo) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.ASP_SendTo", other_value));
		}

		public TitanInteger get_field_connId() {
			return connId;
		}

		public TitanInteger constGet_field_connId() {
			return connId;
		}

		public TitanCharString get_field_remName() {
			return remName;
		}

		public TitanCharString constGet_field_remName() {
			return remName;
		}

		public TitanInteger get_field_remPort() {
			return remPort;
		}

		public TitanInteger constGet_field_remPort() {
			return remPort;
		}

		public Optional<Socket__API__Definitions.ProtoTuple> get_field_proto() {
			return proto;
		}

		public Optional<Socket__API__Definitions.ProtoTuple> constGet_field_proto() {
			return proto;
		}

		public TitanOctetString get_field_msg() {
			return msg;
		}

		public TitanOctetString constGet_field_msg() {
			return msg;
		}

		public TitanInteger size_of() {
			int sizeof = 4;
			if (proto.ispresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" connId := ");
			connId.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" remName := ");
			remName.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" remPort := ");
			remPort.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" proto := ");
			proto.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msg := ");
			msg.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.ASP_SendTo has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_connId().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remName().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remPort().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_proto().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_msg().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("connId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_connId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remName".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remName().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remPort".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remPort().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("proto".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_proto().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msg".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_msg().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.ASP_SendTo: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.ASP_SendTo");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (connId.is_bound()) {
				connId.set_implicit_omit();
			}
			if (remName.is_bound()) {
				remName.set_implicit_omit();
			}
			if (remPort.is_bound()) {
				remPort.set_implicit_omit();
			}
			if (proto.is_bound()) {
				proto.set_implicit_omit();
			} else {
				proto.operator_assign(template_sel.OMIT_VALUE);
			}
			if (msg.is_bound()) {
				msg.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			connId.encode_text(text_buf);
			remName.encode_text(text_buf);
			remPort.encode_text(text_buf);
			proto.encode_text(text_buf);
			msg.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			connId.decode_text(text_buf);
			remName.decode_text(text_buf);
			remPort.decode_text(text_buf);
			proto.decode_text(text_buf);
			msg.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class ASP__SendTo_template extends Base_Template {
		private TitanInteger_template connId;
		private TitanCharString_template remName;
		private TitanInteger_template remPort;
		private Socket__API__Definitions.ProtoTuple_template proto;
		private TitanOctetString_template msg;
		//originally value_list/list_value
		private List<ASP__SendTo_template> list_value;


		public ASP__SendTo_template() {
			// do nothing
		}

		public ASP__SendTo_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public ASP__SendTo_template( final ASP__SendTo otherValue ) {
			copy_value(otherValue);
		}

		public ASP__SendTo_template( final ASP__SendTo_template otherValue ) {
			copy_template( otherValue );
		}

		public ASP__SendTo_template( final Optional<ASP__SendTo> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.ASP_SendTo from an unbound optional field.");
			}
		}

		@Override
		public ASP__SendTo_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public ASP__SendTo_template operator_assign( final ASP__SendTo otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public ASP__SendTo_template operator_assign( final ASP__SendTo_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public ASP__SendTo_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof ASP__SendTo) {
				return operator_assign((ASP__SendTo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ASP__SendTo' can not be cast to {1}", otherValue));
		}

		@Override
		public ASP__SendTo_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof ASP__SendTo_template) {
				return operator_assign((ASP__SendTo_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ASP__SendTo' can not be cast to {1}_template", otherValue));
		}

		public ASP__SendTo_template operator_assign( final Optional<ASP__SendTo> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.ASP_SendTo.");
			}
			return this;
		}

		private void copy_value(final ASP__SendTo other_value) {
			if (other_value.get_field_connId().is_bound()) {
				get_field_connId().operator_assign(other_value.get_field_connId());
			} else {
				get_field_connId().clean_up();
			}
			if (other_value.get_field_remName().is_bound()) {
				get_field_remName().operator_assign(other_value.get_field_remName());
			} else {
				get_field_remName().clean_up();
			}
			if (other_value.get_field_remPort().is_bound()) {
				get_field_remPort().operator_assign(other_value.get_field_remPort());
			} else {
				get_field_remPort().clean_up();
			}
			if (other_value.get_field_proto().is_bound()) {
				if (other_value.get_field_proto().ispresent()) {
					get_field_proto().operator_assign(other_value.get_field_proto().get());
				} else {
					get_field_proto().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_proto().clean_up();
			}
			if (other_value.get_field_msg().is_bound()) {
				get_field_msg().operator_assign(other_value.get_field_msg());
			} else {
				get_field_msg().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final ASP__SendTo_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_connId().get_selection()) {
					get_field_connId().clean_up();
				} else {
					get_field_connId().operator_assign(other_value.get_field_connId());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_remName().get_selection()) {
					get_field_remName().clean_up();
				} else {
					get_field_remName().operator_assign(other_value.get_field_remName());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_remPort().get_selection()) {
					get_field_remPort().clean_up();
				} else {
					get_field_remPort().operator_assign(other_value.get_field_remPort());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_proto().get_selection()) {
					get_field_proto().clean_up();
				} else {
					get_field_proto().operator_assign(other_value.get_field_proto());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_msg().get_selection()) {
					get_field_msg().clean_up();
				} else {
					get_field_msg().operator_assign(other_value.get_field_msg());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ASP__SendTo_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ASP__SendTo_template temp = new ASP__SendTo_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.ASP_SendTo.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.ASP_SendTo.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<ASP__SendTo_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ASP__SendTo_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return connId.is_bound()
					|| remName.is_bound()
					|| remPort.is_bound()
					|| proto.is_omit() || proto.is_bound()
					|| msg.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return connId.is_value()
					&& remName.is_value()
					&& remPort.is_value()
					&& (proto.is_omit() || proto.is_value())
					&& msg.is_value();
		}
		public TitanInteger_template get_field_connId() {
			set_specific();
			return connId;
		}

		public TitanInteger_template constGet_field_connId() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field connId of a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
			}
			return connId;
		}

		public TitanCharString_template get_field_remName() {
			set_specific();
			return remName;
		}

		public TitanCharString_template constGet_field_remName() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field remName of a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
			}
			return remName;
		}

		public TitanInteger_template get_field_remPort() {
			set_specific();
			return remPort;
		}

		public TitanInteger_template constGet_field_remPort() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field remPort of a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
			}
			return remPort;
		}

		public Socket__API__Definitions.ProtoTuple_template get_field_proto() {
			set_specific();
			return proto;
		}

		public Socket__API__Definitions.ProtoTuple_template constGet_field_proto() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field proto of a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
			}
			return proto;
		}

		public TitanOctetString_template get_field_msg() {
			set_specific();
			return msg;
		}

		public TitanOctetString_template constGet_field_msg() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field msg of a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
			}
			return msg;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					connId = new TitanInteger_template(template_sel.ANY_VALUE);
					remName = new TitanCharString_template(template_sel.ANY_VALUE);
					remPort = new TitanInteger_template(template_sel.ANY_VALUE);
					proto = new Socket__API__Definitions.ProtoTuple_template(template_sel.ANY_OR_OMIT);
					msg = new TitanOctetString_template(template_sel.ANY_VALUE);
				} else {
					connId = new TitanInteger_template();
					remName = new TitanCharString_template();
					remPort = new TitanInteger_template();
					proto = new Socket__API__Definitions.ProtoTuple_template();
					msg = new TitanOctetString_template();
				}
			}
		}
		public boolean match(final ASP__SendTo other_value) {
			return match(other_value, false);
		}

		public boolean match(final ASP__SendTo other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_connId().is_bound()) {
					return false;
				}
				if(!connId.match(other_value.get_field_connId(), legacy)) {
					return false;
				}
				if(!other_value.get_field_remName().is_bound()) {
					return false;
				}
				if(!remName.match(other_value.get_field_remName(), legacy)) {
					return false;
				}
				if(!other_value.get_field_remPort().is_bound()) {
					return false;
				}
				if(!remPort.match(other_value.get_field_remPort(), legacy)) {
					return false;
				}
				if(!other_value.get_field_proto().is_bound()) {
					return false;
				}
				if((other_value.get_field_proto().ispresent() ? !proto.match(other_value.get_field_proto().get(), legacy) : !proto.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_msg().is_bound()) {
					return false;
				}
				if(!msg.match(other_value.get_field_msg(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.ASP_SendTo.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ASP__SendTo) {
				return match((ASP__SendTo)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ASP__SendTo.");
		}


		@Override
		public ASP__SendTo valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
			}
			final ASP__SendTo ret_val = new ASP__SendTo();
			if (connId.is_bound()) {
				ret_val.get_field_connId().operator_assign(connId.valueof());
			}
			if (remName.is_bound()) {
				ret_val.get_field_remName().operator_assign(remName.valueof());
			}
			if (remPort.is_bound()) {
				ret_val.get_field_remPort().operator_assign(remPort.valueof());
			}
			if (proto.is_omit()) {
				ret_val.get_field_proto().operator_assign(template_sel.OMIT_VALUE);
			} else if (proto.is_bound()) {
				ret_val.get_field_proto().operator_assign(proto.valueof());
			}
			if (msg.is_bound()) {
				ret_val.get_field_msg().operator_assign(msg.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				int sizeof = 4;
				if (proto.is_present()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.ASP_SendTo.");
			}
		}

		@Override
		public ASP__SendTo_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.ASP_SendTo.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.ASP_SendTo using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.ASP_SendTo.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" connId := ");
				connId.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" remName := ");
				remName.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" remPort := ");
				remPort.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" proto := ");
				proto.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msg := ");
				msg.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ASP__SendTo match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ASP__SendTo) {
				log_match((ASP__SendTo)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.ASP_SendTo.");
		}

		public void log_match(final ASP__SendTo match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !connId.match(match_value.constGet_field_connId(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".connId");
							connId.log_match(match_value.constGet_field_connId(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !remName.match(match_value.constGet_field_remName(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".remName");
							remName.log_match(match_value.constGet_field_remName(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !remPort.match(match_value.constGet_field_remPort(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".remPort");
							remPort.log_match(match_value.constGet_field_remPort(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGet_field_proto().ispresent()) {
							if( !proto.match(match_value.constGet_field_proto().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".proto");
								proto.log_match(match_value.constGet_field_proto().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!proto.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".proto := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								proto.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if( !msg.match(match_value.constGet_field_msg(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msg");
							msg.log_match(match_value.constGet_field_msg(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ connId := ");
				connId.log_match(match_value.constGet_field_connId(), legacy);
				TTCN_Logger.log_event_str("{ remName := ");
				remName.log_match(match_value.constGet_field_remName(), legacy);
				TTCN_Logger.log_event_str("{ remPort := ");
				remPort.log_match(match_value.constGet_field_remPort(), legacy);
				TTCN_Logger.log_event_str("{ proto := ");
				proto.log_match(match_value.constGet_field_proto(), legacy);
				TTCN_Logger.log_event_str("{ msg := ");
				msg.log_match(match_value.constGet_field_msg(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				connId.encode_text(text_buf);
				remName.encode_text(text_buf);
				remPort.encode_text(text_buf);
				proto.encode_text(text_buf);
				msg.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.ASP_SendTo.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				connId = new TitanInteger_template();
				connId.decode_text(text_buf);
				remName = new TitanCharString_template();
				remName.decode_text(text_buf);
				remPort = new TitanInteger_template();
				remPort.decode_text(text_buf);
				proto = new Socket__API__Definitions.ProtoTuple_template();
				proto.decode_text(text_buf);
				msg = new TitanOctetString_template();
				msg.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<ASP__SendTo_template>(size);
				for (int i = 0; i < size; i++) {
					final ASP__SendTo_template temp = new ASP__SendTo_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.ASP_SendTo.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.ASP_SendTo has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_connId().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remName().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remPort().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_proto().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_msg().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("connId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_connId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remName".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remName().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remPort".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remPort().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("proto".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_proto().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msg".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_msg().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.ASP_SendTo: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.ASP_SendTo");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.connId.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_SendTo" : name, legacy);
				this.remName.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_SendTo" : name, legacy);
				this.remPort.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_SendTo" : name, legacy);
				this.proto.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_SendTo" : name, legacy);
				this.msg.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_SendTo" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.ASP_SendTo" : name));
		}
	}
	public static class SctpAssocChange extends Socket__API__Definitions.SctpAssocChange { }
	public static class SctpAssocChange_template extends Socket__API__Definitions.SctpAssocChange_template { }
	public static class SPC__STATE extends Socket__API__Definitions.SPC__STATE { }
	public static class SPC__STATE_template extends Socket__API__Definitions.SPC__STATE_template { }
	public static class SctpEventHandle extends Base_Type {
		private final Optional<TitanBoolean> sctp__data__io__event;
		private final Optional<TitanBoolean> sctp__association__event;
		private final Optional<TitanBoolean> sctp__address__event;
		private final Optional<TitanBoolean> sctp__send__failure__event;
		private final Optional<TitanBoolean> sctp__peer__error__event;
		private final Optional<TitanBoolean> sctp__shutdown__event;
		private final Optional<TitanBoolean> sctp__partial__delivery__event;
		private final Optional<TitanBoolean> sctp__adaptation__layer__event;
		private final Optional<TitanBoolean> sctp__authentication__event;
		private final Optional<TitanBoolean> sctp__sender__dry__event;

		public SctpEventHandle() {
			this.sctp__data__io__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__association__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__address__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__send__failure__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__peer__error__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__shutdown__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__partial__delivery__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__adaptation__layer__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__authentication__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__sender__dry__event = new Optional<TitanBoolean>(TitanBoolean.class);
		}

		public SctpEventHandle(final Optional<TitanBoolean> sctp__data__io__event, final Optional<TitanBoolean> sctp__association__event, final Optional<TitanBoolean> sctp__address__event, final Optional<TitanBoolean> sctp__send__failure__event, final Optional<TitanBoolean> sctp__peer__error__event, final Optional<TitanBoolean> sctp__shutdown__event, final Optional<TitanBoolean> sctp__partial__delivery__event, final Optional<TitanBoolean> sctp__adaptation__layer__event, final Optional<TitanBoolean> sctp__authentication__event, final Optional<TitanBoolean> sctp__sender__dry__event ) {
			this.sctp__data__io__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__data__io__event.operator_assign( sctp__data__io__event );
			this.sctp__association__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__association__event.operator_assign( sctp__association__event );
			this.sctp__address__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__address__event.operator_assign( sctp__address__event );
			this.sctp__send__failure__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__send__failure__event.operator_assign( sctp__send__failure__event );
			this.sctp__peer__error__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__peer__error__event.operator_assign( sctp__peer__error__event );
			this.sctp__shutdown__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__shutdown__event.operator_assign( sctp__shutdown__event );
			this.sctp__partial__delivery__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__partial__delivery__event.operator_assign( sctp__partial__delivery__event );
			this.sctp__adaptation__layer__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__adaptation__layer__event.operator_assign( sctp__adaptation__layer__event );
			this.sctp__authentication__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__authentication__event.operator_assign( sctp__authentication__event );
			this.sctp__sender__dry__event = new Optional<TitanBoolean>(TitanBoolean.class);
			this.sctp__sender__dry__event.operator_assign( sctp__sender__dry__event );
		}

		public SctpEventHandle( final SctpEventHandle otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.SctpEventHandle.");
			sctp__data__io__event = new Optional<TitanBoolean>(TitanBoolean.class);
			sctp__association__event = new Optional<TitanBoolean>(TitanBoolean.class);
			sctp__address__event = new Optional<TitanBoolean>(TitanBoolean.class);
			sctp__send__failure__event = new Optional<TitanBoolean>(TitanBoolean.class);
			sctp__peer__error__event = new Optional<TitanBoolean>(TitanBoolean.class);
			sctp__shutdown__event = new Optional<TitanBoolean>(TitanBoolean.class);
			sctp__partial__delivery__event = new Optional<TitanBoolean>(TitanBoolean.class);
			sctp__adaptation__layer__event = new Optional<TitanBoolean>(TitanBoolean.class);
			sctp__authentication__event = new Optional<TitanBoolean>(TitanBoolean.class);
			sctp__sender__dry__event = new Optional<TitanBoolean>(TitanBoolean.class);
			operator_assign( otherValue );
		}

		public SctpEventHandle operator_assign(final SctpEventHandle otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.SctpEventHandle");
			if (otherValue != this) {
				if ( otherValue.get_field_sctp__data__io__event().is_bound() ) {
					this.sctp__data__io__event.operator_assign( otherValue.get_field_sctp__data__io__event() );
				} else {
					this.sctp__data__io__event.clean_up();
				}
				if ( otherValue.get_field_sctp__association__event().is_bound() ) {
					this.sctp__association__event.operator_assign( otherValue.get_field_sctp__association__event() );
				} else {
					this.sctp__association__event.clean_up();
				}
				if ( otherValue.get_field_sctp__address__event().is_bound() ) {
					this.sctp__address__event.operator_assign( otherValue.get_field_sctp__address__event() );
				} else {
					this.sctp__address__event.clean_up();
				}
				if ( otherValue.get_field_sctp__send__failure__event().is_bound() ) {
					this.sctp__send__failure__event.operator_assign( otherValue.get_field_sctp__send__failure__event() );
				} else {
					this.sctp__send__failure__event.clean_up();
				}
				if ( otherValue.get_field_sctp__peer__error__event().is_bound() ) {
					this.sctp__peer__error__event.operator_assign( otherValue.get_field_sctp__peer__error__event() );
				} else {
					this.sctp__peer__error__event.clean_up();
				}
				if ( otherValue.get_field_sctp__shutdown__event().is_bound() ) {
					this.sctp__shutdown__event.operator_assign( otherValue.get_field_sctp__shutdown__event() );
				} else {
					this.sctp__shutdown__event.clean_up();
				}
				if ( otherValue.get_field_sctp__partial__delivery__event().is_bound() ) {
					this.sctp__partial__delivery__event.operator_assign( otherValue.get_field_sctp__partial__delivery__event() );
				} else {
					this.sctp__partial__delivery__event.clean_up();
				}
				if ( otherValue.get_field_sctp__adaptation__layer__event().is_bound() ) {
					this.sctp__adaptation__layer__event.operator_assign( otherValue.get_field_sctp__adaptation__layer__event() );
				} else {
					this.sctp__adaptation__layer__event.clean_up();
				}
				if ( otherValue.get_field_sctp__authentication__event().is_bound() ) {
					this.sctp__authentication__event.operator_assign( otherValue.get_field_sctp__authentication__event() );
				} else {
					this.sctp__authentication__event.clean_up();
				}
				if ( otherValue.get_field_sctp__sender__dry__event().is_bound() ) {
					this.sctp__sender__dry__event.operator_assign( otherValue.get_field_sctp__sender__dry__event() );
				} else {
					this.sctp__sender__dry__event.clean_up();
				}
			}

			return this;
		}

		@Override
		public SctpEventHandle operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof SctpEventHandle ) {
				return operator_assign((SctpEventHandle) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.SctpEventHandle", otherValue));
		}

		@Override
		public void clean_up() {
			sctp__data__io__event.clean_up();
			sctp__association__event.clean_up();
			sctp__address__event.clean_up();
			sctp__send__failure__event.clean_up();
			sctp__peer__error__event.clean_up();
			sctp__shutdown__event.clean_up();
			sctp__partial__delivery__event.clean_up();
			sctp__adaptation__layer__event.clean_up();
			sctp__authentication__event.clean_up();
			sctp__sender__dry__event.clean_up();
		}

		@Override
		public boolean is_bound() {
			return optional_sel.OPTIONAL_OMIT.equals(sctp__data__io__event.get_selection()) || sctp__data__io__event.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(sctp__association__event.get_selection()) || sctp__association__event.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(sctp__address__event.get_selection()) || sctp__address__event.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(sctp__send__failure__event.get_selection()) || sctp__send__failure__event.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(sctp__peer__error__event.get_selection()) || sctp__peer__error__event.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(sctp__shutdown__event.get_selection()) || sctp__shutdown__event.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(sctp__partial__delivery__event.get_selection()) || sctp__partial__delivery__event.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(sctp__adaptation__layer__event.get_selection()) || sctp__adaptation__layer__event.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(sctp__authentication__event.get_selection()) || sctp__authentication__event.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(sctp__sender__dry__event.get_selection()) || sctp__sender__dry__event.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return (optional_sel.OPTIONAL_OMIT.equals(sctp__data__io__event.get_selection()) || sctp__data__io__event.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(sctp__association__event.get_selection()) || sctp__association__event.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(sctp__address__event.get_selection()) || sctp__address__event.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(sctp__send__failure__event.get_selection()) || sctp__send__failure__event.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(sctp__peer__error__event.get_selection()) || sctp__peer__error__event.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(sctp__shutdown__event.get_selection()) || sctp__shutdown__event.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(sctp__partial__delivery__event.get_selection()) || sctp__partial__delivery__event.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(sctp__adaptation__layer__event.get_selection()) || sctp__adaptation__layer__event.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(sctp__authentication__event.get_selection()) || sctp__authentication__event.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(sctp__sender__dry__event.get_selection()) || sctp__sender__dry__event.is_value());
		}

		public boolean operator_equals( final SctpEventHandle other_value) {
			return sctp__data__io__event.operator_equals( other_value.sctp__data__io__event )
					&& sctp__association__event.operator_equals( other_value.sctp__association__event )
					&& sctp__address__event.operator_equals( other_value.sctp__address__event )
					&& sctp__send__failure__event.operator_equals( other_value.sctp__send__failure__event )
					&& sctp__peer__error__event.operator_equals( other_value.sctp__peer__error__event )
					&& sctp__shutdown__event.operator_equals( other_value.sctp__shutdown__event )
					&& sctp__partial__delivery__event.operator_equals( other_value.sctp__partial__delivery__event )
					&& sctp__adaptation__layer__event.operator_equals( other_value.sctp__adaptation__layer__event )
					&& sctp__authentication__event.operator_equals( other_value.sctp__authentication__event )
					&& sctp__sender__dry__event.operator_equals( other_value.sctp__sender__dry__event );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof SctpEventHandle ) {
				return operator_equals((SctpEventHandle) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.SctpEventHandle", other_value));
		}

		public Optional<TitanBoolean> get_field_sctp__data__io__event() {
			return sctp__data__io__event;
		}

		public Optional<TitanBoolean> constGet_field_sctp__data__io__event() {
			return sctp__data__io__event;
		}

		public Optional<TitanBoolean> get_field_sctp__association__event() {
			return sctp__association__event;
		}

		public Optional<TitanBoolean> constGet_field_sctp__association__event() {
			return sctp__association__event;
		}

		public Optional<TitanBoolean> get_field_sctp__address__event() {
			return sctp__address__event;
		}

		public Optional<TitanBoolean> constGet_field_sctp__address__event() {
			return sctp__address__event;
		}

		public Optional<TitanBoolean> get_field_sctp__send__failure__event() {
			return sctp__send__failure__event;
		}

		public Optional<TitanBoolean> constGet_field_sctp__send__failure__event() {
			return sctp__send__failure__event;
		}

		public Optional<TitanBoolean> get_field_sctp__peer__error__event() {
			return sctp__peer__error__event;
		}

		public Optional<TitanBoolean> constGet_field_sctp__peer__error__event() {
			return sctp__peer__error__event;
		}

		public Optional<TitanBoolean> get_field_sctp__shutdown__event() {
			return sctp__shutdown__event;
		}

		public Optional<TitanBoolean> constGet_field_sctp__shutdown__event() {
			return sctp__shutdown__event;
		}

		public Optional<TitanBoolean> get_field_sctp__partial__delivery__event() {
			return sctp__partial__delivery__event;
		}

		public Optional<TitanBoolean> constGet_field_sctp__partial__delivery__event() {
			return sctp__partial__delivery__event;
		}

		public Optional<TitanBoolean> get_field_sctp__adaptation__layer__event() {
			return sctp__adaptation__layer__event;
		}

		public Optional<TitanBoolean> constGet_field_sctp__adaptation__layer__event() {
			return sctp__adaptation__layer__event;
		}

		public Optional<TitanBoolean> get_field_sctp__authentication__event() {
			return sctp__authentication__event;
		}

		public Optional<TitanBoolean> constGet_field_sctp__authentication__event() {
			return sctp__authentication__event;
		}

		public Optional<TitanBoolean> get_field_sctp__sender__dry__event() {
			return sctp__sender__dry__event;
		}

		public Optional<TitanBoolean> constGet_field_sctp__sender__dry__event() {
			return sctp__sender__dry__event;
		}

		public TitanInteger size_of() {
			int sizeof = 0;
			if (sctp__data__io__event.ispresent()) {
				sizeof++;
			}
			if (sctp__association__event.ispresent()) {
				sizeof++;
			}
			if (sctp__address__event.ispresent()) {
				sizeof++;
			}
			if (sctp__send__failure__event.ispresent()) {
				sizeof++;
			}
			if (sctp__peer__error__event.ispresent()) {
				sizeof++;
			}
			if (sctp__shutdown__event.ispresent()) {
				sizeof++;
			}
			if (sctp__partial__delivery__event.ispresent()) {
				sizeof++;
			}
			if (sctp__adaptation__layer__event.ispresent()) {
				sizeof++;
			}
			if (sctp__authentication__event.ispresent()) {
				sizeof++;
			}
			if (sctp__sender__dry__event.ispresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" sctp_data_io_event := ");
			sctp__data__io__event.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sctp_association_event := ");
			sctp__association__event.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sctp_address_event := ");
			sctp__address__event.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sctp_send_failure_event := ");
			sctp__send__failure__event.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sctp_peer_error_event := ");
			sctp__peer__error__event.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sctp_shutdown_event := ");
			sctp__shutdown__event.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sctp_partial_delivery_event := ");
			sctp__partial__delivery__event.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sctp_adaptation_layer_event := ");
			sctp__adaptation__layer__event.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sctp_authentication_event := ");
			sctp__authentication__event.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sctp_sender_dry_event := ");
			sctp__sender__dry__event.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 10) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.SctpEventHandle has 10 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__data__io__event().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__association__event().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__address__event().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__send__failure__event().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__peer__error__event().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__shutdown__event().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__partial__delivery__event().set_param(param.get_elem(6));
				}
				if (param.get_size() > 7 && param.get_elem(7).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__adaptation__layer__event().set_param(param.get_elem(7));
				}
				if (param.get_size() > 8 && param.get_elem(8).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__authentication__event().set_param(param.get_elem(8));
				}
				if (param.get_size() > 9 && param.get_elem(9).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__sender__dry__event().set_param(param.get_elem(9));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_data_io_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__data__io__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_association_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__association__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_address_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__address__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_send_failure_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__send__failure__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_peer_error_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__peer__error__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_shutdown_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__shutdown__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_partial_delivery_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__partial__delivery__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_adaptation_layer_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__adaptation__layer__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_authentication_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__authentication__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_sender_dry_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__sender__dry__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.SctpEventHandle: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.SctpEventHandle");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (sctp__data__io__event.is_bound()) {
				sctp__data__io__event.set_implicit_omit();
			} else {
				sctp__data__io__event.operator_assign(template_sel.OMIT_VALUE);
			}
			if (sctp__association__event.is_bound()) {
				sctp__association__event.set_implicit_omit();
			} else {
				sctp__association__event.operator_assign(template_sel.OMIT_VALUE);
			}
			if (sctp__address__event.is_bound()) {
				sctp__address__event.set_implicit_omit();
			} else {
				sctp__address__event.operator_assign(template_sel.OMIT_VALUE);
			}
			if (sctp__send__failure__event.is_bound()) {
				sctp__send__failure__event.set_implicit_omit();
			} else {
				sctp__send__failure__event.operator_assign(template_sel.OMIT_VALUE);
			}
			if (sctp__peer__error__event.is_bound()) {
				sctp__peer__error__event.set_implicit_omit();
			} else {
				sctp__peer__error__event.operator_assign(template_sel.OMIT_VALUE);
			}
			if (sctp__shutdown__event.is_bound()) {
				sctp__shutdown__event.set_implicit_omit();
			} else {
				sctp__shutdown__event.operator_assign(template_sel.OMIT_VALUE);
			}
			if (sctp__partial__delivery__event.is_bound()) {
				sctp__partial__delivery__event.set_implicit_omit();
			} else {
				sctp__partial__delivery__event.operator_assign(template_sel.OMIT_VALUE);
			}
			if (sctp__adaptation__layer__event.is_bound()) {
				sctp__adaptation__layer__event.set_implicit_omit();
			} else {
				sctp__adaptation__layer__event.operator_assign(template_sel.OMIT_VALUE);
			}
			if (sctp__authentication__event.is_bound()) {
				sctp__authentication__event.set_implicit_omit();
			} else {
				sctp__authentication__event.operator_assign(template_sel.OMIT_VALUE);
			}
			if (sctp__sender__dry__event.is_bound()) {
				sctp__sender__dry__event.set_implicit_omit();
			} else {
				sctp__sender__dry__event.operator_assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			sctp__data__io__event.encode_text(text_buf);
			sctp__association__event.encode_text(text_buf);
			sctp__address__event.encode_text(text_buf);
			sctp__send__failure__event.encode_text(text_buf);
			sctp__peer__error__event.encode_text(text_buf);
			sctp__shutdown__event.encode_text(text_buf);
			sctp__partial__delivery__event.encode_text(text_buf);
			sctp__adaptation__layer__event.encode_text(text_buf);
			sctp__authentication__event.encode_text(text_buf);
			sctp__sender__dry__event.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			sctp__data__io__event.decode_text(text_buf);
			sctp__association__event.decode_text(text_buf);
			sctp__address__event.decode_text(text_buf);
			sctp__send__failure__event.decode_text(text_buf);
			sctp__peer__error__event.decode_text(text_buf);
			sctp__shutdown__event.decode_text(text_buf);
			sctp__partial__delivery__event.decode_text(text_buf);
			sctp__adaptation__layer__event.decode_text(text_buf);
			sctp__authentication__event.decode_text(text_buf);
			sctp__sender__dry__event.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class SctpEventHandle_template extends Base_Template {
		private TitanBoolean_template sctp__data__io__event;
		private TitanBoolean_template sctp__association__event;
		private TitanBoolean_template sctp__address__event;
		private TitanBoolean_template sctp__send__failure__event;
		private TitanBoolean_template sctp__peer__error__event;
		private TitanBoolean_template sctp__shutdown__event;
		private TitanBoolean_template sctp__partial__delivery__event;
		private TitanBoolean_template sctp__adaptation__layer__event;
		private TitanBoolean_template sctp__authentication__event;
		private TitanBoolean_template sctp__sender__dry__event;
		//originally value_list/list_value
		private List<SctpEventHandle_template> list_value;


		public SctpEventHandle_template() {
			// do nothing
		}

		public SctpEventHandle_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public SctpEventHandle_template( final SctpEventHandle otherValue ) {
			copy_value(otherValue);
		}

		public SctpEventHandle_template( final SctpEventHandle_template otherValue ) {
			copy_template( otherValue );
		}

		public SctpEventHandle_template( final Optional<SctpEventHandle> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.SctpEventHandle from an unbound optional field.");
			}
		}

		@Override
		public SctpEventHandle_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public SctpEventHandle_template operator_assign( final SctpEventHandle otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public SctpEventHandle_template operator_assign( final SctpEventHandle_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public SctpEventHandle_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof SctpEventHandle) {
				return operator_assign((SctpEventHandle) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `SctpEventHandle' can not be cast to {1}", otherValue));
		}

		@Override
		public SctpEventHandle_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof SctpEventHandle_template) {
				return operator_assign((SctpEventHandle_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `SctpEventHandle' can not be cast to {1}_template", otherValue));
		}

		public SctpEventHandle_template operator_assign( final Optional<SctpEventHandle> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return this;
		}

		private void copy_value(final SctpEventHandle other_value) {
			if (other_value.get_field_sctp__data__io__event().is_bound()) {
				if (other_value.get_field_sctp__data__io__event().ispresent()) {
					get_field_sctp__data__io__event().operator_assign(other_value.get_field_sctp__data__io__event().get());
				} else {
					get_field_sctp__data__io__event().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_sctp__data__io__event().clean_up();
			}
			if (other_value.get_field_sctp__association__event().is_bound()) {
				if (other_value.get_field_sctp__association__event().ispresent()) {
					get_field_sctp__association__event().operator_assign(other_value.get_field_sctp__association__event().get());
				} else {
					get_field_sctp__association__event().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_sctp__association__event().clean_up();
			}
			if (other_value.get_field_sctp__address__event().is_bound()) {
				if (other_value.get_field_sctp__address__event().ispresent()) {
					get_field_sctp__address__event().operator_assign(other_value.get_field_sctp__address__event().get());
				} else {
					get_field_sctp__address__event().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_sctp__address__event().clean_up();
			}
			if (other_value.get_field_sctp__send__failure__event().is_bound()) {
				if (other_value.get_field_sctp__send__failure__event().ispresent()) {
					get_field_sctp__send__failure__event().operator_assign(other_value.get_field_sctp__send__failure__event().get());
				} else {
					get_field_sctp__send__failure__event().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_sctp__send__failure__event().clean_up();
			}
			if (other_value.get_field_sctp__peer__error__event().is_bound()) {
				if (other_value.get_field_sctp__peer__error__event().ispresent()) {
					get_field_sctp__peer__error__event().operator_assign(other_value.get_field_sctp__peer__error__event().get());
				} else {
					get_field_sctp__peer__error__event().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_sctp__peer__error__event().clean_up();
			}
			if (other_value.get_field_sctp__shutdown__event().is_bound()) {
				if (other_value.get_field_sctp__shutdown__event().ispresent()) {
					get_field_sctp__shutdown__event().operator_assign(other_value.get_field_sctp__shutdown__event().get());
				} else {
					get_field_sctp__shutdown__event().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_sctp__shutdown__event().clean_up();
			}
			if (other_value.get_field_sctp__partial__delivery__event().is_bound()) {
				if (other_value.get_field_sctp__partial__delivery__event().ispresent()) {
					get_field_sctp__partial__delivery__event().operator_assign(other_value.get_field_sctp__partial__delivery__event().get());
				} else {
					get_field_sctp__partial__delivery__event().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_sctp__partial__delivery__event().clean_up();
			}
			if (other_value.get_field_sctp__adaptation__layer__event().is_bound()) {
				if (other_value.get_field_sctp__adaptation__layer__event().ispresent()) {
					get_field_sctp__adaptation__layer__event().operator_assign(other_value.get_field_sctp__adaptation__layer__event().get());
				} else {
					get_field_sctp__adaptation__layer__event().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_sctp__adaptation__layer__event().clean_up();
			}
			if (other_value.get_field_sctp__authentication__event().is_bound()) {
				if (other_value.get_field_sctp__authentication__event().ispresent()) {
					get_field_sctp__authentication__event().operator_assign(other_value.get_field_sctp__authentication__event().get());
				} else {
					get_field_sctp__authentication__event().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_sctp__authentication__event().clean_up();
			}
			if (other_value.get_field_sctp__sender__dry__event().is_bound()) {
				if (other_value.get_field_sctp__sender__dry__event().ispresent()) {
					get_field_sctp__sender__dry__event().operator_assign(other_value.get_field_sctp__sender__dry__event().get());
				} else {
					get_field_sctp__sender__dry__event().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_sctp__sender__dry__event().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final SctpEventHandle_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_sctp__data__io__event().get_selection()) {
					get_field_sctp__data__io__event().clean_up();
				} else {
					get_field_sctp__data__io__event().operator_assign(other_value.get_field_sctp__data__io__event());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_sctp__association__event().get_selection()) {
					get_field_sctp__association__event().clean_up();
				} else {
					get_field_sctp__association__event().operator_assign(other_value.get_field_sctp__association__event());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_sctp__address__event().get_selection()) {
					get_field_sctp__address__event().clean_up();
				} else {
					get_field_sctp__address__event().operator_assign(other_value.get_field_sctp__address__event());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_sctp__send__failure__event().get_selection()) {
					get_field_sctp__send__failure__event().clean_up();
				} else {
					get_field_sctp__send__failure__event().operator_assign(other_value.get_field_sctp__send__failure__event());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_sctp__peer__error__event().get_selection()) {
					get_field_sctp__peer__error__event().clean_up();
				} else {
					get_field_sctp__peer__error__event().operator_assign(other_value.get_field_sctp__peer__error__event());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_sctp__shutdown__event().get_selection()) {
					get_field_sctp__shutdown__event().clean_up();
				} else {
					get_field_sctp__shutdown__event().operator_assign(other_value.get_field_sctp__shutdown__event());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_sctp__partial__delivery__event().get_selection()) {
					get_field_sctp__partial__delivery__event().clean_up();
				} else {
					get_field_sctp__partial__delivery__event().operator_assign(other_value.get_field_sctp__partial__delivery__event());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_sctp__adaptation__layer__event().get_selection()) {
					get_field_sctp__adaptation__layer__event().clean_up();
				} else {
					get_field_sctp__adaptation__layer__event().operator_assign(other_value.get_field_sctp__adaptation__layer__event());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_sctp__authentication__event().get_selection()) {
					get_field_sctp__authentication__event().clean_up();
				} else {
					get_field_sctp__authentication__event().operator_assign(other_value.get_field_sctp__authentication__event());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_sctp__sender__dry__event().get_selection()) {
					get_field_sctp__sender__dry__event().clean_up();
				} else {
					get_field_sctp__sender__dry__event().operator_assign(other_value.get_field_sctp__sender__dry__event());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<SctpEventHandle_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final SctpEventHandle_template temp = new SctpEventHandle_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.SctpEventHandle.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.SctpEventHandle.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<SctpEventHandle_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new SctpEventHandle_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return sctp__data__io__event.is_omit() || sctp__data__io__event.is_bound()
					|| sctp__association__event.is_omit() || sctp__association__event.is_bound()
					|| sctp__address__event.is_omit() || sctp__address__event.is_bound()
					|| sctp__send__failure__event.is_omit() || sctp__send__failure__event.is_bound()
					|| sctp__peer__error__event.is_omit() || sctp__peer__error__event.is_bound()
					|| sctp__shutdown__event.is_omit() || sctp__shutdown__event.is_bound()
					|| sctp__partial__delivery__event.is_omit() || sctp__partial__delivery__event.is_bound()
					|| sctp__adaptation__layer__event.is_omit() || sctp__adaptation__layer__event.is_bound()
					|| sctp__authentication__event.is_omit() || sctp__authentication__event.is_bound()
					|| sctp__sender__dry__event.is_omit() || sctp__sender__dry__event.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return (sctp__data__io__event.is_omit() || sctp__data__io__event.is_value())
					&& (sctp__association__event.is_omit() || sctp__association__event.is_value())
					&& (sctp__address__event.is_omit() || sctp__address__event.is_value())
					&& (sctp__send__failure__event.is_omit() || sctp__send__failure__event.is_value())
					&& (sctp__peer__error__event.is_omit() || sctp__peer__error__event.is_value())
					&& (sctp__shutdown__event.is_omit() || sctp__shutdown__event.is_value())
					&& (sctp__partial__delivery__event.is_omit() || sctp__partial__delivery__event.is_value())
					&& (sctp__adaptation__layer__event.is_omit() || sctp__adaptation__layer__event.is_value())
					&& (sctp__authentication__event.is_omit() || sctp__authentication__event.is_value())
					&& (sctp__sender__dry__event.is_omit() || sctp__sender__dry__event.is_value());
		}
		public TitanBoolean_template get_field_sctp__data__io__event() {
			set_specific();
			return sctp__data__io__event;
		}

		public TitanBoolean_template constGet_field_sctp__data__io__event() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctp_data_io_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return sctp__data__io__event;
		}

		public TitanBoolean_template get_field_sctp__association__event() {
			set_specific();
			return sctp__association__event;
		}

		public TitanBoolean_template constGet_field_sctp__association__event() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctp_association_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return sctp__association__event;
		}

		public TitanBoolean_template get_field_sctp__address__event() {
			set_specific();
			return sctp__address__event;
		}

		public TitanBoolean_template constGet_field_sctp__address__event() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctp_address_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return sctp__address__event;
		}

		public TitanBoolean_template get_field_sctp__send__failure__event() {
			set_specific();
			return sctp__send__failure__event;
		}

		public TitanBoolean_template constGet_field_sctp__send__failure__event() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctp_send_failure_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return sctp__send__failure__event;
		}

		public TitanBoolean_template get_field_sctp__peer__error__event() {
			set_specific();
			return sctp__peer__error__event;
		}

		public TitanBoolean_template constGet_field_sctp__peer__error__event() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctp_peer_error_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return sctp__peer__error__event;
		}

		public TitanBoolean_template get_field_sctp__shutdown__event() {
			set_specific();
			return sctp__shutdown__event;
		}

		public TitanBoolean_template constGet_field_sctp__shutdown__event() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctp_shutdown_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return sctp__shutdown__event;
		}

		public TitanBoolean_template get_field_sctp__partial__delivery__event() {
			set_specific();
			return sctp__partial__delivery__event;
		}

		public TitanBoolean_template constGet_field_sctp__partial__delivery__event() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctp_partial_delivery_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return sctp__partial__delivery__event;
		}

		public TitanBoolean_template get_field_sctp__adaptation__layer__event() {
			set_specific();
			return sctp__adaptation__layer__event;
		}

		public TitanBoolean_template constGet_field_sctp__adaptation__layer__event() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctp_adaptation_layer_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return sctp__adaptation__layer__event;
		}

		public TitanBoolean_template get_field_sctp__authentication__event() {
			set_specific();
			return sctp__authentication__event;
		}

		public TitanBoolean_template constGet_field_sctp__authentication__event() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctp_authentication_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return sctp__authentication__event;
		}

		public TitanBoolean_template get_field_sctp__sender__dry__event() {
			set_specific();
			return sctp__sender__dry__event;
		}

		public TitanBoolean_template constGet_field_sctp__sender__dry__event() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctp_sender_dry_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return sctp__sender__dry__event;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					sctp__data__io__event = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
					sctp__association__event = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
					sctp__address__event = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
					sctp__send__failure__event = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
					sctp__peer__error__event = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
					sctp__shutdown__event = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
					sctp__partial__delivery__event = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
					sctp__adaptation__layer__event = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
					sctp__authentication__event = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
					sctp__sender__dry__event = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
				} else {
					sctp__data__io__event = new TitanBoolean_template();
					sctp__association__event = new TitanBoolean_template();
					sctp__address__event = new TitanBoolean_template();
					sctp__send__failure__event = new TitanBoolean_template();
					sctp__peer__error__event = new TitanBoolean_template();
					sctp__shutdown__event = new TitanBoolean_template();
					sctp__partial__delivery__event = new TitanBoolean_template();
					sctp__adaptation__layer__event = new TitanBoolean_template();
					sctp__authentication__event = new TitanBoolean_template();
					sctp__sender__dry__event = new TitanBoolean_template();
				}
			}
		}
		public boolean match(final SctpEventHandle other_value) {
			return match(other_value, false);
		}

		public boolean match(final SctpEventHandle other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_sctp__data__io__event().is_bound()) {
					return false;
				}
				if((other_value.get_field_sctp__data__io__event().ispresent() ? !sctp__data__io__event.match(other_value.get_field_sctp__data__io__event().get(), legacy) : !sctp__data__io__event.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_sctp__association__event().is_bound()) {
					return false;
				}
				if((other_value.get_field_sctp__association__event().ispresent() ? !sctp__association__event.match(other_value.get_field_sctp__association__event().get(), legacy) : !sctp__association__event.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_sctp__address__event().is_bound()) {
					return false;
				}
				if((other_value.get_field_sctp__address__event().ispresent() ? !sctp__address__event.match(other_value.get_field_sctp__address__event().get(), legacy) : !sctp__address__event.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_sctp__send__failure__event().is_bound()) {
					return false;
				}
				if((other_value.get_field_sctp__send__failure__event().ispresent() ? !sctp__send__failure__event.match(other_value.get_field_sctp__send__failure__event().get(), legacy) : !sctp__send__failure__event.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_sctp__peer__error__event().is_bound()) {
					return false;
				}
				if((other_value.get_field_sctp__peer__error__event().ispresent() ? !sctp__peer__error__event.match(other_value.get_field_sctp__peer__error__event().get(), legacy) : !sctp__peer__error__event.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_sctp__shutdown__event().is_bound()) {
					return false;
				}
				if((other_value.get_field_sctp__shutdown__event().ispresent() ? !sctp__shutdown__event.match(other_value.get_field_sctp__shutdown__event().get(), legacy) : !sctp__shutdown__event.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_sctp__partial__delivery__event().is_bound()) {
					return false;
				}
				if((other_value.get_field_sctp__partial__delivery__event().ispresent() ? !sctp__partial__delivery__event.match(other_value.get_field_sctp__partial__delivery__event().get(), legacy) : !sctp__partial__delivery__event.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_sctp__adaptation__layer__event().is_bound()) {
					return false;
				}
				if((other_value.get_field_sctp__adaptation__layer__event().ispresent() ? !sctp__adaptation__layer__event.match(other_value.get_field_sctp__adaptation__layer__event().get(), legacy) : !sctp__adaptation__layer__event.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_sctp__authentication__event().is_bound()) {
					return false;
				}
				if((other_value.get_field_sctp__authentication__event().ispresent() ? !sctp__authentication__event.match(other_value.get_field_sctp__authentication__event().get(), legacy) : !sctp__authentication__event.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_sctp__sender__dry__event().is_bound()) {
					return false;
				}
				if((other_value.get_field_sctp__sender__dry__event().ispresent() ? !sctp__sender__dry__event.match(other_value.get_field_sctp__sender__dry__event().get(), legacy) : !sctp__sender__dry__event.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.SctpEventHandle.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof SctpEventHandle) {
				return match((SctpEventHandle)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type SctpEventHandle.");
		}


		@Override
		public SctpEventHandle valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
			}
			final SctpEventHandle ret_val = new SctpEventHandle();
			if (sctp__data__io__event.is_omit()) {
				ret_val.get_field_sctp__data__io__event().operator_assign(template_sel.OMIT_VALUE);
			} else if (sctp__data__io__event.is_bound()) {
				ret_val.get_field_sctp__data__io__event().operator_assign(sctp__data__io__event.valueof());
			}
			if (sctp__association__event.is_omit()) {
				ret_val.get_field_sctp__association__event().operator_assign(template_sel.OMIT_VALUE);
			} else if (sctp__association__event.is_bound()) {
				ret_val.get_field_sctp__association__event().operator_assign(sctp__association__event.valueof());
			}
			if (sctp__address__event.is_omit()) {
				ret_val.get_field_sctp__address__event().operator_assign(template_sel.OMIT_VALUE);
			} else if (sctp__address__event.is_bound()) {
				ret_val.get_field_sctp__address__event().operator_assign(sctp__address__event.valueof());
			}
			if (sctp__send__failure__event.is_omit()) {
				ret_val.get_field_sctp__send__failure__event().operator_assign(template_sel.OMIT_VALUE);
			} else if (sctp__send__failure__event.is_bound()) {
				ret_val.get_field_sctp__send__failure__event().operator_assign(sctp__send__failure__event.valueof());
			}
			if (sctp__peer__error__event.is_omit()) {
				ret_val.get_field_sctp__peer__error__event().operator_assign(template_sel.OMIT_VALUE);
			} else if (sctp__peer__error__event.is_bound()) {
				ret_val.get_field_sctp__peer__error__event().operator_assign(sctp__peer__error__event.valueof());
			}
			if (sctp__shutdown__event.is_omit()) {
				ret_val.get_field_sctp__shutdown__event().operator_assign(template_sel.OMIT_VALUE);
			} else if (sctp__shutdown__event.is_bound()) {
				ret_val.get_field_sctp__shutdown__event().operator_assign(sctp__shutdown__event.valueof());
			}
			if (sctp__partial__delivery__event.is_omit()) {
				ret_val.get_field_sctp__partial__delivery__event().operator_assign(template_sel.OMIT_VALUE);
			} else if (sctp__partial__delivery__event.is_bound()) {
				ret_val.get_field_sctp__partial__delivery__event().operator_assign(sctp__partial__delivery__event.valueof());
			}
			if (sctp__adaptation__layer__event.is_omit()) {
				ret_val.get_field_sctp__adaptation__layer__event().operator_assign(template_sel.OMIT_VALUE);
			} else if (sctp__adaptation__layer__event.is_bound()) {
				ret_val.get_field_sctp__adaptation__layer__event().operator_assign(sctp__adaptation__layer__event.valueof());
			}
			if (sctp__authentication__event.is_omit()) {
				ret_val.get_field_sctp__authentication__event().operator_assign(template_sel.OMIT_VALUE);
			} else if (sctp__authentication__event.is_bound()) {
				ret_val.get_field_sctp__authentication__event().operator_assign(sctp__authentication__event.valueof());
			}
			if (sctp__sender__dry__event.is_omit()) {
				ret_val.get_field_sctp__sender__dry__event().operator_assign(template_sel.OMIT_VALUE);
			} else if (sctp__sender__dry__event.is_bound()) {
				ret_val.get_field_sctp__sender__dry__event().operator_assign(sctp__sender__dry__event.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				int sizeof = 0;
				if (sctp__data__io__event.is_present()) {
					sizeof++;
				}
				if (sctp__association__event.is_present()) {
					sizeof++;
				}
				if (sctp__address__event.is_present()) {
					sizeof++;
				}
				if (sctp__send__failure__event.is_present()) {
					sizeof++;
				}
				if (sctp__peer__error__event.is_present()) {
					sizeof++;
				}
				if (sctp__shutdown__event.is_present()) {
					sizeof++;
				}
				if (sctp__partial__delivery__event.is_present()) {
					sizeof++;
				}
				if (sctp__adaptation__layer__event.is_present()) {
					sizeof++;
				}
				if (sctp__authentication__event.is_present()) {
					sizeof++;
				}
				if (sctp__sender__dry__event.is_present()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.SctpEventHandle.");
			}
		}

		@Override
		public SctpEventHandle_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.SctpEventHandle.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.SctpEventHandle using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.SctpEventHandle.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" sctp_data_io_event := ");
				sctp__data__io__event.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sctp_association_event := ");
				sctp__association__event.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sctp_address_event := ");
				sctp__address__event.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sctp_send_failure_event := ");
				sctp__send__failure__event.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sctp_peer_error_event := ");
				sctp__peer__error__event.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sctp_shutdown_event := ");
				sctp__shutdown__event.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sctp_partial_delivery_event := ");
				sctp__partial__delivery__event.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sctp_adaptation_layer_event := ");
				sctp__adaptation__layer__event.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sctp_authentication_event := ");
				sctp__authentication__event.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sctp_sender_dry_event := ");
				sctp__sender__dry__event.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final SctpEventHandle match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof SctpEventHandle) {
				log_match((SctpEventHandle)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.SctpEventHandle.");
		}

		public void log_match(final SctpEventHandle match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if (match_value.constGet_field_sctp__data__io__event().ispresent()) {
							if( !sctp__data__io__event.match(match_value.constGet_field_sctp__data__io__event().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".sctp_data_io_event");
								sctp__data__io__event.log_match(match_value.constGet_field_sctp__data__io__event().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!sctp__data__io__event.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".sctp_data_io_event := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								sctp__data__io__event.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_sctp__association__event().ispresent()) {
							if( !sctp__association__event.match(match_value.constGet_field_sctp__association__event().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".sctp_association_event");
								sctp__association__event.log_match(match_value.constGet_field_sctp__association__event().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!sctp__association__event.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".sctp_association_event := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								sctp__association__event.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_sctp__address__event().ispresent()) {
							if( !sctp__address__event.match(match_value.constGet_field_sctp__address__event().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".sctp_address_event");
								sctp__address__event.log_match(match_value.constGet_field_sctp__address__event().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!sctp__address__event.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".sctp_address_event := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								sctp__address__event.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_sctp__send__failure__event().ispresent()) {
							if( !sctp__send__failure__event.match(match_value.constGet_field_sctp__send__failure__event().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".sctp_send_failure_event");
								sctp__send__failure__event.log_match(match_value.constGet_field_sctp__send__failure__event().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!sctp__send__failure__event.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".sctp_send_failure_event := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								sctp__send__failure__event.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_sctp__peer__error__event().ispresent()) {
							if( !sctp__peer__error__event.match(match_value.constGet_field_sctp__peer__error__event().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".sctp_peer_error_event");
								sctp__peer__error__event.log_match(match_value.constGet_field_sctp__peer__error__event().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!sctp__peer__error__event.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".sctp_peer_error_event := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								sctp__peer__error__event.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_sctp__shutdown__event().ispresent()) {
							if( !sctp__shutdown__event.match(match_value.constGet_field_sctp__shutdown__event().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".sctp_shutdown_event");
								sctp__shutdown__event.log_match(match_value.constGet_field_sctp__shutdown__event().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!sctp__shutdown__event.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".sctp_shutdown_event := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								sctp__shutdown__event.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_sctp__partial__delivery__event().ispresent()) {
							if( !sctp__partial__delivery__event.match(match_value.constGet_field_sctp__partial__delivery__event().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".sctp_partial_delivery_event");
								sctp__partial__delivery__event.log_match(match_value.constGet_field_sctp__partial__delivery__event().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!sctp__partial__delivery__event.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".sctp_partial_delivery_event := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								sctp__partial__delivery__event.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_sctp__adaptation__layer__event().ispresent()) {
							if( !sctp__adaptation__layer__event.match(match_value.constGet_field_sctp__adaptation__layer__event().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".sctp_adaptation_layer_event");
								sctp__adaptation__layer__event.log_match(match_value.constGet_field_sctp__adaptation__layer__event().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!sctp__adaptation__layer__event.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".sctp_adaptation_layer_event := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								sctp__adaptation__layer__event.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_sctp__authentication__event().ispresent()) {
							if( !sctp__authentication__event.match(match_value.constGet_field_sctp__authentication__event().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".sctp_authentication_event");
								sctp__authentication__event.log_match(match_value.constGet_field_sctp__authentication__event().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!sctp__authentication__event.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".sctp_authentication_event := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								sctp__authentication__event.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_sctp__sender__dry__event().ispresent()) {
							if( !sctp__sender__dry__event.match(match_value.constGet_field_sctp__sender__dry__event().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".sctp_sender_dry_event");
								sctp__sender__dry__event.log_match(match_value.constGet_field_sctp__sender__dry__event().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!sctp__sender__dry__event.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".sctp_sender_dry_event := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								sctp__sender__dry__event.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ sctp_data_io_event := ");
				sctp__data__io__event.log_match(match_value.constGet_field_sctp__data__io__event(), legacy);
				TTCN_Logger.log_event_str("{ sctp_association_event := ");
				sctp__association__event.log_match(match_value.constGet_field_sctp__association__event(), legacy);
				TTCN_Logger.log_event_str("{ sctp_address_event := ");
				sctp__address__event.log_match(match_value.constGet_field_sctp__address__event(), legacy);
				TTCN_Logger.log_event_str("{ sctp_send_failure_event := ");
				sctp__send__failure__event.log_match(match_value.constGet_field_sctp__send__failure__event(), legacy);
				TTCN_Logger.log_event_str("{ sctp_peer_error_event := ");
				sctp__peer__error__event.log_match(match_value.constGet_field_sctp__peer__error__event(), legacy);
				TTCN_Logger.log_event_str("{ sctp_shutdown_event := ");
				sctp__shutdown__event.log_match(match_value.constGet_field_sctp__shutdown__event(), legacy);
				TTCN_Logger.log_event_str("{ sctp_partial_delivery_event := ");
				sctp__partial__delivery__event.log_match(match_value.constGet_field_sctp__partial__delivery__event(), legacy);
				TTCN_Logger.log_event_str("{ sctp_adaptation_layer_event := ");
				sctp__adaptation__layer__event.log_match(match_value.constGet_field_sctp__adaptation__layer__event(), legacy);
				TTCN_Logger.log_event_str("{ sctp_authentication_event := ");
				sctp__authentication__event.log_match(match_value.constGet_field_sctp__authentication__event(), legacy);
				TTCN_Logger.log_event_str("{ sctp_sender_dry_event := ");
				sctp__sender__dry__event.log_match(match_value.constGet_field_sctp__sender__dry__event(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				sctp__data__io__event.encode_text(text_buf);
				sctp__association__event.encode_text(text_buf);
				sctp__address__event.encode_text(text_buf);
				sctp__send__failure__event.encode_text(text_buf);
				sctp__peer__error__event.encode_text(text_buf);
				sctp__shutdown__event.encode_text(text_buf);
				sctp__partial__delivery__event.encode_text(text_buf);
				sctp__adaptation__layer__event.encode_text(text_buf);
				sctp__authentication__event.encode_text(text_buf);
				sctp__sender__dry__event.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.SctpEventHandle.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				sctp__data__io__event = new TitanBoolean_template();
				sctp__data__io__event.decode_text(text_buf);
				sctp__association__event = new TitanBoolean_template();
				sctp__association__event.decode_text(text_buf);
				sctp__address__event = new TitanBoolean_template();
				sctp__address__event.decode_text(text_buf);
				sctp__send__failure__event = new TitanBoolean_template();
				sctp__send__failure__event.decode_text(text_buf);
				sctp__peer__error__event = new TitanBoolean_template();
				sctp__peer__error__event.decode_text(text_buf);
				sctp__shutdown__event = new TitanBoolean_template();
				sctp__shutdown__event.decode_text(text_buf);
				sctp__partial__delivery__event = new TitanBoolean_template();
				sctp__partial__delivery__event.decode_text(text_buf);
				sctp__adaptation__layer__event = new TitanBoolean_template();
				sctp__adaptation__layer__event.decode_text(text_buf);
				sctp__authentication__event = new TitanBoolean_template();
				sctp__authentication__event.decode_text(text_buf);
				sctp__sender__dry__event = new TitanBoolean_template();
				sctp__sender__dry__event.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<SctpEventHandle_template>(size);
				for (int i = 0; i < size; i++) {
					final SctpEventHandle_template temp = new SctpEventHandle_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.SctpEventHandle.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 10) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.SctpEventHandle has 10 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__data__io__event().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__association__event().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__address__event().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__send__failure__event().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__peer__error__event().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__shutdown__event().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__partial__delivery__event().set_param(param.get_elem(6));
				}
				if (param.get_size() > 7 && param.get_elem(7).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__adaptation__layer__event().set_param(param.get_elem(7));
				}
				if (param.get_size() > 8 && param.get_elem(8).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__authentication__event().set_param(param.get_elem(8));
				}
				if (param.get_size() > 9 && param.get_elem(9).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_sctp__sender__dry__event().set_param(param.get_elem(9));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_data_io_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__data__io__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_association_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__association__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_address_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__address__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_send_failure_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__send__failure__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_peer_error_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__peer__error__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_shutdown_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__shutdown__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_partial_delivery_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__partial__delivery__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_adaptation_layer_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__adaptation__layer__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_authentication_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__authentication__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sctp_sender_dry_event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_sctp__sender__dry__event().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.SctpEventHandle: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.SctpEventHandle");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.sctp__data__io__event.check_restriction(restriction, name == null ? "@IPL4asp_Types.SctpEventHandle" : name, legacy);
				this.sctp__association__event.check_restriction(restriction, name == null ? "@IPL4asp_Types.SctpEventHandle" : name, legacy);
				this.sctp__address__event.check_restriction(restriction, name == null ? "@IPL4asp_Types.SctpEventHandle" : name, legacy);
				this.sctp__send__failure__event.check_restriction(restriction, name == null ? "@IPL4asp_Types.SctpEventHandle" : name, legacy);
				this.sctp__peer__error__event.check_restriction(restriction, name == null ? "@IPL4asp_Types.SctpEventHandle" : name, legacy);
				this.sctp__shutdown__event.check_restriction(restriction, name == null ? "@IPL4asp_Types.SctpEventHandle" : name, legacy);
				this.sctp__partial__delivery__event.check_restriction(restriction, name == null ? "@IPL4asp_Types.SctpEventHandle" : name, legacy);
				this.sctp__adaptation__layer__event.check_restriction(restriction, name == null ? "@IPL4asp_Types.SctpEventHandle" : name, legacy);
				this.sctp__authentication__event.check_restriction(restriction, name == null ? "@IPL4asp_Types.SctpEventHandle" : name, legacy);
				this.sctp__sender__dry__event.check_restriction(restriction, name == null ? "@IPL4asp_Types.SctpEventHandle" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.SctpEventHandle" : name));
		}
	}
	public static class IPL4__IPAddressType extends Base_Type {
		public enum enum_type {
			ErrorReadingAddress (0),
			IPv4 (1),
			IPv6 (2),
			UNKNOWN_VALUE(3),
			UNBOUND_VALUE(4);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return ErrorReadingAddress;
				case 1:  return IPv4;
				case 2:  return IPv6;
				case 3:  return UNKNOWN_VALUE;
				case 4:  return UNBOUND_VALUE;

				default:
					return null;
				}
			}

			}

		public enum_type enum_value;
		//===Constructors===;
		public IPL4__IPAddressType() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public IPL4__IPAddressType(final IPL4__IPAddressType otherValue) {
			enum_value = otherValue.enum_value;
		}

		public IPL4__IPAddressType(final IPL4__IPAddressType.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public IPL4__IPAddressType(final int otherValue) {
			if (!is_valid_enum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `IPL4__IPAddressType' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		public IPL4__IPAddressType operator_assign(final IPL4__IPAddressType otherValue){
			otherValue.must_bound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public IPL4__IPAddressType operator_assign(final Base_Type otherValue){
			if( otherValue instanceof IPL4__IPAddressType ) {
				return operator_assign((IPL4__IPAddressType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `IPL4__IPAddressType' can not be cast to {1}", otherValue));
		}

		public IPL4__IPAddressType operator_assign(final IPL4__IPAddressType.enum_type otherValue){
			return operator_assign( new IPL4__IPAddressType(otherValue) );
		}

		public IPL4__IPAddressType operator_assign(final int otherValue){
			if (!is_valid_enum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `IPL4__IPAddressType'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		public boolean operator_equals(final IPL4__IPAddressType otherValue){
			return enum_value == otherValue.enum_value;
		}

		public boolean operator_equals(final Base_Type otherValue){
			if (otherValue instanceof IPL4__IPAddressType) {
				return operator_equals( (IPL4__IPAddressType) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.IPL4_IPAddressType.");
			}
		}

		public boolean operator_equals(final IPL4__IPAddressType.enum_type otherValue){
			return enum_value == otherValue;
		}

		public boolean operator_not_equals(final IPL4__IPAddressType otherValue){
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals(final Base_Type otherValue){
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals(final IPL4__IPAddressType.enum_type otherValue){
			return !operator_equals(otherValue);
		}

		public boolean is_less_than(final IPL4__IPAddressType.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			return enum_value.enum_num < otherValue.enum_num;
		}

		public boolean is_less_than(final IPL4__IPAddressType otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		public boolean is_less_than_or_equal(final IPL4__IPAddressType.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			return enum_value.enum_num <= otherValue.enum_num;
		}

		public boolean is_less_than_or_equal(final IPL4__IPAddressType otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			return enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		public boolean is_greater_than(final IPL4__IPAddressType.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			return enum_value.enum_num > otherValue.enum_num;
		}

		public boolean is_greater_than(final IPL4__IPAddressType otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			return enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		public boolean is_greater_than_or_equal(final IPL4__IPAddressType.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			return enum_value.enum_num >= otherValue.enum_num;
		}

		public boolean is_greater_than_or_equal(final IPL4__IPAddressType otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__IPAddressType. ");
			return enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		@Override
		public boolean is_value() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		@Override
		public void clean_up() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean is_valid_enum(final int other_value) {
			final enum_type helper =  enum_type.getValue(other_value);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean is_valid_enum(final enum_type other_value) {
			return other_value != enum_type.UNKNOWN_VALUE && other_value != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!is_valid_enum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!is_valid_enum(intValue.get_int())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.get_int()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.get_int());
		}

		public static int enum2int(final IPL4__IPAddressType.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final IPL4__IPAddressType enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("ErrorReadingAddress".equals(strPar)) {
				return enum_type.ErrorReadingAddress;
			}
			if ("IPv4".equals(strPar)) {
				return enum_type.IPv4;
			}
			if ("IPv6".equals(strPar)) {
				return enum_type.IPv6;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum_to_str(final enum_type enumPar) {
			return enumPar.name();
		}

		public int as_int() {
			return enum2int(enum_value);
		}

		public void from_int(final int intValue) {
			enum_value = enum_type.getValue(intValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		@Override
		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum_to_str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@IPL4asp_Types.IPL4_IPAddressType");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!is_valid_enum(enum_value)) {
				param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_IPAddressType.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().get_int();
			if (!is_valid_enum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @IPL4asp_Types.IPL4_IPAddressType.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class IPL4__IPAddressType_template extends Base_Template {
		// single_value
		private IPL4__IPAddressType.enum_type single_value;
		// value_list part
		private ArrayList<IPL4__IPAddressType_template> value_list;

		private void copy_value(final IPL4__IPAddressType other_value) {
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = other_value.enum_value;
		}

		private void copy_template(final IPL4__IPAddressType_template otherValue) {
			set_selection(otherValue);
			switch (otherValue.template_selection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<IPL4__IPAddressType_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final IPL4__IPAddressType_template temp = new IPL4__IPAddressType_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
			}
		}

		public IPL4__IPAddressType_template() {
			// do nothing
		}

		public IPL4__IPAddressType_template(final template_sel otherValue) {
			super(otherValue);
			check_single_selection(otherValue);
		}

		public IPL4__IPAddressType_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!IPL4__IPAddressType.is_valid_enum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType with unknown numeric value "+ otherValue +".");
			}
			single_value = IPL4__IPAddressType.enum_type.getValue(otherValue);
		}

		public IPL4__IPAddressType_template(final IPL4__IPAddressType otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			otherValue.must_bound("Creating a template from an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType. ");
			single_value = otherValue.enum_value;
		}

		public IPL4__IPAddressType_template( final Optional<IPL4__IPAddressType> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.IPL4_IPAddressType from an unbound optional field.");
			}
		}

		public IPL4__IPAddressType_template(final IPL4__IPAddressType_template otherValue) {
			copy_template(otherValue);
		}

		public IPL4__IPAddressType_template(final IPL4__IPAddressType.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		@Override
		public void clean_up() {
			if (template_selection == template_sel.VALUE_LIST || template_selection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		@Override
		public boolean is_bound() {
			return template_selection != template_sel.UNINITIALIZED_TEMPLATE || is_ifPresent;
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != IPL4__IPAddressType.enum_type.UNBOUND_VALUE;
		}

		@Override
		public IPL4__IPAddressType_template operator_assign(final template_sel otherValue) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public IPL4__IPAddressType_template operator_assign(final int otherValue) {
			if (!IPL4__IPAddressType.is_valid_enum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
			}
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		public IPL4__IPAddressType_template operator_assign(final IPL4__IPAddressType.enum_type otherValue){
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		public IPL4__IPAddressType_template operator_assign(final IPL4__IPAddressType_template otherValue){
			// otherValue.must_bound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public IPL4__IPAddressType_template operator_assign(final IPL4__IPAddressType otherValue){
			otherValue.must_bound("Assignment of an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType to a template. ");
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public IPL4__IPAddressType_template operator_assign(final Base_Type otherValue){
			if( otherValue instanceof IPL4__IPAddressType ) {
				return operator_assign((IPL4__IPAddressType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.IPL4_IPAddressType' can not be cast to {1}", otherValue));
		}

		@Override
		public IPL4__IPAddressType_template operator_assign(final Base_Template otherValue){
			if( otherValue instanceof IPL4__IPAddressType_template ) {
				return operator_assign((IPL4__IPAddressType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.IPL4_IPAddressType'_template can not be cast to {1}", otherValue));
		}

		public boolean match(final IPL4__IPAddressType.enum_type otherValue) {
			return match(otherValue, false);
		}

		public boolean match(final IPL4__IPAddressType.enum_type otherValue, final boolean legacy) {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
			}
		}

		public boolean match(final IPL4__IPAddressType otherValue) {
			return match(otherValue.enum_value, false);
		}

		public boolean match(final IPL4__IPAddressType otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof IPL4__IPAddressType ) {
				return match((IPL4__IPAddressType) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.IPL4_IPAddressType' can not be cast to {1}", otherValue));
		}

		@Override
		public IPL4__IPAddressType valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
			}
			return new IPL4__IPAddressType(single_value);
		}

		@Override
		public void set_type(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
			}
			clean_up();
			set_selection(templateType);
			value_list = new ArrayList<IPL4__IPAddressType_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new IPL4__IPAddressType_template());
			}
		}

		@Override
		public IPL4__IPAddressType_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type IPL4__IPAddressType using a negative index ({0}).", list_index));
			} else if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
			}
			return value_list.get(list_index);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(IPL4__IPAddressType.enum_to_str(single_value), IPL4__IPAddressType.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof IPL4__IPAddressType) {
				log_match((IPL4__IPAddressType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.IPL4_IPAddressType.");
		}

		public void log_match(final IPL4__IPAddressType match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final IPL4__IPAddressType.enum_type enum_value = IPL4__IPAddressType.str_to_enum(param.get_enumerated());
				if (!IPL4__IPAddressType.is_valid_enum(enum_value)) {
					param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_IPAddressType.");
				}
				operator_assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@IPL4asp_Types.IPL4_IPAddressType");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().get_int();
				if (!IPL4__IPAddressType.is_valid_enum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @IPL4asp_Types.IPL4_IPAddressType.", temp));
				}
				single_value = IPL4__IPAddressType.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				value_list = new ArrayList<IPL4__IPAddressType_template>(size);
				for (int i = 0; i < size; i++) {
					final IPL4__IPAddressType_template temp = new IPL4__IPAddressType_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && template_selection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (template_selection == template_sel.OMIT_VALUE || template_selection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.IPL4_IPAddressType" : name));
		}
	}
	public static class Option_alpn__list extends PreGenRecordOf.PREGEN__RECORD__OF__CHARSTRING {
		public Option_alpn__list() {
			super();
		}
		public Option_alpn__list(final Option_alpn__list other_value) {
			super(other_value);
		}
		public Option_alpn__list(final TitanNull_Type other_value) {
			super(other_value);
		}
		public Option_alpn__list(final PreGenRecordOf.PREGEN__RECORD__OF__CHARSTRING other_value) {
			super(other_value);
		}
	@Override
		public Option_alpn__list operator_concatenate(PreGenRecordOf.PREGEN__RECORD__OF__CHARSTRING other_value) {
			must_bound("Unbound operand of @IPL4asp_Types.Option.alpn_list concatenation.");
			other_value.must_bound("Unbound operand of @IPL4asp_Types.Option.alpn_list concatenation.");
		final Option_alpn__list ret_val = new Option_alpn__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i < valueElements.size(); i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		for (int i = 0; i < other_value.lengthof().get_int(); i++) {
			final TitanCharString elem = other_value.get_at(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		return ret_val;
	}
	}
	public static class Option_alpn__list_template extends PreGenRecordOf.PREGEN__RECORD__OF__CHARSTRING_template {
		public Option_alpn__list_template() {
			super();
		}
		public Option_alpn__list_template(final Option_alpn__list other_value) {
			super(other_value);
		}
		public Option_alpn__list_template(final Option_alpn__list_template other_template) {
			super(other_template);
		}
		public Option_alpn__list_template(final template_sel other_template) {
			super(other_template);
		}
		public Option_alpn__list_template(final TitanNull_Type other_template) {
			super(other_template);
		}
		public Option_alpn__list_template(final PreGenRecordOf.PREGEN__RECORD__OF__CHARSTRING_template other_template) {
			super(other_template);
		}
		public Option_alpn__list_template( final Optional<Option_alpn__list> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.Option.alpn_list from an unbound optional field.");
			}
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PreGenRecordOf.PREGEN__RECORD__OF__CHARSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new Option_alpn__list_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @IPL4asp_Types.Option.alpn_list.");
			}
			set_selection(template_type);
		}
		@Override
		public Option_alpn__list_template list_item(final int list_index) {
			return (Option_alpn__list_template)super.list_item(list_index);
		}
		@Override
		public Option_alpn__list valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.Option.alpn_list.");
			}
			final Option_alpn__list ret_val = new Option_alpn__list(TitanNull_Type.NULL_VALUE);
			int i = 0;
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).is_bound()) {
					ret_val.get_at(i).operator_assign(value_elements.get(elem_count).valueof());
					i++;
				}
			}
			return ret_val;
			}
		}
	public static class ProtoTuple extends Socket__API__Definitions.ProtoTuple { }
	public static class ProtoTuple_template extends Socket__API__Definitions.ProtoTuple_template { }
	public static class MTU__discover extends Base_Type {
		public enum enum_type {
			PMTUDISC__DONT (0),
			PMTUDISC__WANT (1),
			PMTUDISC__DO (2),
			MTU (3),
			UNKNOWN_VALUE(4),
			UNBOUND_VALUE(5);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return PMTUDISC__DONT;
				case 1:  return PMTUDISC__WANT;
				case 2:  return PMTUDISC__DO;
				case 3:  return MTU;
				case 4:  return UNKNOWN_VALUE;
				case 5:  return UNBOUND_VALUE;

				default:
					return null;
				}
			}

			}

		public enum_type enum_value;
		//===Constructors===;
		public MTU__discover() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public MTU__discover(final MTU__discover otherValue) {
			enum_value = otherValue.enum_value;
		}

		public MTU__discover(final MTU__discover.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public MTU__discover(final int otherValue) {
			if (!is_valid_enum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `MTU__discover' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		public MTU__discover operator_assign(final MTU__discover otherValue){
			otherValue.must_bound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public MTU__discover operator_assign(final Base_Type otherValue){
			if( otherValue instanceof MTU__discover ) {
				return operator_assign((MTU__discover) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MTU__discover' can not be cast to {1}", otherValue));
		}

		public MTU__discover operator_assign(final MTU__discover.enum_type otherValue){
			return operator_assign( new MTU__discover(otherValue) );
		}

		public MTU__discover operator_assign(final int otherValue){
			if (!is_valid_enum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `MTU__discover'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		public boolean operator_equals(final MTU__discover otherValue){
			return enum_value == otherValue.enum_value;
		}

		public boolean operator_equals(final Base_Type otherValue){
			if (otherValue instanceof MTU__discover) {
				return operator_equals( (MTU__discover) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.MTU_discover.");
			}
		}

		public boolean operator_equals(final MTU__discover.enum_type otherValue){
			return enum_value == otherValue;
		}

		public boolean operator_not_equals(final MTU__discover otherValue){
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals(final Base_Type otherValue){
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals(final MTU__discover.enum_type otherValue){
			return !operator_equals(otherValue);
		}

		public boolean is_less_than(final MTU__discover.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type MTU__discover. ");
			return enum_value.enum_num < otherValue.enum_num;
		}

		public boolean is_less_than(final MTU__discover otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type MTU__discover. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type MTU__discover. ");
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		public boolean is_less_than_or_equal(final MTU__discover.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type MTU__discover. ");
			return enum_value.enum_num <= otherValue.enum_num;
		}

		public boolean is_less_than_or_equal(final MTU__discover otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type MTU__discover. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type MTU__discover. ");
			return enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		public boolean is_greater_than(final MTU__discover.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type MTU__discover. ");
			return enum_value.enum_num > otherValue.enum_num;
		}

		public boolean is_greater_than(final MTU__discover otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type MTU__discover. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type MTU__discover. ");
			return enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		public boolean is_greater_than_or_equal(final MTU__discover.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type MTU__discover. ");
			return enum_value.enum_num >= otherValue.enum_num;
		}

		public boolean is_greater_than_or_equal(final MTU__discover otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type MTU__discover. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type MTU__discover. ");
			return enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		@Override
		public boolean is_value() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		@Override
		public void clean_up() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean is_valid_enum(final int other_value) {
			final enum_type helper =  enum_type.getValue(other_value);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean is_valid_enum(final enum_type other_value) {
			return other_value != enum_type.UNKNOWN_VALUE && other_value != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!is_valid_enum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!is_valid_enum(intValue.get_int())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.get_int()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.get_int());
		}

		public static int enum2int(final MTU__discover.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final MTU__discover enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("PMTUDISC__DONT".equals(strPar) || "PMTUDISC_DONT".equals(strPar)) {
				return enum_type.PMTUDISC__DONT;
			}
			if ("PMTUDISC__WANT".equals(strPar) || "PMTUDISC_WANT".equals(strPar)) {
				return enum_type.PMTUDISC__WANT;
			}
			if ("PMTUDISC__DO".equals(strPar) || "PMTUDISC_DO".equals(strPar)) {
				return enum_type.PMTUDISC__DO;
			}
			if ("MTU".equals(strPar)) {
				return enum_type.MTU;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum_to_str(final enum_type enumPar) {
			return enumPar.name();
		}

		public int as_int() {
			return enum2int(enum_value);
		}

		public void from_int(final int intValue) {
			enum_value = enum_type.getValue(intValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		@Override
		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum_to_str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@IPL4asp_Types.MTU_discover");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!is_valid_enum(enum_value)) {
				param.error("Invalid enumerated value for type @IPL4asp_Types.MTU_discover.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of enumerated type @IPL4asp_Types.MTU_discover.");
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().get_int();
			if (!is_valid_enum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @IPL4asp_Types.MTU_discover.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MTU__discover_template extends Base_Template {
		// single_value
		private MTU__discover.enum_type single_value;
		// value_list part
		private ArrayList<MTU__discover_template> value_list;

		private void copy_value(final MTU__discover other_value) {
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = other_value.enum_value;
		}

		private void copy_template(final MTU__discover_template otherValue) {
			set_selection(otherValue);
			switch (otherValue.template_selection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<MTU__discover_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final MTU__discover_template temp = new MTU__discover_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type @IPL4asp_Types.MTU_discover.");
			}
		}

		public MTU__discover_template() {
			// do nothing
		}

		public MTU__discover_template(final template_sel otherValue) {
			super(otherValue);
			check_single_selection(otherValue);
		}

		public MTU__discover_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!MTU__discover.is_valid_enum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type @IPL4asp_Types.MTU_discover with unknown numeric value "+ otherValue +".");
			}
			single_value = MTU__discover.enum_type.getValue(otherValue);
		}

		public MTU__discover_template(final MTU__discover otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			otherValue.must_bound("Creating a template from an unbound value of enumerated type @IPL4asp_Types.MTU_discover. ");
			single_value = otherValue.enum_value;
		}

		public MTU__discover_template( final Optional<MTU__discover> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.MTU_discover from an unbound optional field.");
			}
		}

		public MTU__discover_template(final MTU__discover_template otherValue) {
			copy_template(otherValue);
		}

		public MTU__discover_template(final MTU__discover.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		@Override
		public void clean_up() {
			if (template_selection == template_sel.VALUE_LIST || template_selection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		@Override
		public boolean is_bound() {
			return template_selection != template_sel.UNINITIALIZED_TEMPLATE || is_ifPresent;
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != MTU__discover.enum_type.UNBOUND_VALUE;
		}

		@Override
		public MTU__discover_template operator_assign(final template_sel otherValue) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public MTU__discover_template operator_assign(final int otherValue) {
			if (!MTU__discover.is_valid_enum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type @IPL4asp_Types.MTU_discover.");
			}
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		public MTU__discover_template operator_assign(final MTU__discover.enum_type otherValue){
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		public MTU__discover_template operator_assign(final MTU__discover_template otherValue){
			// otherValue.must_bound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public MTU__discover_template operator_assign(final MTU__discover otherValue){
			otherValue.must_bound("Assignment of an unbound value of enumerated type @IPL4asp_Types.MTU_discover to a template. ");
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public MTU__discover_template operator_assign(final Base_Type otherValue){
			if( otherValue instanceof MTU__discover ) {
				return operator_assign((MTU__discover) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.MTU_discover' can not be cast to {1}", otherValue));
		}

		@Override
		public MTU__discover_template operator_assign(final Base_Template otherValue){
			if( otherValue instanceof MTU__discover_template ) {
				return operator_assign((MTU__discover_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.MTU_discover'_template can not be cast to {1}", otherValue));
		}

		public boolean match(final MTU__discover.enum_type otherValue) {
			return match(otherValue, false);
		}

		public boolean match(final MTU__discover.enum_type otherValue, final boolean legacy) {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type @IPL4asp_Types.MTU_discover.");
			}
		}

		public boolean match(final MTU__discover otherValue) {
			return match(otherValue.enum_value, false);
		}

		public boolean match(final MTU__discover otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof MTU__discover ) {
				return match((MTU__discover) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.MTU_discover' can not be cast to {1}", otherValue));
		}

		@Override
		public MTU__discover valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type @IPL4asp_Types.MTU_discover.");
			}
			return new MTU__discover(single_value);
		}

		@Override
		public void set_type(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type @IPL4asp_Types.MTU_discover.");
			}
			clean_up();
			set_selection(templateType);
			value_list = new ArrayList<MTU__discover_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new MTU__discover_template());
			}
		}

		@Override
		public MTU__discover_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type @IPL4asp_Types.MTU_discover.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type MTU__discover using a negative index ({0}).", list_index));
			} else if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type @IPL4asp_Types.MTU_discover.");
			}
			return value_list.get(list_index);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(MTU__discover.enum_to_str(single_value), MTU__discover.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MTU__discover) {
				log_match((MTU__discover)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.MTU_discover.");
		}

		public void log_match(final MTU__discover match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final MTU__discover.enum_type enum_value = MTU__discover.str_to_enum(param.get_enumerated());
				if (!MTU__discover.is_valid_enum(enum_value)) {
					param.error("Invalid enumerated value for type @IPL4asp_Types.MTU_discover.");
				}
				operator_assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@IPL4asp_Types.MTU_discover");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @IPL4asp_Types.MTU_discover.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().get_int();
				if (!MTU__discover.is_valid_enum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @IPL4asp_Types.MTU_discover.", temp));
				}
				single_value = MTU__discover.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				value_list = new ArrayList<MTU__discover_template>(size);
				for (int i = 0; i < size; i++) {
					final MTU__discover_template temp = new MTU__discover_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @IPL4asp_Types.MTU_discover.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && template_selection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (template_selection == template_sel.OMIT_VALUE || template_selection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.MTU_discover" : name));
		}
	}
	public static class f__getMsgLen extends Socket__API__Definitions.f__getMsgLen { }
	public static class f__getMsgLen_template extends Socket__API__Definitions.f__getMsgLen_template { }
	public static class SAC__STATE extends Socket__API__Definitions.SAC__STATE { }
	public static class SAC__STATE_template extends Socket__API__Definitions.SAC__STATE_template { }
	public static class ro__ConnectionId extends Socket__API__Definitions.ro__ConnectionId { }
	public static class ro__ConnectionId_template extends Socket__API__Definitions.ro__ConnectionId_template { }
	public static class TcpTuple extends Socket__API__Definitions.TcpTuple { }
	public static class TcpTuple_template extends Socket__API__Definitions.TcpTuple_template { }
	public static class HostList extends Base_Type {

		protected List<TitanCharString> valueElements;

		public HostList() {
			// do nothing
		}

		public HostList( final HostList otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @IPL4asp_Types.HostList.");
			valueElements = copy_list( otherValue.valueElements );
		}


		public HostList(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
		}

		private static final List<TitanCharString> copy_list( final List<TitanCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanCharString> newList = new ArrayList<TitanCharString>( srcList.size() );
			for (final TitanCharString srcElem : srcList) {
				final TitanCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			for (int i=0; i < valueElements.size(); i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type otherValue) {
			if (otherValue instanceof HostList) {
				return operator_equals((HostList)otherValue);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type HostList.");
		}

		public boolean operator_equals( final HostList otherValue ) {
			must_bound("The left operand of comparison is an unbound value of type @IPL4asp_Types.HostList.");
			otherValue.must_bound("The right operand of comparison is an unbound value of type @IPL4asp_Types.HostList.");

			final int size = valueElements.size();
			if ( size != otherValue.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanCharString leftElem = valueElements.get( i );
				final TitanCharString rightElem = otherValue.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public HostList operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof HostList) {
				return operator_assign((HostList)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type HostList.");
		}

		public HostList operator_assign( final HostList otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @IPL4asp_Types.HostList." );

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		public HostList operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
			return this;
		}

		public HostList operator_concatenate(final HostList other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @IPL4asp_Types.HostList concatenation.");
			}
			final HostList ret_val = new HostList(TitanNull_Type.NULL_VALUE);
			for (int i=0; i < valueElements.size(); i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < other_value.valueElements.size(); i++) {
				final TitanCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		public HostList operator_concatenate(final TitanNull_Type null_value) {
			return new HostList(this);
		}

		public HostList rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		public HostList rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		public HostList rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		public HostList rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @IPL4asp_Types.HostList.");
			final int size = valueElements.size();
			if (size == 0) {
				return new HostList(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new HostList(this);
			}
			final HostList ret_val = new HostList(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		public TitanCharString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @IPL4asp_Types.HostList using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			if ( valueElements.get( index_value ) == null ) {
				final TitanCharString newElem = get_unbound_elem();
				valueElements.set( index_value, newElem );
			}
			return valueElements.get( index_value );
		}

		public TitanCharString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @IPL4asp_Types.HostList." );
			return get_at( index_value.get_int() );
		}

		public TitanCharString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @IPL4asp_Types.HostList." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @IPL4asp_Types.HostList using a negative index: "+index_value+".");
			}
			final int nofElements = n_elem().get_int();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @IPL4asp_Types.HostList: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanCharString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		public TitanCharString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @IPL4asp_Types.HostList." );
			return constGet_at( index_value.get_int() );
		}

		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @IPL4asp_Types.HostList.");
			return new TitanInteger(valueElements.size());
		}

		public TitanInteger n_elem() {
			return size_of();
		}

		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @IPL4asp_Types.HostList.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanCharString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @IPL4asp_Types.HostList.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanCharString>(newSize);
			}
			if (newSize > valueElements.size()) {
				for ( int i = valueElements.size(); i < newSize; i++ ) {
					valueElements.add( new TitanCharString() );
				}
			} else if (newSize < valueElements.size()) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanCharString get_unbound_elem() {
			return new TitanCharString();
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		public HostList substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @IPL4asp_Types.HostList.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@IPL4asp_Types.HostList","element");
			final HostList ret_val = new HostList(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		public HostList replace(final int index, final int len, final HostList repl) {
			must_bound("The first argument of replace() is an unbound value of type @IPL4asp_Types.HostList.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @IPL4asp_Types.HostList.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@IPL4asp_Types.HostList","element");
			final HostList ret_val = new HostList(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < valueElements.size() - index - len; i++) {
				final TitanCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		public HostList replace(final int index, final int len, final HostList_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		public HostList replace(final int index, final TitanInteger len, final HostList_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		public HostList replace(final TitanInteger index, final int len, final HostList_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		public HostList replace(final TitanInteger index, final TitanInteger len, final HostList_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				valueElements.get(i).log();
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@IPL4asp_Types.HostList");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@IPL4asp_Types.HostList");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @IPL4asp_Types.HostList.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanCharString temp2 = new TitanCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class HostList_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanCharString_template> value_elements;

		//originally value_list/list_value
		protected List<HostList_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((HostList)value_ptr, value_index, (HostList_template)template_ptr, template_index, legacy);
			}
		};

		public HostList_template() {
			// do nothing
		}

		public HostList_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public HostList_template( final HostList otherValue ) {
			copy_value( otherValue );
		}

		public HostList_template( final HostList_template otherValue ) {
			copy_template( otherValue );
		}

		public HostList_template( final Optional<HostList> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.HostList from an unbound optional field.");
			}
		}

		public HostList_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanCharString_template>();
		}

		protected void copy_value(final HostList other_value) {
			other_value.must_bound("Initialization of a template of type @IPL4asp_Types.HostList with an unbound value.");
			value_elements = new ArrayList<TitanCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanCharString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final HostList_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanCharString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<HostList_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final HostList_template temp = new HostList_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.HostList.");
			}
			set_selection(other_value);
		}

		public boolean match(final HostList other_value) {
			return match(other_value, false);
		}

		public boolean match(final HostList other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < list_value.size(); i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @IPL4asp_Types.HostList.");
			}
		}

		private boolean match_index(final HostList value_ptr, final int value_index, final HostList_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof HostList) {
				return match((HostList)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type HostList.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < list_value.size(); i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public HostList_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public HostList_template operator_assign( final HostList otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public HostList_template operator_assign( final HostList_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public HostList_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof HostList) {
				return operator_assign((HostList)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type HostList.");
		}

		@Override
		public HostList_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof HostList_template) {
				return operator_assign((HostList_template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type HostList_template.");
		}

		public HostList_template operator_assign( final Optional<HostList> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.HostList.");
			}
			return this;
		}
		public HostList_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanCharString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public HostList replace(final int index, final int len, final HostList_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		public HostList replace(final TitanInteger index, final TitanInteger len, final HostList_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		public HostList replace(final int index, final int len, final HostList repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		public HostList replace(final TitanInteger index, final TitanInteger len, final HostList repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		public TitanCharString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @IPL4asp_Types.HostList using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @IPL4asp_Types.HostList.");
			}
			return value_elements.get(index_value);
		}

		public TitanCharString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @IPL4asp_Types.HostList.");

			return get_at(index_value.get_int());
		}

		public TitanCharString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @IPL4asp_Types.HostList using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @IPL4asp_Types.HostList.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @IPL4asp_Types.HostList: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		public TitanCharString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @IPL4asp_Types.HostList.");

			return constGet_at(index_value.get_int());
		}

		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @IPL4asp_Types.HostList.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanCharString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		public TitanInteger size_of() {
			return sizeOf(true);
		}

		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.HostList which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.HostList containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.HostList containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.HostList containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				for (int i = 1; i < list_value.size(); i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.HostList containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.HostList containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type HostList.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanCharString_template"));
		}

		public TitanInteger n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(value_elements.size());
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type HostList containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type HostList.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<HostList_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new HostList_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @IPL4asp_Types.HostList.");
			}
			set_selection(template_type);
		}

		@Override
		public HostList_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.HostList.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.HostList using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.HostList.");
			}
			return list_value.get(list_index);
		}

		public HostList_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @IPL4asp_Types.HostList.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.HostList using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @IPL4asp_Types.HostList.");
			}
			return list_value.get( list_index );
		}

		@Override
		public HostList valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.HostList.");
			}
			final HostList ret_val = new HostList(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).is_bound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueof() );
				}
			}
			return ret_val;
		}

		public HostList substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		public void log_match(final HostList match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof HostList) {
				log_match((HostList)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.HostList.");
		}

		public void log_match(final HostList match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(value_elements.size());
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(value_elements.size());
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.HostList.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @IPL4asp_Types.HostList.");
				}
				value_elements = new ArrayList<TitanCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanCharString_template temp2 = new TitanCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<HostList_template>(size);
				for (int i = 0; i < size; i++) {
					final HostList_template temp2 = new HostList_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @IPL4asp_Types.HostList.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@IPL4asp_Types.HostList");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE:
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				for (int i=0; i<value_elements.size(); i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@IPL4asp_Types.HostList" : name, false);
				}
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.HostList" : name));
		}
	}
	public static class SctpSendFailed extends Socket__API__Definitions.SctpSendFailed { }
	public static class SctpSendFailed_template extends Socket__API__Definitions.SctpSendFailed_template { }
	public static class ASP__ConnId__ReadyToRelease extends Base_Type {
		private final TitanInteger connId;

		public ASP__ConnId__ReadyToRelease() {
			this.connId = new TitanInteger();
		}

		public ASP__ConnId__ReadyToRelease(final TitanInteger connId ) {
			this.connId = new TitanInteger( connId );
		}

		public ASP__ConnId__ReadyToRelease( final ASP__ConnId__ReadyToRelease otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			connId = new TitanInteger();
			operator_assign( otherValue );
		}

		public ASP__ConnId__ReadyToRelease operator_assign(final ASP__ConnId__ReadyToRelease otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease");
			if (otherValue != this) {
				if ( otherValue.get_field_connId().is_bound() ) {
					this.connId.operator_assign( otherValue.get_field_connId() );
				} else {
					this.connId.clean_up();
				}
			}

			return this;
		}

		@Override
		public ASP__ConnId__ReadyToRelease operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof ASP__ConnId__ReadyToRelease ) {
				return operator_assign((ASP__ConnId__ReadyToRelease) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.ASP_ConnId_ReadyToRelease", otherValue));
		}

		@Override
		public void clean_up() {
			connId.clean_up();
		}

		@Override
		public boolean is_bound() {
			return connId.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return connId.is_value();
		}

		public boolean operator_equals( final ASP__ConnId__ReadyToRelease other_value) {
			return connId.operator_equals( other_value.connId );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof ASP__ConnId__ReadyToRelease ) {
				return operator_equals((ASP__ConnId__ReadyToRelease) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.ASP_ConnId_ReadyToRelease", other_value));
		}

		public TitanInteger get_field_connId() {
			return connId;
		}

		public TitanInteger constGet_field_connId() {
			return connId;
		}

		public TitanInteger size_of() {
			return new TitanInteger(1);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" connId := ");
			connId.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_connId().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("connId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_connId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.ASP_ConnId_ReadyToRelease: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.ASP_ConnId_ReadyToRelease");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (connId.is_bound()) {
				connId.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			connId.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			connId.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class ASP__ConnId__ReadyToRelease_template extends Base_Template {
		private TitanInteger_template connId;
		//originally value_list/list_value
		private List<ASP__ConnId__ReadyToRelease_template> list_value;


		public ASP__ConnId__ReadyToRelease_template() {
			// do nothing
		}

		public ASP__ConnId__ReadyToRelease_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public ASP__ConnId__ReadyToRelease_template( final ASP__ConnId__ReadyToRelease otherValue ) {
			copy_value(otherValue);
		}

		public ASP__ConnId__ReadyToRelease_template( final ASP__ConnId__ReadyToRelease_template otherValue ) {
			copy_template( otherValue );
		}

		public ASP__ConnId__ReadyToRelease_template( final Optional<ASP__ConnId__ReadyToRelease> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease from an unbound optional field.");
			}
		}

		@Override
		public ASP__ConnId__ReadyToRelease_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public ASP__ConnId__ReadyToRelease_template operator_assign( final ASP__ConnId__ReadyToRelease otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public ASP__ConnId__ReadyToRelease_template operator_assign( final ASP__ConnId__ReadyToRelease_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public ASP__ConnId__ReadyToRelease_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof ASP__ConnId__ReadyToRelease) {
				return operator_assign((ASP__ConnId__ReadyToRelease) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ASP__ConnId__ReadyToRelease' can not be cast to {1}", otherValue));
		}

		@Override
		public ASP__ConnId__ReadyToRelease_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof ASP__ConnId__ReadyToRelease_template) {
				return operator_assign((ASP__ConnId__ReadyToRelease_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ASP__ConnId__ReadyToRelease' can not be cast to {1}_template", otherValue));
		}

		public ASP__ConnId__ReadyToRelease_template operator_assign( final Optional<ASP__ConnId__ReadyToRelease> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
			return this;
		}

		private void copy_value(final ASP__ConnId__ReadyToRelease other_value) {
			if (other_value.get_field_connId().is_bound()) {
				get_field_connId().operator_assign(other_value.get_field_connId());
			} else {
				get_field_connId().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final ASP__ConnId__ReadyToRelease_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_connId().get_selection()) {
					get_field_connId().clean_up();
				} else {
					get_field_connId().operator_assign(other_value.get_field_connId());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ASP__ConnId__ReadyToRelease_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ASP__ConnId__ReadyToRelease_template temp = new ASP__ConnId__ReadyToRelease_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<ASP__ConnId__ReadyToRelease_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ASP__ConnId__ReadyToRelease_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return connId.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return connId.is_value();
		}
		public TitanInteger_template get_field_connId() {
			set_specific();
			return connId;
		}

		public TitanInteger_template constGet_field_connId() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field connId of a non-specific template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
			return connId;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					connId = new TitanInteger_template(template_sel.ANY_VALUE);
				} else {
					connId = new TitanInteger_template();
				}
			}
		}
		public boolean match(final ASP__ConnId__ReadyToRelease other_value) {
			return match(other_value, false);
		}

		public boolean match(final ASP__ConnId__ReadyToRelease other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_connId().is_bound()) {
					return false;
				}
				if(!connId.match(other_value.get_field_connId(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ASP__ConnId__ReadyToRelease) {
				return match((ASP__ConnId__ReadyToRelease)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ASP__ConnId__ReadyToRelease.");
		}


		@Override
		public ASP__ConnId__ReadyToRelease valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
			final ASP__ConnId__ReadyToRelease ret_val = new ASP__ConnId__ReadyToRelease();
			if (connId.is_bound()) {
				ret_val.get_field_connId().operator_assign(connId.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
		}

		@Override
		public ASP__ConnId__ReadyToRelease_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" connId := ");
				connId.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ASP__ConnId__ReadyToRelease match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ASP__ConnId__ReadyToRelease) {
				log_match((ASP__ConnId__ReadyToRelease)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
		}

		public void log_match(final ASP__ConnId__ReadyToRelease match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !connId.match(match_value.constGet_field_connId(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".connId");
							connId.log_match(match_value.constGet_field_connId(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ connId := ");
				connId.log_match(match_value.constGet_field_connId(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				connId.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				connId = new TitanInteger_template();
				connId.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<ASP__ConnId__ReadyToRelease_template>(size);
				for (int i = 0; i < size; i++) {
					final ASP__ConnId__ReadyToRelease_template temp = new ASP__ConnId__ReadyToRelease_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.ASP_ConnId_ReadyToRelease has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_connId().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("connId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_connId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.ASP_ConnId_ReadyToRelease: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.ASP_ConnId_ReadyToRelease");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.connId.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_ConnId_ReadyToRelease" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.ASP_ConnId_ReadyToRelease" : name));
		}
	}
	public static class SctpRemoteError extends Socket__API__Definitions.SctpRemoteError { }
	public static class SctpRemoteError_template extends Socket__API__Definitions.SctpRemoteError_template { }
	public static class SocketList extends Socket__API__Definitions.SocketList { }
	public static class SocketList_template extends Socket__API__Definitions.SocketList_template { }
	public static class Socket extends Socket__API__Definitions.Socket { }
	public static class Socket_template extends Socket__API__Definitions.Socket_template { }
	public static class OptionList extends Base_Type {

		protected List<Option> valueElements;

		public OptionList() {
			// do nothing
		}

		public OptionList( final OptionList otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @IPL4asp_Types.OptionList.");
			valueElements = copy_list( otherValue.valueElements );
		}


		public OptionList(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<Option>();
		}

		private static final List<Option> copy_list( final List<Option> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<Option> newList = new ArrayList<Option>( srcList.size() );
			for (final Option srcElem : srcList) {
				final Option newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			for (int i=0; i < valueElements.size(); i++) {
				final Option elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type otherValue) {
			if (otherValue instanceof OptionList) {
				return operator_equals((OptionList)otherValue);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type OptionList.");
		}

		public boolean operator_equals( final OptionList otherValue ) {
			must_bound("The left operand of comparison is an unbound value of type @IPL4asp_Types.OptionList.");
			otherValue.must_bound("The right operand of comparison is an unbound value of type @IPL4asp_Types.OptionList.");

			final int size = valueElements.size();
			if ( size != otherValue.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final Option leftElem = valueElements.get( i );
				final Option rightElem = otherValue.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public OptionList operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof OptionList) {
				return operator_assign((OptionList)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type OptionList.");
		}

		public OptionList operator_assign( final OptionList otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @IPL4asp_Types.OptionList." );

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		public OptionList operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<Option>();
			return this;
		}

		public OptionList operator_concatenate(final OptionList other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @IPL4asp_Types.OptionList concatenation.");
			}
			final OptionList ret_val = new OptionList(TitanNull_Type.NULL_VALUE);
			for (int i=0; i < valueElements.size(); i++) {
				final Option elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new Option(elem));
				}
			}
			for (int i = 0; i < other_value.valueElements.size(); i++) {
				final Option elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new Option(elem));
				}
			}
			return ret_val;
		}

		public OptionList operator_concatenate(final TitanNull_Type null_value) {
			return new OptionList(this);
		}

		public OptionList rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		public OptionList rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		public OptionList rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		public OptionList rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @IPL4asp_Types.OptionList.");
			final int size = valueElements.size();
			if (size == 0) {
				return new OptionList(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new OptionList(this);
			}
			final OptionList ret_val = new OptionList(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final Option elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new Option(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final Option elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new Option(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		public Option get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @IPL4asp_Types.OptionList using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			if ( valueElements.get( index_value ) == null ) {
				final Option newElem = get_unbound_elem();
				valueElements.set( index_value, newElem );
			}
			return valueElements.get( index_value );
		}

		public Option get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @IPL4asp_Types.OptionList." );
			return get_at( index_value.get_int() );
		}

		public Option constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @IPL4asp_Types.OptionList." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @IPL4asp_Types.OptionList using a negative index: "+index_value+".");
			}
			final int nofElements = n_elem().get_int();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @IPL4asp_Types.OptionList: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final Option elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		public Option constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @IPL4asp_Types.OptionList." );
			return constGet_at( index_value.get_int() );
		}

		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @IPL4asp_Types.OptionList.");
			return new TitanInteger(valueElements.size());
		}

		public TitanInteger n_elem() {
			return size_of();
		}

		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @IPL4asp_Types.OptionList.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final Option elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @IPL4asp_Types.OptionList.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<Option>(newSize);
			}
			if (newSize > valueElements.size()) {
				for ( int i = valueElements.size(); i < newSize; i++ ) {
					valueElements.add( new Option() );
				}
			} else if (newSize < valueElements.size()) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static Option get_unbound_elem() {
			return new Option();
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		public OptionList substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @IPL4asp_Types.OptionList.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@IPL4asp_Types.OptionList","element");
			final OptionList ret_val = new OptionList(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new Option(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		public OptionList replace(final int index, final int len, final OptionList repl) {
			must_bound("The first argument of replace() is an unbound value of type @IPL4asp_Types.OptionList.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @IPL4asp_Types.OptionList.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@IPL4asp_Types.OptionList","element");
			final OptionList ret_val = new OptionList(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final Option elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new Option(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final Option elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new Option(elem));
				}
			}
			for (int i = 0; i < valueElements.size() - index - len; i++) {
				final Option elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new Option(elem));
				}
			}
			return ret_val;
		}

		public OptionList replace(final int index, final int len, final OptionList_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		public OptionList replace(final int index, final TitanInteger len, final OptionList_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		public OptionList replace(final TitanInteger index, final int len, final OptionList_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		public OptionList replace(final TitanInteger index, final TitanInteger len, final OptionList_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				valueElements.get(i).log();
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@IPL4asp_Types.OptionList");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@IPL4asp_Types.OptionList");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @IPL4asp_Types.OptionList.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<Option>(temp);
			for (int i = 0; i < temp; i++) {
				final Option temp2 = new Option();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class OptionList_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<Option_template> value_elements;

		//originally value_list/list_value
		protected List<OptionList_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((OptionList)value_ptr, value_index, (OptionList_template)template_ptr, template_index, legacy);
			}
		};

		public OptionList_template() {
			// do nothing
		}

		public OptionList_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public OptionList_template( final OptionList otherValue ) {
			copy_value( otherValue );
		}

		public OptionList_template( final OptionList_template otherValue ) {
			copy_template( otherValue );
		}

		public OptionList_template( final Optional<OptionList> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.OptionList from an unbound optional field.");
			}
		}

		public OptionList_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<Option_template>();
		}

		protected void copy_value(final OptionList other_value) {
			other_value.must_bound("Initialization of a template of type @IPL4asp_Types.OptionList with an unbound value.");
			value_elements = new ArrayList<Option_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new Option_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new Option_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final OptionList_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<Option_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new Option_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new Option_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<OptionList_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final OptionList_template temp = new OptionList_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.OptionList.");
			}
			set_selection(other_value);
		}

		public boolean match(final OptionList other_value) {
			return match(other_value, false);
		}

		public boolean match(final OptionList other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < list_value.size(); i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @IPL4asp_Types.OptionList.");
			}
		}

		private boolean match_index(final OptionList value_ptr, final int value_index, final OptionList_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof OptionList) {
				return match((OptionList)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type OptionList.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < list_value.size(); i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public OptionList_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public OptionList_template operator_assign( final OptionList otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public OptionList_template operator_assign( final OptionList_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public OptionList_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof OptionList) {
				return operator_assign((OptionList)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type OptionList.");
		}

		@Override
		public OptionList_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof OptionList_template) {
				return operator_assign((OptionList_template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type OptionList_template.");
		}

		public OptionList_template operator_assign( final Optional<OptionList> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.OptionList.");
			}
			return this;
		}
		public OptionList_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<Option_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public OptionList replace(final int index, final int len, final OptionList_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		public OptionList replace(final TitanInteger index, final TitanInteger len, final OptionList_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		public OptionList replace(final int index, final int len, final OptionList repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		public OptionList replace(final TitanInteger index, final TitanInteger len, final OptionList repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		public Option_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @IPL4asp_Types.OptionList using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @IPL4asp_Types.OptionList.");
			}
			return value_elements.get(index_value);
		}

		public Option_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @IPL4asp_Types.OptionList.");

			return get_at(index_value.get_int());
		}

		public Option_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @IPL4asp_Types.OptionList using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @IPL4asp_Types.OptionList.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @IPL4asp_Types.OptionList: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		public Option_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @IPL4asp_Types.OptionList.");

			return constGet_at(index_value.get_int());
		}

		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @IPL4asp_Types.OptionList.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<Option_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new Option_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new Option_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		public TitanInteger size_of() {
			return sizeOf(true);
		}

		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.OptionList which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.OptionList containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.OptionList containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.OptionList containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				for (int i = 1; i < list_value.size(); i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.OptionList containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @IPL4asp_Types.OptionList containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type OptionList.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "Option_template"));
		}

		public TitanInteger n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(value_elements.size());
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type OptionList containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type OptionList.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<OptionList_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new OptionList_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @IPL4asp_Types.OptionList.");
			}
			set_selection(template_type);
		}

		@Override
		public OptionList_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.OptionList.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.OptionList using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.OptionList.");
			}
			return list_value.get(list_index);
		}

		public OptionList_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @IPL4asp_Types.OptionList.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.OptionList using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @IPL4asp_Types.OptionList.");
			}
			return list_value.get( list_index );
		}

		@Override
		public OptionList valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.OptionList.");
			}
			final OptionList ret_val = new OptionList(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).is_bound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueof() );
				}
			}
			return ret_val;
		}

		public OptionList substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		public void log_match(final OptionList match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof OptionList) {
				log_match((OptionList)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.OptionList.");
		}

		public void log_match(final OptionList match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(value_elements.size());
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(value_elements.size());
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.OptionList.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @IPL4asp_Types.OptionList.");
				}
				value_elements = new ArrayList<Option_template>(temp);
				for (int i = 0; i < temp; i++) {
					final Option_template temp2 = new Option_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<OptionList_template>(size);
				for (int i = 0; i < size; i++) {
					final OptionList_template temp2 = new OptionList_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @IPL4asp_Types.OptionList.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@IPL4asp_Types.OptionList");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE:
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				for (int i=0; i<value_elements.size(); i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@IPL4asp_Types.OptionList" : name, false);
				}
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.OptionList" : name));
		}
	}
	public static class ConnectionClosedEvent extends Socket__API__Definitions.ConnectionOpenedEvent { }
	public static class ConnectionClosedEvent_template extends Socket__API__Definitions.ConnectionOpenedEvent_template { }
	public static class IPL4__Param extends Base_Type {
		public enum enum_type {
			IPL4__LOCALADDRESS (0),
			IPL4__REMOTEADDRESS (1),
			IPL4__PROTO (2),
			IPL4__USERDATA (3),
			IPL4__PARENTIDX (4),
			UNKNOWN_VALUE(5),
			UNBOUND_VALUE(6);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return IPL4__LOCALADDRESS;
				case 1:  return IPL4__REMOTEADDRESS;
				case 2:  return IPL4__PROTO;
				case 3:  return IPL4__USERDATA;
				case 4:  return IPL4__PARENTIDX;
				case 5:  return UNKNOWN_VALUE;
				case 6:  return UNBOUND_VALUE;

				default:
					return null;
				}
			}

			}

		public enum_type enum_value;
		//===Constructors===;
		public IPL4__Param() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public IPL4__Param(final IPL4__Param otherValue) {
			enum_value = otherValue.enum_value;
		}

		public IPL4__Param(final IPL4__Param.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public IPL4__Param(final int otherValue) {
			if (!is_valid_enum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `IPL4__Param' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		public IPL4__Param operator_assign(final IPL4__Param otherValue){
			otherValue.must_bound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public IPL4__Param operator_assign(final Base_Type otherValue){
			if( otherValue instanceof IPL4__Param ) {
				return operator_assign((IPL4__Param) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `IPL4__Param' can not be cast to {1}", otherValue));
		}

		public IPL4__Param operator_assign(final IPL4__Param.enum_type otherValue){
			return operator_assign( new IPL4__Param(otherValue) );
		}

		public IPL4__Param operator_assign(final int otherValue){
			if (!is_valid_enum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `IPL4__Param'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		public boolean operator_equals(final IPL4__Param otherValue){
			return enum_value == otherValue.enum_value;
		}

		public boolean operator_equals(final Base_Type otherValue){
			if (otherValue instanceof IPL4__Param) {
				return operator_equals( (IPL4__Param) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.IPL4_Param.");
			}
		}

		public boolean operator_equals(final IPL4__Param.enum_type otherValue){
			return enum_value == otherValue;
		}

		public boolean operator_not_equals(final IPL4__Param otherValue){
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals(final Base_Type otherValue){
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals(final IPL4__Param.enum_type otherValue){
			return !operator_equals(otherValue);
		}

		public boolean is_less_than(final IPL4__Param.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			return enum_value.enum_num < otherValue.enum_num;
		}

		public boolean is_less_than(final IPL4__Param otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		public boolean is_less_than_or_equal(final IPL4__Param.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			return enum_value.enum_num <= otherValue.enum_num;
		}

		public boolean is_less_than_or_equal(final IPL4__Param otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			return enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		public boolean is_greater_than(final IPL4__Param.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			return enum_value.enum_num > otherValue.enum_num;
		}

		public boolean is_greater_than(final IPL4__Param otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			return enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		public boolean is_greater_than_or_equal(final IPL4__Param.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			return enum_value.enum_num >= otherValue.enum_num;
		}

		public boolean is_greater_than_or_equal(final IPL4__Param otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type IPL4__Param. ");
			return enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		@Override
		public boolean is_value() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		@Override
		public void clean_up() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean is_valid_enum(final int other_value) {
			final enum_type helper =  enum_type.getValue(other_value);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean is_valid_enum(final enum_type other_value) {
			return other_value != enum_type.UNKNOWN_VALUE && other_value != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!is_valid_enum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!is_valid_enum(intValue.get_int())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.get_int()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.get_int());
		}

		public static int enum2int(final IPL4__Param.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final IPL4__Param enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("IPL4__LOCALADDRESS".equals(strPar) || "IPL4_LOCALADDRESS".equals(strPar)) {
				return enum_type.IPL4__LOCALADDRESS;
			}
			if ("IPL4__REMOTEADDRESS".equals(strPar) || "IPL4_REMOTEADDRESS".equals(strPar)) {
				return enum_type.IPL4__REMOTEADDRESS;
			}
			if ("IPL4__PROTO".equals(strPar) || "IPL4_PROTO".equals(strPar)) {
				return enum_type.IPL4__PROTO;
			}
			if ("IPL4__USERDATA".equals(strPar) || "IPL4_USERDATA".equals(strPar)) {
				return enum_type.IPL4__USERDATA;
			}
			if ("IPL4__PARENTIDX".equals(strPar) || "IPL4_PARENTIDX".equals(strPar)) {
				return enum_type.IPL4__PARENTIDX;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum_to_str(final enum_type enumPar) {
			return enumPar.name();
		}

		public int as_int() {
			return enum2int(enum_value);
		}

		public void from_int(final int intValue) {
			enum_value = enum_type.getValue(intValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		@Override
		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum_to_str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@IPL4asp_Types.IPL4_Param");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!is_valid_enum(enum_value)) {
				param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_Param.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().get_int();
			if (!is_valid_enum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @IPL4asp_Types.IPL4_Param.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class IPL4__Param_template extends Base_Template {
		// single_value
		private IPL4__Param.enum_type single_value;
		// value_list part
		private ArrayList<IPL4__Param_template> value_list;

		private void copy_value(final IPL4__Param other_value) {
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = other_value.enum_value;
		}

		private void copy_template(final IPL4__Param_template otherValue) {
			set_selection(otherValue);
			switch (otherValue.template_selection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<IPL4__Param_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final IPL4__Param_template temp = new IPL4__Param_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_Param.");
			}
		}

		public IPL4__Param_template() {
			// do nothing
		}

		public IPL4__Param_template(final template_sel otherValue) {
			super(otherValue);
			check_single_selection(otherValue);
		}

		public IPL4__Param_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!IPL4__Param.is_valid_enum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type @IPL4asp_Types.IPL4_Param with unknown numeric value "+ otherValue +".");
			}
			single_value = IPL4__Param.enum_type.getValue(otherValue);
		}

		public IPL4__Param_template(final IPL4__Param otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			otherValue.must_bound("Creating a template from an unbound value of enumerated type @IPL4asp_Types.IPL4_Param. ");
			single_value = otherValue.enum_value;
		}

		public IPL4__Param_template( final Optional<IPL4__Param> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.IPL4_Param from an unbound optional field.");
			}
		}

		public IPL4__Param_template(final IPL4__Param_template otherValue) {
			copy_template(otherValue);
		}

		public IPL4__Param_template(final IPL4__Param.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		@Override
		public void clean_up() {
			if (template_selection == template_sel.VALUE_LIST || template_selection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		@Override
		public boolean is_bound() {
			return template_selection != template_sel.UNINITIALIZED_TEMPLATE || is_ifPresent;
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != IPL4__Param.enum_type.UNBOUND_VALUE;
		}

		@Override
		public IPL4__Param_template operator_assign(final template_sel otherValue) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public IPL4__Param_template operator_assign(final int otherValue) {
			if (!IPL4__Param.is_valid_enum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type @IPL4asp_Types.IPL4_Param.");
			}
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		public IPL4__Param_template operator_assign(final IPL4__Param.enum_type otherValue){
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		public IPL4__Param_template operator_assign(final IPL4__Param_template otherValue){
			// otherValue.must_bound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public IPL4__Param_template operator_assign(final IPL4__Param otherValue){
			otherValue.must_bound("Assignment of an unbound value of enumerated type @IPL4asp_Types.IPL4_Param to a template. ");
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public IPL4__Param_template operator_assign(final Base_Type otherValue){
			if( otherValue instanceof IPL4__Param ) {
				return operator_assign((IPL4__Param) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.IPL4_Param' can not be cast to {1}", otherValue));
		}

		@Override
		public IPL4__Param_template operator_assign(final Base_Template otherValue){
			if( otherValue instanceof IPL4__Param_template ) {
				return operator_assign((IPL4__Param_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.IPL4_Param'_template can not be cast to {1}", otherValue));
		}

		public boolean match(final IPL4__Param.enum_type otherValue) {
			return match(otherValue, false);
		}

		public boolean match(final IPL4__Param.enum_type otherValue, final boolean legacy) {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_Param.");
			}
		}

		public boolean match(final IPL4__Param otherValue) {
			return match(otherValue.enum_value, false);
		}

		public boolean match(final IPL4__Param otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof IPL4__Param ) {
				return match((IPL4__Param) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.IPL4_Param' can not be cast to {1}", otherValue));
		}

		@Override
		public IPL4__Param valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type @IPL4asp_Types.IPL4_Param.");
			}
			return new IPL4__Param(single_value);
		}

		@Override
		public void set_type(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type @IPL4asp_Types.IPL4_Param.");
			}
			clean_up();
			set_selection(templateType);
			value_list = new ArrayList<IPL4__Param_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new IPL4__Param_template());
			}
		}

		@Override
		public IPL4__Param_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type @IPL4asp_Types.IPL4_Param.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type IPL4__Param using a negative index ({0}).", list_index));
			} else if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type @IPL4asp_Types.IPL4_Param.");
			}
			return value_list.get(list_index);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(IPL4__Param.enum_to_str(single_value), IPL4__Param.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof IPL4__Param) {
				log_match((IPL4__Param)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.IPL4_Param.");
		}

		public void log_match(final IPL4__Param match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final IPL4__Param.enum_type enum_value = IPL4__Param.str_to_enum(param.get_enumerated());
				if (!IPL4__Param.is_valid_enum(enum_value)) {
					param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_Param.");
				}
				operator_assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@IPL4asp_Types.IPL4_Param");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_Param.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().get_int();
				if (!IPL4__Param.is_valid_enum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @IPL4asp_Types.IPL4_Param.", temp));
				}
				single_value = IPL4__Param.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				value_list = new ArrayList<IPL4__Param_template>(size);
				for (int i = 0; i < size; i++) {
					final IPL4__Param_template temp = new IPL4__Param_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @IPL4asp_Types.IPL4_Param.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && template_selection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (template_selection == template_sel.OMIT_VALUE || template_selection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.IPL4_Param" : name));
		}
	}
	public static class UDP__ENCAP__Param extends Base_Type {
		public enum enum_type {
			UDP__ENCAP__ESPINUDP__NON__IKE (1),
			UDP__ENCAP__ESPINUDP (2),
			UDP__ENCAP__L2TPINUDP (3),
			UNKNOWN_VALUE(0),
			UNBOUND_VALUE(4);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 1:  return UDP__ENCAP__ESPINUDP__NON__IKE;
				case 2:  return UDP__ENCAP__ESPINUDP;
				case 3:  return UDP__ENCAP__L2TPINUDP;
				case 0:  return UNKNOWN_VALUE;
				case 4:  return UNBOUND_VALUE;

				default:
					return null;
				}
			}

			}

		public enum_type enum_value;
		//===Constructors===;
		public UDP__ENCAP__Param() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public UDP__ENCAP__Param(final UDP__ENCAP__Param otherValue) {
			enum_value = otherValue.enum_value;
		}

		public UDP__ENCAP__Param(final UDP__ENCAP__Param.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public UDP__ENCAP__Param(final int otherValue) {
			if (!is_valid_enum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `UDP__ENCAP__Param' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		public UDP__ENCAP__Param operator_assign(final UDP__ENCAP__Param otherValue){
			otherValue.must_bound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public UDP__ENCAP__Param operator_assign(final Base_Type otherValue){
			if( otherValue instanceof UDP__ENCAP__Param ) {
				return operator_assign((UDP__ENCAP__Param) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `UDP__ENCAP__Param' can not be cast to {1}", otherValue));
		}

		public UDP__ENCAP__Param operator_assign(final UDP__ENCAP__Param.enum_type otherValue){
			return operator_assign( new UDP__ENCAP__Param(otherValue) );
		}

		public UDP__ENCAP__Param operator_assign(final int otherValue){
			if (!is_valid_enum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `UDP__ENCAP__Param'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		public boolean operator_equals(final UDP__ENCAP__Param otherValue){
			return enum_value == otherValue.enum_value;
		}

		public boolean operator_equals(final Base_Type otherValue){
			if (otherValue instanceof UDP__ENCAP__Param) {
				return operator_equals( (UDP__ENCAP__Param) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.UDP_ENCAP_Param.");
			}
		}

		public boolean operator_equals(final UDP__ENCAP__Param.enum_type otherValue){
			return enum_value == otherValue;
		}

		public boolean operator_not_equals(final UDP__ENCAP__Param otherValue){
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals(final Base_Type otherValue){
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals(final UDP__ENCAP__Param.enum_type otherValue){
			return !operator_equals(otherValue);
		}

		public boolean is_less_than(final UDP__ENCAP__Param.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			return enum_value.enum_num < otherValue.enum_num;
		}

		public boolean is_less_than(final UDP__ENCAP__Param otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		public boolean is_less_than_or_equal(final UDP__ENCAP__Param.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			return enum_value.enum_num <= otherValue.enum_num;
		}

		public boolean is_less_than_or_equal(final UDP__ENCAP__Param otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			return enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		public boolean is_greater_than(final UDP__ENCAP__Param.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			return enum_value.enum_num > otherValue.enum_num;
		}

		public boolean is_greater_than(final UDP__ENCAP__Param otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			return enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		public boolean is_greater_than_or_equal(final UDP__ENCAP__Param.enum_type otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			return enum_value.enum_num >= otherValue.enum_num;
		}

		public boolean is_greater_than_or_equal(final UDP__ENCAP__Param otherValue){
			must_bound("The left operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			otherValue.must_bound("The right operand of comparison is an unbound value of enumerated type UDP__ENCAP__Param. ");
			return enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		@Override
		public boolean is_value() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		@Override
		public void clean_up() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean is_valid_enum(final int other_value) {
			final enum_type helper =  enum_type.getValue(other_value);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean is_valid_enum(final enum_type other_value) {
			return other_value != enum_type.UNKNOWN_VALUE && other_value != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!is_valid_enum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!is_valid_enum(intValue.get_int())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.get_int()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.get_int());
		}

		public static int enum2int(final UDP__ENCAP__Param.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final UDP__ENCAP__Param enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("UDP__ENCAP__ESPINUDP__NON__IKE".equals(strPar) || "UDP_ENCAP_ESPINUDP_NON_IKE".equals(strPar)) {
				return enum_type.UDP__ENCAP__ESPINUDP__NON__IKE;
			}
			if ("UDP__ENCAP__ESPINUDP".equals(strPar) || "UDP_ENCAP_ESPINUDP".equals(strPar)) {
				return enum_type.UDP__ENCAP__ESPINUDP;
			}
			if ("UDP__ENCAP__L2TPINUDP".equals(strPar) || "UDP_ENCAP_L2TPINUDP".equals(strPar)) {
				return enum_type.UDP__ENCAP__L2TPINUDP;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum_to_str(final enum_type enumPar) {
			return enumPar.name();
		}

		public int as_int() {
			return enum2int(enum_value);
		}

		public void from_int(final int intValue) {
			enum_value = enum_type.getValue(intValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		@Override
		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum_to_str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@IPL4asp_Types.UDP_ENCAP_Param");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!is_valid_enum(enum_value)) {
				param.error("Invalid enumerated value for type @IPL4asp_Types.UDP_ENCAP_Param.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of enumerated type @IPL4asp_Types.UDP_ENCAP_Param.");
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().get_int();
			if (!is_valid_enum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @IPL4asp_Types.UDP_ENCAP_Param.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class UDP__ENCAP__Param_template extends Base_Template {
		// single_value
		private UDP__ENCAP__Param.enum_type single_value;
		// value_list part
		private ArrayList<UDP__ENCAP__Param_template> value_list;

		private void copy_value(final UDP__ENCAP__Param other_value) {
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = other_value.enum_value;
		}

		private void copy_template(final UDP__ENCAP__Param_template otherValue) {
			set_selection(otherValue);
			switch (otherValue.template_selection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<UDP__ENCAP__Param_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final UDP__ENCAP__Param_template temp = new UDP__ENCAP__Param_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type @IPL4asp_Types.UDP_ENCAP_Param.");
			}
		}

		public UDP__ENCAP__Param_template() {
			// do nothing
		}

		public UDP__ENCAP__Param_template(final template_sel otherValue) {
			super(otherValue);
			check_single_selection(otherValue);
		}

		public UDP__ENCAP__Param_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!UDP__ENCAP__Param.is_valid_enum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type @IPL4asp_Types.UDP_ENCAP_Param with unknown numeric value "+ otherValue +".");
			}
			single_value = UDP__ENCAP__Param.enum_type.getValue(otherValue);
		}

		public UDP__ENCAP__Param_template(final UDP__ENCAP__Param otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			otherValue.must_bound("Creating a template from an unbound value of enumerated type @IPL4asp_Types.UDP_ENCAP_Param. ");
			single_value = otherValue.enum_value;
		}

		public UDP__ENCAP__Param_template( final Optional<UDP__ENCAP__Param> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.UDP_ENCAP_Param from an unbound optional field.");
			}
		}

		public UDP__ENCAP__Param_template(final UDP__ENCAP__Param_template otherValue) {
			copy_template(otherValue);
		}

		public UDP__ENCAP__Param_template(final UDP__ENCAP__Param.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		@Override
		public void clean_up() {
			if (template_selection == template_sel.VALUE_LIST || template_selection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		@Override
		public boolean is_bound() {
			return template_selection != template_sel.UNINITIALIZED_TEMPLATE || is_ifPresent;
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != UDP__ENCAP__Param.enum_type.UNBOUND_VALUE;
		}

		@Override
		public UDP__ENCAP__Param_template operator_assign(final template_sel otherValue) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public UDP__ENCAP__Param_template operator_assign(final int otherValue) {
			if (!UDP__ENCAP__Param.is_valid_enum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type @IPL4asp_Types.UDP_ENCAP_Param.");
			}
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		public UDP__ENCAP__Param_template operator_assign(final UDP__ENCAP__Param.enum_type otherValue){
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		public UDP__ENCAP__Param_template operator_assign(final UDP__ENCAP__Param_template otherValue){
			// otherValue.must_bound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public UDP__ENCAP__Param_template operator_assign(final UDP__ENCAP__Param otherValue){
			otherValue.must_bound("Assignment of an unbound value of enumerated type @IPL4asp_Types.UDP_ENCAP_Param to a template. ");
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public UDP__ENCAP__Param_template operator_assign(final Base_Type otherValue){
			if( otherValue instanceof UDP__ENCAP__Param ) {
				return operator_assign((UDP__ENCAP__Param) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.UDP_ENCAP_Param' can not be cast to {1}", otherValue));
		}

		@Override
		public UDP__ENCAP__Param_template operator_assign(final Base_Template otherValue){
			if( otherValue instanceof UDP__ENCAP__Param_template ) {
				return operator_assign((UDP__ENCAP__Param_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.UDP_ENCAP_Param'_template can not be cast to {1}", otherValue));
		}

		public boolean match(final UDP__ENCAP__Param.enum_type otherValue) {
			return match(otherValue, false);
		}

		public boolean match(final UDP__ENCAP__Param.enum_type otherValue, final boolean legacy) {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type @IPL4asp_Types.UDP_ENCAP_Param.");
			}
		}

		public boolean match(final UDP__ENCAP__Param otherValue) {
			return match(otherValue.enum_value, false);
		}

		public boolean match(final UDP__ENCAP__Param otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof UDP__ENCAP__Param ) {
				return match((UDP__ENCAP__Param) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `@IPL4asp_Types.UDP_ENCAP_Param' can not be cast to {1}", otherValue));
		}

		@Override
		public UDP__ENCAP__Param valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type @IPL4asp_Types.UDP_ENCAP_Param.");
			}
			return new UDP__ENCAP__Param(single_value);
		}

		@Override
		public void set_type(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type @IPL4asp_Types.UDP_ENCAP_Param.");
			}
			clean_up();
			set_selection(templateType);
			value_list = new ArrayList<UDP__ENCAP__Param_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new UDP__ENCAP__Param_template());
			}
		}

		@Override
		public UDP__ENCAP__Param_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type @IPL4asp_Types.UDP_ENCAP_Param.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type UDP__ENCAP__Param using a negative index ({0}).", list_index));
			} else if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type @IPL4asp_Types.UDP_ENCAP_Param.");
			}
			return value_list.get(list_index);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(UDP__ENCAP__Param.enum_to_str(single_value), UDP__ENCAP__Param.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof UDP__ENCAP__Param) {
				log_match((UDP__ENCAP__Param)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.UDP_ENCAP_Param.");
		}

		public void log_match(final UDP__ENCAP__Param match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final UDP__ENCAP__Param.enum_type enum_value = UDP__ENCAP__Param.str_to_enum(param.get_enumerated());
				if (!UDP__ENCAP__Param.is_valid_enum(enum_value)) {
					param.error("Invalid enumerated value for type @IPL4asp_Types.UDP_ENCAP_Param.");
				}
				operator_assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@IPL4asp_Types.UDP_ENCAP_Param");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @IPL4asp_Types.UDP_ENCAP_Param.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().get_int();
				if (!UDP__ENCAP__Param.is_valid_enum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @IPL4asp_Types.UDP_ENCAP_Param.", temp));
				}
				single_value = UDP__ENCAP__Param.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				value_list = new ArrayList<UDP__ENCAP__Param_template>(size);
				for (int i = 0; i < size; i++) {
					final UDP__ENCAP__Param_template temp = new UDP__ENCAP__Param_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @IPL4asp_Types.UDP_ENCAP_Param.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && template_selection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (template_selection == template_sel.OMIT_VALUE || template_selection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.UDP_ENCAP_Param" : name));
		}
	}
	public static class Result extends Socket__API__Definitions.Result { }
	public static class Result_template extends Socket__API__Definitions.Result_template { }
	public static class PortError extends Socket__API__Definitions.PortError { }
	public static class PortError_template extends Socket__API__Definitions.PortError_template { }
	public static class ro__integer extends Socket__API__Definitions.ro__integer { }
	public static class ro__integer_template extends Socket__API__Definitions.ro__integer_template { }
	public static class HostName extends TitanCharString { }
	public static class HostName_template extends TitanCharString_template { }
	public static class SctpPartialDeliveryEvent extends Socket__API__Definitions.SctpPartialDeliveryEvent { }
	public static class SctpPartialDeliveryEvent_template extends Socket__API__Definitions.SctpPartialDeliveryEvent_template { }
	public static class SslTuple extends Socket__API__Definitions.SslTuple { }
	public static class SslTuple_template extends Socket__API__Definitions.SslTuple_template { }
	public static class SctpTuple extends Socket__API__Definitions.SctpTuple { }
	public static class SctpTuple_template extends Socket__API__Definitions.SctpTuple_template { }
	public static class UnspecifiedTuple extends Socket__API__Definitions.UnspecifiedTuple { }
	public static class UnspecifiedTuple_template extends Socket__API__Definitions.UnspecifiedTuple_template { }
	public static class SctpAdaptationIndication extends Socket__API__Definitions.SctpAdaptationIndication { }
	public static class SctpAdaptationIndication_template extends Socket__API__Definitions.SctpAdaptationIndication_template { }
	public static class ASP__Send extends Base_Type {
		private final TitanInteger connId;
		private final Optional<Socket__API__Definitions.ProtoTuple> proto;
		private final TitanOctetString msg;

		public ASP__Send() {
			this.connId = new TitanInteger();
			this.proto = new Optional<Socket__API__Definitions.ProtoTuple>(Socket__API__Definitions.ProtoTuple.class);
			this.msg = new TitanOctetString();
		}

		public ASP__Send(final TitanInteger connId, final Optional<Socket__API__Definitions.ProtoTuple> proto, final TitanOctetString msg ) {
			this.connId = new TitanInteger( connId );
			this.proto = new Optional<Socket__API__Definitions.ProtoTuple>(Socket__API__Definitions.ProtoTuple.class);
			this.proto.operator_assign( proto );
			this.msg = new TitanOctetString( msg );
		}

		public ASP__Send( final ASP__Send otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.ASP_Send.");
			connId = new TitanInteger();
			proto = new Optional<Socket__API__Definitions.ProtoTuple>(Socket__API__Definitions.ProtoTuple.class);
			msg = new TitanOctetString();
			operator_assign( otherValue );
		}

		public ASP__Send operator_assign(final ASP__Send otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.ASP_Send");
			if (otherValue != this) {
				if ( otherValue.get_field_connId().is_bound() ) {
					this.connId.operator_assign( otherValue.get_field_connId() );
				} else {
					this.connId.clean_up();
				}
				if ( otherValue.get_field_proto().is_bound() ) {
					this.proto.operator_assign( otherValue.get_field_proto() );
				} else {
					this.proto.clean_up();
				}
				if ( otherValue.get_field_msg().is_bound() ) {
					this.msg.operator_assign( otherValue.get_field_msg() );
				} else {
					this.msg.clean_up();
				}
			}

			return this;
		}

		@Override
		public ASP__Send operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof ASP__Send ) {
				return operator_assign((ASP__Send) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.ASP_Send", otherValue));
		}

		@Override
		public void clean_up() {
			connId.clean_up();
			proto.clean_up();
			msg.clean_up();
		}

		@Override
		public boolean is_bound() {
			return connId.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(proto.get_selection()) || proto.is_bound()
					|| msg.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return connId.is_value()
					&& (optional_sel.OPTIONAL_OMIT.equals(proto.get_selection()) || proto.is_value())
					&& msg.is_value();
		}

		public boolean operator_equals( final ASP__Send other_value) {
			return connId.operator_equals( other_value.connId )
					&& proto.operator_equals( other_value.proto )
					&& msg.operator_equals( other_value.msg );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof ASP__Send ) {
				return operator_equals((ASP__Send) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.ASP_Send", other_value));
		}

		public TitanInteger get_field_connId() {
			return connId;
		}

		public TitanInteger constGet_field_connId() {
			return connId;
		}

		public Optional<Socket__API__Definitions.ProtoTuple> get_field_proto() {
			return proto;
		}

		public Optional<Socket__API__Definitions.ProtoTuple> constGet_field_proto() {
			return proto;
		}

		public TitanOctetString get_field_msg() {
			return msg;
		}

		public TitanOctetString constGet_field_msg() {
			return msg;
		}

		public TitanInteger size_of() {
			int sizeof = 2;
			if (proto.ispresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" connId := ");
			connId.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" proto := ");
			proto.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msg := ");
			msg.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.ASP_Send has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_connId().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_proto().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_msg().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("connId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_connId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("proto".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_proto().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msg".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_msg().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.ASP_Send: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.ASP_Send");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (connId.is_bound()) {
				connId.set_implicit_omit();
			}
			if (proto.is_bound()) {
				proto.set_implicit_omit();
			} else {
				proto.operator_assign(template_sel.OMIT_VALUE);
			}
			if (msg.is_bound()) {
				msg.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			connId.encode_text(text_buf);
			proto.encode_text(text_buf);
			msg.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			connId.decode_text(text_buf);
			proto.decode_text(text_buf);
			msg.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class ASP__Send_template extends Base_Template {
		private TitanInteger_template connId;
		private Socket__API__Definitions.ProtoTuple_template proto;
		private TitanOctetString_template msg;
		//originally value_list/list_value
		private List<ASP__Send_template> list_value;


		public ASP__Send_template() {
			// do nothing
		}

		public ASP__Send_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public ASP__Send_template( final ASP__Send otherValue ) {
			copy_value(otherValue);
		}

		public ASP__Send_template( final ASP__Send_template otherValue ) {
			copy_template( otherValue );
		}

		public ASP__Send_template( final Optional<ASP__Send> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.ASP_Send from an unbound optional field.");
			}
		}

		@Override
		public ASP__Send_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public ASP__Send_template operator_assign( final ASP__Send otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public ASP__Send_template operator_assign( final ASP__Send_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public ASP__Send_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof ASP__Send) {
				return operator_assign((ASP__Send) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ASP__Send' can not be cast to {1}", otherValue));
		}

		@Override
		public ASP__Send_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof ASP__Send_template) {
				return operator_assign((ASP__Send_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ASP__Send' can not be cast to {1}_template", otherValue));
		}

		public ASP__Send_template operator_assign( final Optional<ASP__Send> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.ASP_Send.");
			}
			return this;
		}

		private void copy_value(final ASP__Send other_value) {
			if (other_value.get_field_connId().is_bound()) {
				get_field_connId().operator_assign(other_value.get_field_connId());
			} else {
				get_field_connId().clean_up();
			}
			if (other_value.get_field_proto().is_bound()) {
				if (other_value.get_field_proto().ispresent()) {
					get_field_proto().operator_assign(other_value.get_field_proto().get());
				} else {
					get_field_proto().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_proto().clean_up();
			}
			if (other_value.get_field_msg().is_bound()) {
				get_field_msg().operator_assign(other_value.get_field_msg());
			} else {
				get_field_msg().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final ASP__Send_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_connId().get_selection()) {
					get_field_connId().clean_up();
				} else {
					get_field_connId().operator_assign(other_value.get_field_connId());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_proto().get_selection()) {
					get_field_proto().clean_up();
				} else {
					get_field_proto().operator_assign(other_value.get_field_proto());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_msg().get_selection()) {
					get_field_msg().clean_up();
				} else {
					get_field_msg().operator_assign(other_value.get_field_msg());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ASP__Send_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ASP__Send_template temp = new ASP__Send_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.ASP_Send.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.ASP_Send.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<ASP__Send_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ASP__Send_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return connId.is_bound()
					|| proto.is_omit() || proto.is_bound()
					|| msg.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return connId.is_value()
					&& (proto.is_omit() || proto.is_value())
					&& msg.is_value();
		}
		public TitanInteger_template get_field_connId() {
			set_specific();
			return connId;
		}

		public TitanInteger_template constGet_field_connId() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field connId of a non-specific template of type @IPL4asp_Types.ASP_Send.");
			}
			return connId;
		}

		public Socket__API__Definitions.ProtoTuple_template get_field_proto() {
			set_specific();
			return proto;
		}

		public Socket__API__Definitions.ProtoTuple_template constGet_field_proto() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field proto of a non-specific template of type @IPL4asp_Types.ASP_Send.");
			}
			return proto;
		}

		public TitanOctetString_template get_field_msg() {
			set_specific();
			return msg;
		}

		public TitanOctetString_template constGet_field_msg() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field msg of a non-specific template of type @IPL4asp_Types.ASP_Send.");
			}
			return msg;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					connId = new TitanInteger_template(template_sel.ANY_VALUE);
					proto = new Socket__API__Definitions.ProtoTuple_template(template_sel.ANY_OR_OMIT);
					msg = new TitanOctetString_template(template_sel.ANY_VALUE);
				} else {
					connId = new TitanInteger_template();
					proto = new Socket__API__Definitions.ProtoTuple_template();
					msg = new TitanOctetString_template();
				}
			}
		}
		public boolean match(final ASP__Send other_value) {
			return match(other_value, false);
		}

		public boolean match(final ASP__Send other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_connId().is_bound()) {
					return false;
				}
				if(!connId.match(other_value.get_field_connId(), legacy)) {
					return false;
				}
				if(!other_value.get_field_proto().is_bound()) {
					return false;
				}
				if((other_value.get_field_proto().ispresent() ? !proto.match(other_value.get_field_proto().get(), legacy) : !proto.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_msg().is_bound()) {
					return false;
				}
				if(!msg.match(other_value.get_field_msg(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.ASP_Send.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ASP__Send) {
				return match((ASP__Send)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ASP__Send.");
		}


		@Override
		public ASP__Send valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.ASP_Send.");
			}
			final ASP__Send ret_val = new ASP__Send();
			if (connId.is_bound()) {
				ret_val.get_field_connId().operator_assign(connId.valueof());
			}
			if (proto.is_omit()) {
				ret_val.get_field_proto().operator_assign(template_sel.OMIT_VALUE);
			} else if (proto.is_bound()) {
				ret_val.get_field_proto().operator_assign(proto.valueof());
			}
			if (msg.is_bound()) {
				ret_val.get_field_msg().operator_assign(msg.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				if (proto.is_present()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.ASP_Send.");
			}
		}

		@Override
		public ASP__Send_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.ASP_Send.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.ASP_Send using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.ASP_Send.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" connId := ");
				connId.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" proto := ");
				proto.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msg := ");
				msg.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ASP__Send match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ASP__Send) {
				log_match((ASP__Send)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.ASP_Send.");
		}

		public void log_match(final ASP__Send match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !connId.match(match_value.constGet_field_connId(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".connId");
							connId.log_match(match_value.constGet_field_connId(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGet_field_proto().ispresent()) {
							if( !proto.match(match_value.constGet_field_proto().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".proto");
								proto.log_match(match_value.constGet_field_proto().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!proto.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".proto := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								proto.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if( !msg.match(match_value.constGet_field_msg(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msg");
							msg.log_match(match_value.constGet_field_msg(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ connId := ");
				connId.log_match(match_value.constGet_field_connId(), legacy);
				TTCN_Logger.log_event_str("{ proto := ");
				proto.log_match(match_value.constGet_field_proto(), legacy);
				TTCN_Logger.log_event_str("{ msg := ");
				msg.log_match(match_value.constGet_field_msg(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				connId.encode_text(text_buf);
				proto.encode_text(text_buf);
				msg.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.ASP_Send.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				connId = new TitanInteger_template();
				connId.decode_text(text_buf);
				proto = new Socket__API__Definitions.ProtoTuple_template();
				proto.decode_text(text_buf);
				msg = new TitanOctetString_template();
				msg.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<ASP__Send_template>(size);
				for (int i = 0; i < size; i++) {
					final ASP__Send_template temp = new ASP__Send_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.ASP_Send.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.ASP_Send has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_connId().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_proto().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_msg().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("connId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_connId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("proto".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_proto().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msg".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_msg().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.ASP_Send: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.ASP_Send");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.connId.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_Send" : name, legacy);
				this.proto.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_Send" : name, legacy);
				this.msg.check_restriction(restriction, name == null ? "@IPL4asp_Types.ASP_Send" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.ASP_Send" : name));
		}
	}
	public static class SctpEvent extends Socket__API__Definitions.SctpEvent { }
	public static class SctpEvent_template extends Socket__API__Definitions.SctpEvent_template { }
	public static class Linger__opt extends Base_Type {
		private final TitanInteger l__onoff;
		private final TitanInteger l__linger;

		public Linger__opt() {
			this.l__onoff = new TitanInteger();
			this.l__linger = new TitanInteger();
		}

		public Linger__opt(final TitanInteger l__onoff, final TitanInteger l__linger ) {
			this.l__onoff = new TitanInteger( l__onoff );
			this.l__linger = new TitanInteger( l__linger );
		}

		public Linger__opt( final Linger__opt otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.Linger_opt.");
			l__onoff = new TitanInteger();
			l__linger = new TitanInteger();
			operator_assign( otherValue );
		}

		public Linger__opt operator_assign(final Linger__opt otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.Linger_opt");
			if (otherValue != this) {
				if ( otherValue.get_field_l__onoff().is_bound() ) {
					this.l__onoff.operator_assign( otherValue.get_field_l__onoff() );
				} else {
					this.l__onoff.clean_up();
				}
				if ( otherValue.get_field_l__linger().is_bound() ) {
					this.l__linger.operator_assign( otherValue.get_field_l__linger() );
				} else {
					this.l__linger.clean_up();
				}
			}

			return this;
		}

		@Override
		public Linger__opt operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof Linger__opt ) {
				return operator_assign((Linger__opt) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.Linger_opt", otherValue));
		}

		@Override
		public void clean_up() {
			l__onoff.clean_up();
			l__linger.clean_up();
		}

		@Override
		public boolean is_bound() {
			return l__onoff.is_bound()
					|| l__linger.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return l__onoff.is_value()
					&& l__linger.is_value();
		}

		public boolean operator_equals( final Linger__opt other_value) {
			return l__onoff.operator_equals( other_value.l__onoff )
					&& l__linger.operator_equals( other_value.l__linger );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof Linger__opt ) {
				return operator_equals((Linger__opt) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.Linger_opt", other_value));
		}

		public TitanInteger get_field_l__onoff() {
			return l__onoff;
		}

		public TitanInteger constGet_field_l__onoff() {
			return l__onoff;
		}

		public TitanInteger get_field_l__linger() {
			return l__linger;
		}

		public TitanInteger constGet_field_l__linger() {
			return l__linger;
		}

		public TitanInteger size_of() {
			return new TitanInteger(2);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" l_onoff := ");
			l__onoff.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" l_linger := ");
			l__linger.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.Linger_opt has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_l__onoff().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_l__linger().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("l_onoff".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_l__onoff().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("l_linger".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_l__linger().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.Linger_opt: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.Linger_opt");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (l__onoff.is_bound()) {
				l__onoff.set_implicit_omit();
			}
			if (l__linger.is_bound()) {
				l__linger.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			l__onoff.encode_text(text_buf);
			l__linger.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			l__onoff.decode_text(text_buf);
			l__linger.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class Linger__opt_template extends Base_Template {
		private TitanInteger_template l__onoff;
		private TitanInteger_template l__linger;
		//originally value_list/list_value
		private List<Linger__opt_template> list_value;


		public Linger__opt_template() {
			// do nothing
		}

		public Linger__opt_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public Linger__opt_template( final Linger__opt otherValue ) {
			copy_value(otherValue);
		}

		public Linger__opt_template( final Linger__opt_template otherValue ) {
			copy_template( otherValue );
		}

		public Linger__opt_template( final Optional<Linger__opt> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.Linger_opt from an unbound optional field.");
			}
		}

		@Override
		public Linger__opt_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public Linger__opt_template operator_assign( final Linger__opt otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public Linger__opt_template operator_assign( final Linger__opt_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public Linger__opt_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof Linger__opt) {
				return operator_assign((Linger__opt) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Linger__opt' can not be cast to {1}", otherValue));
		}

		@Override
		public Linger__opt_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof Linger__opt_template) {
				return operator_assign((Linger__opt_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Linger__opt' can not be cast to {1}_template", otherValue));
		}

		public Linger__opt_template operator_assign( final Optional<Linger__opt> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.Linger_opt.");
			}
			return this;
		}

		private void copy_value(final Linger__opt other_value) {
			if (other_value.get_field_l__onoff().is_bound()) {
				get_field_l__onoff().operator_assign(other_value.get_field_l__onoff());
			} else {
				get_field_l__onoff().clean_up();
			}
			if (other_value.get_field_l__linger().is_bound()) {
				get_field_l__linger().operator_assign(other_value.get_field_l__linger());
			} else {
				get_field_l__linger().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final Linger__opt_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_l__onoff().get_selection()) {
					get_field_l__onoff().clean_up();
				} else {
					get_field_l__onoff().operator_assign(other_value.get_field_l__onoff());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_l__linger().get_selection()) {
					get_field_l__linger().clean_up();
				} else {
					get_field_l__linger().operator_assign(other_value.get_field_l__linger());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Linger__opt_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Linger__opt_template temp = new Linger__opt_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.Linger_opt.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.Linger_opt.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<Linger__opt_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Linger__opt_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return l__onoff.is_bound()
					|| l__linger.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return l__onoff.is_value()
					&& l__linger.is_value();
		}
		public TitanInteger_template get_field_l__onoff() {
			set_specific();
			return l__onoff;
		}

		public TitanInteger_template constGet_field_l__onoff() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field l_onoff of a non-specific template of type @IPL4asp_Types.Linger_opt.");
			}
			return l__onoff;
		}

		public TitanInteger_template get_field_l__linger() {
			set_specific();
			return l__linger;
		}

		public TitanInteger_template constGet_field_l__linger() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field l_linger of a non-specific template of type @IPL4asp_Types.Linger_opt.");
			}
			return l__linger;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					l__onoff = new TitanInteger_template(template_sel.ANY_VALUE);
					l__linger = new TitanInteger_template(template_sel.ANY_VALUE);
				} else {
					l__onoff = new TitanInteger_template();
					l__linger = new TitanInteger_template();
				}
			}
		}
		public boolean match(final Linger__opt other_value) {
			return match(other_value, false);
		}

		public boolean match(final Linger__opt other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_l__onoff().is_bound()) {
					return false;
				}
				if(!l__onoff.match(other_value.get_field_l__onoff(), legacy)) {
					return false;
				}
				if(!other_value.get_field_l__linger().is_bound()) {
					return false;
				}
				if(!l__linger.match(other_value.get_field_l__linger(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.Linger_opt.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Linger__opt) {
				return match((Linger__opt)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Linger__opt.");
		}


		@Override
		public Linger__opt valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.Linger_opt.");
			}
			final Linger__opt ret_val = new Linger__opt();
			if (l__onoff.is_bound()) {
				ret_val.get_field_l__onoff().operator_assign(l__onoff.valueof());
			}
			if (l__linger.is_bound()) {
				ret_val.get_field_l__linger().operator_assign(l__linger.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(2);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.Linger_opt.");
			}
		}

		@Override
		public Linger__opt_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.Linger_opt.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.Linger_opt using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.Linger_opt.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" l_onoff := ");
				l__onoff.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" l_linger := ");
				l__linger.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Linger__opt match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Linger__opt) {
				log_match((Linger__opt)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.Linger_opt.");
		}

		public void log_match(final Linger__opt match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !l__onoff.match(match_value.constGet_field_l__onoff(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".l_onoff");
							l__onoff.log_match(match_value.constGet_field_l__onoff(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !l__linger.match(match_value.constGet_field_l__linger(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".l_linger");
							l__linger.log_match(match_value.constGet_field_l__linger(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ l_onoff := ");
				l__onoff.log_match(match_value.constGet_field_l__onoff(), legacy);
				TTCN_Logger.log_event_str("{ l_linger := ");
				l__linger.log_match(match_value.constGet_field_l__linger(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				l__onoff.encode_text(text_buf);
				l__linger.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.Linger_opt.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				l__onoff = new TitanInteger_template();
				l__onoff.decode_text(text_buf);
				l__linger = new TitanInteger_template();
				l__linger.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<Linger__opt_template>(size);
				for (int i = 0; i < size; i++) {
					final Linger__opt_template temp = new Linger__opt_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.Linger_opt.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.Linger_opt has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_l__onoff().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_l__linger().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("l_onoff".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_l__onoff().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("l_linger".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_l__linger().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.Linger_opt: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.Linger_opt");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.l__onoff.check_restriction(restriction, name == null ? "@IPL4asp_Types.Linger_opt" : name, legacy);
				this.l__linger.check_restriction(restriction, name == null ? "@IPL4asp_Types.Linger_opt" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.Linger_opt" : name));
		}
	}
	public static class Option extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_reuseAddress,  ALT_tcpKeepAlive,  ALT_sctpEventHandle,  ALT_sslKeepAlive,  ALT_sctpAdditionalLocalAddresses,  ALT_sctpEINConfigGroup,  ALT_solinger,  ALT_ssl__support,  ALT_no__delay,  ALT_dtlsSrtpProfiles,  ALT_cert__options,  ALT_freebind,  ALT_alpn__list,  ALT_tls__hostname,  ALT_udp__encap,  ALT_dscp,  ALT_mtu__discover,  ALT_psk__options };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;

		public Option() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};

		public Option(final Option otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final Option other_value) {
			switch (other_value.union_selection){
			case ALT_reuseAddress:
				field = new ReuseAddress((ReuseAddress)other_value.field);
				break;
			case ALT_tcpKeepAlive:
				field = new TcpKeepAlive((TcpKeepAlive)other_value.field);
				break;
			case ALT_sctpEventHandle:
				field = new SctpEventHandle((SctpEventHandle)other_value.field);
				break;
			case ALT_sslKeepAlive:
				field = new TcpKeepAlive((TcpKeepAlive)other_value.field);
				break;
			case ALT_sctpAdditionalLocalAddresses:
				field = new HostList((HostList)other_value.field);
				break;
			case ALT_sctpEINConfigGroup:
				field = new TitanInteger((TitanInteger)other_value.field);
				break;
			case ALT_solinger:
				field = new Linger__opt((Linger__opt)other_value.field);
				break;
			case ALT_ssl__support:
				field = new SSL__proto__support((SSL__proto__support)other_value.field);
				break;
			case ALT_no__delay:
				field = new TitanBoolean((TitanBoolean)other_value.field);
				break;
			case ALT_dtlsSrtpProfiles:
				field = new TitanCharString((TitanCharString)other_value.field);
				break;
			case ALT_cert__options:
				field = new SSL__cert__options((SSL__cert__options)other_value.field);
				break;
			case ALT_freebind:
				field = new TitanBoolean((TitanBoolean)other_value.field);
				break;
			case ALT_alpn__list:
				field = new Option_alpn__list((Option_alpn__list)other_value.field);
				break;
			case ALT_tls__hostname:
				field = new TitanCharString((TitanCharString)other_value.field);
				break;
			case ALT_udp__encap:
				field = new UDP__ENCAP__Param((UDP__ENCAP__Param)other_value.field);
				break;
			case ALT_dscp:
				field = new TitanInteger((TitanInteger)other_value.field);
				break;
			case ALT_mtu__discover:
				field = new MTU__discover((MTU__discover)other_value.field);
				break;
			case ALT_psk__options:
				field = new PSK__options((PSK__options)other_value.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @IPL4asp_Types.Option.");
			}
			union_selection = other_value.union_selection;
		}

		public Option operator_assign( final Option otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_value(otherValue);
			}

			return this;
		}

		@Override
		public Option operator_assign( final Base_Type otherValue ) {
			if (otherValue instanceof Option) {
				return operator_assign((Option)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.Option.");
		}

		@Override
		public void clean_up() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean ischosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.Option.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean is_bound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean is_value() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_reuseAddress:
				return field.is_value();
			case ALT_tcpKeepAlive:
				return field.is_value();
			case ALT_sctpEventHandle:
				return field.is_value();
			case ALT_sslKeepAlive:
				return field.is_value();
			case ALT_sctpAdditionalLocalAddresses:
				return field.is_value();
			case ALT_sctpEINConfigGroup:
				return field.is_value();
			case ALT_solinger:
				return field.is_value();
			case ALT_ssl__support:
				return field.is_value();
			case ALT_no__delay:
				return field.is_value();
			case ALT_dtlsSrtpProfiles:
				return field.is_value();
			case ALT_cert__options:
				return field.is_value();
			case ALT_freebind:
				return field.is_value();
			case ALT_alpn__list:
				return field.is_value();
			case ALT_tls__hostname:
				return field.is_value();
			case ALT_udp__encap:
				return field.is_value();
			case ALT_dscp:
				return field.is_value();
			case ALT_mtu__discover:
				return field.is_value();
			case ALT_psk__options:
				return field.is_value();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		public boolean operator_equals( final Option otherValue ) {
			must_bound( "The left operand of comparison is an unbound value of union type @IPL4asp_Types.Option." );
			otherValue.must_bound( "The right operand of comparison is an unbound value of union type @IPL4asp_Types.Option." );
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_reuseAddress:
				return ((ReuseAddress)field).operator_equals((ReuseAddress)otherValue.field);
			case ALT_tcpKeepAlive:
				return ((TcpKeepAlive)field).operator_equals((TcpKeepAlive)otherValue.field);
			case ALT_sctpEventHandle:
				return ((SctpEventHandle)field).operator_equals((SctpEventHandle)otherValue.field);
			case ALT_sslKeepAlive:
				return ((TcpKeepAlive)field).operator_equals((TcpKeepAlive)otherValue.field);
			case ALT_sctpAdditionalLocalAddresses:
				return ((HostList)field).operator_equals((HostList)otherValue.field);
			case ALT_sctpEINConfigGroup:
				return ((TitanInteger)field).operator_equals((TitanInteger)otherValue.field);
			case ALT_solinger:
				return ((Linger__opt)field).operator_equals((Linger__opt)otherValue.field);
			case ALT_ssl__support:
				return ((SSL__proto__support)field).operator_equals((SSL__proto__support)otherValue.field);
			case ALT_no__delay:
				return ((TitanBoolean)field).operator_equals((TitanBoolean)otherValue.field);
			case ALT_dtlsSrtpProfiles:
				return ((TitanCharString)field).operator_equals((TitanCharString)otherValue.field);
			case ALT_cert__options:
				return ((SSL__cert__options)field).operator_equals((SSL__cert__options)otherValue.field);
			case ALT_freebind:
				return ((TitanBoolean)field).operator_equals((TitanBoolean)otherValue.field);
			case ALT_alpn__list:
				return ((Option_alpn__list)field).operator_equals((Option_alpn__list)otherValue.field);
			case ALT_tls__hostname:
				return ((TitanCharString)field).operator_equals((TitanCharString)otherValue.field);
			case ALT_udp__encap:
				return ((UDP__ENCAP__Param)field).operator_equals((UDP__ENCAP__Param)otherValue.field);
			case ALT_dscp:
				return ((TitanInteger)field).operator_equals((TitanInteger)otherValue.field);
			case ALT_mtu__discover:
				return ((MTU__discover)field).operator_equals((MTU__discover)otherValue.field);
			case ALT_psk__options:
				return ((PSK__options)field).operator_equals((PSK__options)otherValue.field);
			default:
				return false;
			}
		}

		@Override
		public boolean operator_equals( final Base_Type otherValue ) {
			if (otherValue instanceof Option) {
				return operator_equals((Option)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.Option.");
		}

		public boolean operator_not_equals( final Option otherValue ) {
			return !operator_equals(otherValue);
		}

		public ReuseAddress get_field_reuseAddress() {
			if (union_selection != union_selection_type.ALT_reuseAddress) {
				clean_up();
				field = new ReuseAddress();
				union_selection = union_selection_type.ALT_reuseAddress;
			}
			return (ReuseAddress)field;
		}

		public ReuseAddress constGet_field_reuseAddress() {
			if (union_selection != union_selection_type.ALT_reuseAddress) {
				throw new TtcnError("Using non-selected field reuseAddress in a value of union type @IPL4asp_Types.Option.");
			}
			return (ReuseAddress)field;
		}

		public TcpKeepAlive get_field_tcpKeepAlive() {
			if (union_selection != union_selection_type.ALT_tcpKeepAlive) {
				clean_up();
				field = new TcpKeepAlive();
				union_selection = union_selection_type.ALT_tcpKeepAlive;
			}
			return (TcpKeepAlive)field;
		}

		public TcpKeepAlive constGet_field_tcpKeepAlive() {
			if (union_selection != union_selection_type.ALT_tcpKeepAlive) {
				throw new TtcnError("Using non-selected field tcpKeepAlive in a value of union type @IPL4asp_Types.Option.");
			}
			return (TcpKeepAlive)field;
		}

		public SctpEventHandle get_field_sctpEventHandle() {
			if (union_selection != union_selection_type.ALT_sctpEventHandle) {
				clean_up();
				field = new SctpEventHandle();
				union_selection = union_selection_type.ALT_sctpEventHandle;
			}
			return (SctpEventHandle)field;
		}

		public SctpEventHandle constGet_field_sctpEventHandle() {
			if (union_selection != union_selection_type.ALT_sctpEventHandle) {
				throw new TtcnError("Using non-selected field sctpEventHandle in a value of union type @IPL4asp_Types.Option.");
			}
			return (SctpEventHandle)field;
		}

		public TcpKeepAlive get_field_sslKeepAlive() {
			if (union_selection != union_selection_type.ALT_sslKeepAlive) {
				clean_up();
				field = new TcpKeepAlive();
				union_selection = union_selection_type.ALT_sslKeepAlive;
			}
			return (TcpKeepAlive)field;
		}

		public TcpKeepAlive constGet_field_sslKeepAlive() {
			if (union_selection != union_selection_type.ALT_sslKeepAlive) {
				throw new TtcnError("Using non-selected field sslKeepAlive in a value of union type @IPL4asp_Types.Option.");
			}
			return (TcpKeepAlive)field;
		}

		public HostList get_field_sctpAdditionalLocalAddresses() {
			if (union_selection != union_selection_type.ALT_sctpAdditionalLocalAddresses) {
				clean_up();
				field = new HostList();
				union_selection = union_selection_type.ALT_sctpAdditionalLocalAddresses;
			}
			return (HostList)field;
		}

		public HostList constGet_field_sctpAdditionalLocalAddresses() {
			if (union_selection != union_selection_type.ALT_sctpAdditionalLocalAddresses) {
				throw new TtcnError("Using non-selected field sctpAdditionalLocalAddresses in a value of union type @IPL4asp_Types.Option.");
			}
			return (HostList)field;
		}

		public TitanInteger get_field_sctpEINConfigGroup() {
			if (union_selection != union_selection_type.ALT_sctpEINConfigGroup) {
				clean_up();
				field = new TitanInteger();
				union_selection = union_selection_type.ALT_sctpEINConfigGroup;
			}
			return (TitanInteger)field;
		}

		public TitanInteger constGet_field_sctpEINConfigGroup() {
			if (union_selection != union_selection_type.ALT_sctpEINConfigGroup) {
				throw new TtcnError("Using non-selected field sctpEINConfigGroup in a value of union type @IPL4asp_Types.Option.");
			}
			return (TitanInteger)field;
		}

		public Linger__opt get_field_solinger() {
			if (union_selection != union_selection_type.ALT_solinger) {
				clean_up();
				field = new Linger__opt();
				union_selection = union_selection_type.ALT_solinger;
			}
			return (Linger__opt)field;
		}

		public Linger__opt constGet_field_solinger() {
			if (union_selection != union_selection_type.ALT_solinger) {
				throw new TtcnError("Using non-selected field solinger in a value of union type @IPL4asp_Types.Option.");
			}
			return (Linger__opt)field;
		}

		public SSL__proto__support get_field_ssl__support() {
			if (union_selection != union_selection_type.ALT_ssl__support) {
				clean_up();
				field = new SSL__proto__support();
				union_selection = union_selection_type.ALT_ssl__support;
			}
			return (SSL__proto__support)field;
		}

		public SSL__proto__support constGet_field_ssl__support() {
			if (union_selection != union_selection_type.ALT_ssl__support) {
				throw new TtcnError("Using non-selected field ssl_support in a value of union type @IPL4asp_Types.Option.");
			}
			return (SSL__proto__support)field;
		}

		public TitanBoolean get_field_no__delay() {
			if (union_selection != union_selection_type.ALT_no__delay) {
				clean_up();
				field = new TitanBoolean();
				union_selection = union_selection_type.ALT_no__delay;
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean constGet_field_no__delay() {
			if (union_selection != union_selection_type.ALT_no__delay) {
				throw new TtcnError("Using non-selected field no_delay in a value of union type @IPL4asp_Types.Option.");
			}
			return (TitanBoolean)field;
		}

		public TitanCharString get_field_dtlsSrtpProfiles() {
			if (union_selection != union_selection_type.ALT_dtlsSrtpProfiles) {
				clean_up();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_dtlsSrtpProfiles;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGet_field_dtlsSrtpProfiles() {
			if (union_selection != union_selection_type.ALT_dtlsSrtpProfiles) {
				throw new TtcnError("Using non-selected field dtlsSrtpProfiles in a value of union type @IPL4asp_Types.Option.");
			}
			return (TitanCharString)field;
		}

		public SSL__cert__options get_field_cert__options() {
			if (union_selection != union_selection_type.ALT_cert__options) {
				clean_up();
				field = new SSL__cert__options();
				union_selection = union_selection_type.ALT_cert__options;
			}
			return (SSL__cert__options)field;
		}

		public SSL__cert__options constGet_field_cert__options() {
			if (union_selection != union_selection_type.ALT_cert__options) {
				throw new TtcnError("Using non-selected field cert_options in a value of union type @IPL4asp_Types.Option.");
			}
			return (SSL__cert__options)field;
		}

		public TitanBoolean get_field_freebind() {
			if (union_selection != union_selection_type.ALT_freebind) {
				clean_up();
				field = new TitanBoolean();
				union_selection = union_selection_type.ALT_freebind;
			}
			return (TitanBoolean)field;
		}

		public TitanBoolean constGet_field_freebind() {
			if (union_selection != union_selection_type.ALT_freebind) {
				throw new TtcnError("Using non-selected field freebind in a value of union type @IPL4asp_Types.Option.");
			}
			return (TitanBoolean)field;
		}

		public Option_alpn__list get_field_alpn__list() {
			if (union_selection != union_selection_type.ALT_alpn__list) {
				clean_up();
				field = new Option_alpn__list();
				union_selection = union_selection_type.ALT_alpn__list;
			}
			return (Option_alpn__list)field;
		}

		public Option_alpn__list constGet_field_alpn__list() {
			if (union_selection != union_selection_type.ALT_alpn__list) {
				throw new TtcnError("Using non-selected field alpn_list in a value of union type @IPL4asp_Types.Option.");
			}
			return (Option_alpn__list)field;
		}

		public TitanCharString get_field_tls__hostname() {
			if (union_selection != union_selection_type.ALT_tls__hostname) {
				clean_up();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_tls__hostname;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGet_field_tls__hostname() {
			if (union_selection != union_selection_type.ALT_tls__hostname) {
				throw new TtcnError("Using non-selected field tls_hostname in a value of union type @IPL4asp_Types.Option.");
			}
			return (TitanCharString)field;
		}

		public UDP__ENCAP__Param get_field_udp__encap() {
			if (union_selection != union_selection_type.ALT_udp__encap) {
				clean_up();
				field = new UDP__ENCAP__Param();
				union_selection = union_selection_type.ALT_udp__encap;
			}
			return (UDP__ENCAP__Param)field;
		}

		public UDP__ENCAP__Param constGet_field_udp__encap() {
			if (union_selection != union_selection_type.ALT_udp__encap) {
				throw new TtcnError("Using non-selected field udp_encap in a value of union type @IPL4asp_Types.Option.");
			}
			return (UDP__ENCAP__Param)field;
		}

		public TitanInteger get_field_dscp() {
			if (union_selection != union_selection_type.ALT_dscp) {
				clean_up();
				field = new TitanInteger();
				union_selection = union_selection_type.ALT_dscp;
			}
			return (TitanInteger)field;
		}

		public TitanInteger constGet_field_dscp() {
			if (union_selection != union_selection_type.ALT_dscp) {
				throw new TtcnError("Using non-selected field dscp in a value of union type @IPL4asp_Types.Option.");
			}
			return (TitanInteger)field;
		}

		public MTU__discover get_field_mtu__discover() {
			if (union_selection != union_selection_type.ALT_mtu__discover) {
				clean_up();
				field = new MTU__discover();
				union_selection = union_selection_type.ALT_mtu__discover;
			}
			return (MTU__discover)field;
		}

		public MTU__discover constGet_field_mtu__discover() {
			if (union_selection != union_selection_type.ALT_mtu__discover) {
				throw new TtcnError("Using non-selected field mtu_discover in a value of union type @IPL4asp_Types.Option.");
			}
			return (MTU__discover)field;
		}

		public PSK__options get_field_psk__options() {
			if (union_selection != union_selection_type.ALT_psk__options) {
				clean_up();
				field = new PSK__options();
				union_selection = union_selection_type.ALT_psk__options;
			}
			return (PSK__options)field;
		}

		public PSK__options constGet_field_psk__options() {
			if (union_selection != union_selection_type.ALT_psk__options) {
				throw new TtcnError("Using non-selected field psk_options in a value of union type @IPL4asp_Types.Option.");
			}
			return (PSK__options)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}

		@Override
		public void log() {
			switch (union_selection) {
			case ALT_reuseAddress:
				TTCN_Logger.log_event_str("{ reuseAddress := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_tcpKeepAlive:
				TTCN_Logger.log_event_str("{ tcpKeepAlive := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_sctpEventHandle:
				TTCN_Logger.log_event_str("{ sctpEventHandle := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_sslKeepAlive:
				TTCN_Logger.log_event_str("{ sslKeepAlive := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_sctpAdditionalLocalAddresses:
				TTCN_Logger.log_event_str("{ sctpAdditionalLocalAddresses := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_sctpEINConfigGroup:
				TTCN_Logger.log_event_str("{ sctpEINConfigGroup := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_solinger:
				TTCN_Logger.log_event_str("{ solinger := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_ssl__support:
				TTCN_Logger.log_event_str("{ ssl_support := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_no__delay:
				TTCN_Logger.log_event_str("{ no_delay := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_dtlsSrtpProfiles:
				TTCN_Logger.log_event_str("{ dtlsSrtpProfiles := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_cert__options:
				TTCN_Logger.log_event_str("{ cert_options := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_freebind:
				TTCN_Logger.log_event_str("{ freebind := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_alpn__list:
				TTCN_Logger.log_event_str("{ alpn_list := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_tls__hostname:
				TTCN_Logger.log_event_str("{ tls_hostname := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_udp__encap:
				TTCN_Logger.log_event_str("{ udp_encap := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_dscp:
				TTCN_Logger.log_event_str("{ dscp := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_mtu__discover:
				TTCN_Logger.log_event_str("{ mtu_discover := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_psk__options:
				TTCN_Logger.log_event_str("{ psk_options := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("reuseAddress".equals(last_name)) {
				get_field_reuseAddress().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("tcpKeepAlive".equals(last_name)) {
				get_field_tcpKeepAlive().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("sctpEventHandle".equals(last_name)) {
				get_field_sctpEventHandle().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("sslKeepAlive".equals(last_name)) {
				get_field_sslKeepAlive().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("sctpAdditionalLocalAddresses".equals(last_name)) {
				get_field_sctpAdditionalLocalAddresses().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("sctpEINConfigGroup".equals(last_name)) {
				get_field_sctpEINConfigGroup().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("solinger".equals(last_name)) {
				get_field_solinger().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("ssl_support".equals(last_name)) {
				get_field_ssl__support().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("no_delay".equals(last_name)) {
				get_field_no__delay().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("dtlsSrtpProfiles".equals(last_name)) {
				get_field_dtlsSrtpProfiles().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("cert_options".equals(last_name)) {
				get_field_cert__options().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("freebind".equals(last_name)) {
				get_field_freebind().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("alpn_list".equals(last_name)) {
				get_field_alpn__list().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("tls_hostname".equals(last_name)) {
				get_field_tls__hostname().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("udp_encap".equals(last_name)) {
				get_field_udp__encap().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("dscp".equals(last_name)) {
				get_field_dscp().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("mtu_discover".equals(last_name)) {
				get_field_mtu__discover().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			if ("psk_options".equals(last_name)) {
				get_field_psk__options().set_param(mp_last);
				if (!field.is_bound()) {
					clean_up();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @IPL4asp_Types.Option.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_reuseAddress:
			case ALT_tcpKeepAlive:
			case ALT_sctpEventHandle:
			case ALT_sslKeepAlive:
			case ALT_sctpAdditionalLocalAddresses:
			case ALT_sctpEINConfigGroup:
			case ALT_solinger:
			case ALT_ssl__support:
			case ALT_no__delay:
			case ALT_dtlsSrtpProfiles:
			case ALT_cert__options:
			case ALT_freebind:
			case ALT_alpn__list:
			case ALT_tls__hostname:
			case ALT_udp__encap:
			case ALT_dscp:
			case ALT_mtu__discover:
			case ALT_psk__options:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_reuseAddress:
				text_buf.push_int(1);
				break;
			case ALT_tcpKeepAlive:
				text_buf.push_int(2);
				break;
			case ALT_sctpEventHandle:
				text_buf.push_int(3);
				break;
			case ALT_sslKeepAlive:
				text_buf.push_int(4);
				break;
			case ALT_sctpAdditionalLocalAddresses:
				text_buf.push_int(5);
				break;
			case ALT_sctpEINConfigGroup:
				text_buf.push_int(6);
				break;
			case ALT_solinger:
				text_buf.push_int(7);
				break;
			case ALT_ssl__support:
				text_buf.push_int(8);
				break;
			case ALT_no__delay:
				text_buf.push_int(9);
				break;
			case ALT_dtlsSrtpProfiles:
				text_buf.push_int(10);
				break;
			case ALT_cert__options:
				text_buf.push_int(11);
				break;
			case ALT_freebind:
				text_buf.push_int(12);
				break;
			case ALT_alpn__list:
				text_buf.push_int(13);
				break;
			case ALT_tls__hostname:
				text_buf.push_int(14);
				break;
			case ALT_udp__encap:
				text_buf.push_int(15);
				break;
			case ALT_dscp:
				text_buf.push_int(16);
				break;
			case ALT_mtu__discover:
				text_buf.push_int(17);
				break;
			case ALT_psk__options:
				text_buf.push_int(18);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @IPL4asp_Types.Option.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().get_int();
			switch (temp) {
			case 1:
				get_field_reuseAddress().decode_text(text_buf);
				break;
			case 2:
				get_field_tcpKeepAlive().decode_text(text_buf);
				break;
			case 3:
				get_field_sctpEventHandle().decode_text(text_buf);
				break;
			case 4:
				get_field_sslKeepAlive().decode_text(text_buf);
				break;
			case 5:
				get_field_sctpAdditionalLocalAddresses().decode_text(text_buf);
				break;
			case 6:
				get_field_sctpEINConfigGroup().decode_text(text_buf);
				break;
			case 7:
				get_field_solinger().decode_text(text_buf);
				break;
			case 8:
				get_field_ssl__support().decode_text(text_buf);
				break;
			case 9:
				get_field_no__delay().decode_text(text_buf);
				break;
			case 10:
				get_field_dtlsSrtpProfiles().decode_text(text_buf);
				break;
			case 11:
				get_field_cert__options().decode_text(text_buf);
				break;
			case 12:
				get_field_freebind().decode_text(text_buf);
				break;
			case 13:
				get_field_alpn__list().decode_text(text_buf);
				break;
			case 14:
				get_field_tls__hostname().decode_text(text_buf);
				break;
			case 15:
				get_field_udp__encap().decode_text(text_buf);
				break;
			case 16:
				get_field_dscp().decode_text(text_buf);
				break;
			case 17:
				get_field_mtu__discover().decode_text(text_buf);
				break;
			case 18:
				get_field_psk__options().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @IPL4asp_Types.Option.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Option_template extends Base_Template {
		//if single value which value?
		private Option.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<Option_template> value_list;

		private void copy_value(final Option other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_reuseAddress:
				single_value = new ReuseAddress_template(other_value.constGet_field_reuseAddress());
				break;
			case ALT_tcpKeepAlive:
				single_value = new TcpKeepAlive_template(other_value.constGet_field_tcpKeepAlive());
				break;
			case ALT_sctpEventHandle:
				single_value = new SctpEventHandle_template(other_value.constGet_field_sctpEventHandle());
				break;
			case ALT_sslKeepAlive:
				single_value = new TcpKeepAlive_template(other_value.constGet_field_sslKeepAlive());
				break;
			case ALT_sctpAdditionalLocalAddresses:
				single_value = new HostList_template(other_value.constGet_field_sctpAdditionalLocalAddresses());
				break;
			case ALT_sctpEINConfigGroup:
				single_value = new TitanInteger_template(other_value.constGet_field_sctpEINConfigGroup());
				break;
			case ALT_solinger:
				single_value = new Linger__opt_template(other_value.constGet_field_solinger());
				break;
			case ALT_ssl__support:
				single_value = new SSL__proto__support_template(other_value.constGet_field_ssl__support());
				break;
			case ALT_no__delay:
				single_value = new TitanBoolean_template(other_value.constGet_field_no__delay());
				break;
			case ALT_dtlsSrtpProfiles:
				single_value = new TitanCharString_template(other_value.constGet_field_dtlsSrtpProfiles());
				break;
			case ALT_cert__options:
				single_value = new SSL__cert__options_template(other_value.constGet_field_cert__options());
				break;
			case ALT_freebind:
				single_value = new TitanBoolean_template(other_value.constGet_field_freebind());
				break;
			case ALT_alpn__list:
				single_value = new Option_alpn__list_template(other_value.constGet_field_alpn__list());
				break;
			case ALT_tls__hostname:
				single_value = new TitanCharString_template(other_value.constGet_field_tls__hostname());
				break;
			case ALT_udp__encap:
				single_value = new UDP__ENCAP__Param_template(other_value.constGet_field_udp__encap());
				break;
			case ALT_dscp:
				single_value = new TitanInteger_template(other_value.constGet_field_dscp());
				break;
			case ALT_mtu__discover:
				single_value = new MTU__discover_template(other_value.constGet_field_mtu__discover());
				break;
			case ALT_psk__options:
				single_value = new PSK__options_template(other_value.constGet_field_psk__options());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @IPL4asp_Types.Option.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final Option_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_reuseAddress:
					single_value = new ReuseAddress_template(other_value.constGet_field_reuseAddress());
					break;
				case ALT_tcpKeepAlive:
					single_value = new TcpKeepAlive_template(other_value.constGet_field_tcpKeepAlive());
					break;
				case ALT_sctpEventHandle:
					single_value = new SctpEventHandle_template(other_value.constGet_field_sctpEventHandle());
					break;
				case ALT_sslKeepAlive:
					single_value = new TcpKeepAlive_template(other_value.constGet_field_sslKeepAlive());
					break;
				case ALT_sctpAdditionalLocalAddresses:
					single_value = new HostList_template(other_value.constGet_field_sctpAdditionalLocalAddresses());
					break;
				case ALT_sctpEINConfigGroup:
					single_value = new TitanInteger_template(other_value.constGet_field_sctpEINConfigGroup());
					break;
				case ALT_solinger:
					single_value = new Linger__opt_template(other_value.constGet_field_solinger());
					break;
				case ALT_ssl__support:
					single_value = new SSL__proto__support_template(other_value.constGet_field_ssl__support());
					break;
				case ALT_no__delay:
					single_value = new TitanBoolean_template(other_value.constGet_field_no__delay());
					break;
				case ALT_dtlsSrtpProfiles:
					single_value = new TitanCharString_template(other_value.constGet_field_dtlsSrtpProfiles());
					break;
				case ALT_cert__options:
					single_value = new SSL__cert__options_template(other_value.constGet_field_cert__options());
					break;
				case ALT_freebind:
					single_value = new TitanBoolean_template(other_value.constGet_field_freebind());
					break;
				case ALT_alpn__list:
					single_value = new Option_alpn__list_template(other_value.constGet_field_alpn__list());
					break;
				case ALT_tls__hostname:
					single_value = new TitanCharString_template(other_value.constGet_field_tls__hostname());
					break;
				case ALT_udp__encap:
					single_value = new UDP__ENCAP__Param_template(other_value.constGet_field_udp__encap());
					break;
				case ALT_dscp:
					single_value = new TitanInteger_template(other_value.constGet_field_dscp());
					break;
				case ALT_mtu__discover:
					single_value = new MTU__discover_template(other_value.constGet_field_mtu__discover());
					break;
				case ALT_psk__options:
					single_value = new PSK__options_template(other_value.constGet_field_psk__options());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @IPL4asp_Types.Option.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<Option_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final Option_template temp = new Option_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @IPL4asp_Types.Option.");
			}
			set_selection(other_value);
		}

		public Option_template() {
			// do nothing
		}
		public Option_template(final template_sel other_value) {
			super(other_value);
			check_single_selection(other_value);
		}
		public Option_template(final Option other_value) {
			copy_value(other_value);
		}
		public Option_template(final Option_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_reuseAddress:
					((ReuseAddress_template)single_value).clean_up();
					break;
				case ALT_tcpKeepAlive:
					((TcpKeepAlive_template)single_value).clean_up();
					break;
				case ALT_sctpEventHandle:
					((SctpEventHandle_template)single_value).clean_up();
					break;
				case ALT_sslKeepAlive:
					((TcpKeepAlive_template)single_value).clean_up();
					break;
				case ALT_sctpAdditionalLocalAddresses:
					((HostList_template)single_value).clean_up();
					break;
				case ALT_sctpEINConfigGroup:
					((TitanInteger_template)single_value).clean_up();
					break;
				case ALT_solinger:
					((Linger__opt_template)single_value).clean_up();
					break;
				case ALT_ssl__support:
					((SSL__proto__support_template)single_value).clean_up();
					break;
				case ALT_no__delay:
					((TitanBoolean_template)single_value).clean_up();
					break;
				case ALT_dtlsSrtpProfiles:
					((TitanCharString_template)single_value).clean_up();
					break;
				case ALT_cert__options:
					((SSL__cert__options_template)single_value).clean_up();
					break;
				case ALT_freebind:
					((TitanBoolean_template)single_value).clean_up();
					break;
				case ALT_alpn__list:
					((Option_alpn__list_template)single_value).clean_up();
					break;
				case ALT_tls__hostname:
					((TitanCharString_template)single_value).clean_up();
					break;
				case ALT_udp__encap:
					((UDP__ENCAP__Param_template)single_value).clean_up();
					break;
				case ALT_dscp:
					((TitanInteger_template)single_value).clean_up();
					break;
				case ALT_mtu__discover:
					((MTU__discover_template)single_value).clean_up();
					break;
				case ALT_psk__options:
					((PSK__options_template)single_value).clean_up();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		@Override
		public Option_template operator_assign(final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public Option_template operator_assign(final Option otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public Option_template operator_assign(final Option_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public Option_template operator_assign(final Base_Type otherValue ) {
			if (otherValue instanceof Option) {
				return operator_assign((Option)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to Option.");
		}

		@Override
		public Option_template operator_assign(final Base_Template otherValue ) {
			if (otherValue instanceof Option_template) {
				return operator_assign((Option_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to Option_template.");
		}

		public boolean match(final Option other_value) {
			return match(other_value, false);
		}

		public boolean match(final Option other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final Option.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == Option.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_reuseAddress:
					return ((ReuseAddress_template)single_value).match(other_value.get_field_reuseAddress(), legacy);
				case ALT_tcpKeepAlive:
					return ((TcpKeepAlive_template)single_value).match(other_value.get_field_tcpKeepAlive(), legacy);
				case ALT_sctpEventHandle:
					return ((SctpEventHandle_template)single_value).match(other_value.get_field_sctpEventHandle(), legacy);
				case ALT_sslKeepAlive:
					return ((TcpKeepAlive_template)single_value).match(other_value.get_field_sslKeepAlive(), legacy);
				case ALT_sctpAdditionalLocalAddresses:
					return ((HostList_template)single_value).match(other_value.get_field_sctpAdditionalLocalAddresses(), legacy);
				case ALT_sctpEINConfigGroup:
					return ((TitanInteger_template)single_value).match(other_value.get_field_sctpEINConfigGroup(), legacy);
				case ALT_solinger:
					return ((Linger__opt_template)single_value).match(other_value.get_field_solinger(), legacy);
				case ALT_ssl__support:
					return ((SSL__proto__support_template)single_value).match(other_value.get_field_ssl__support(), legacy);
				case ALT_no__delay:
					return ((TitanBoolean_template)single_value).match(other_value.get_field_no__delay(), legacy);
				case ALT_dtlsSrtpProfiles:
					return ((TitanCharString_template)single_value).match(other_value.get_field_dtlsSrtpProfiles(), legacy);
				case ALT_cert__options:
					return ((SSL__cert__options_template)single_value).match(other_value.get_field_cert__options(), legacy);
				case ALT_freebind:
					return ((TitanBoolean_template)single_value).match(other_value.get_field_freebind(), legacy);
				case ALT_alpn__list:
					return ((Option_alpn__list_template)single_value).match(other_value.get_field_alpn__list(), legacy);
				case ALT_tls__hostname:
					return ((TitanCharString_template)single_value).match(other_value.get_field_tls__hostname(), legacy);
				case ALT_udp__encap:
					return ((UDP__ENCAP__Param_template)single_value).match(other_value.get_field_udp__encap(), legacy);
				case ALT_dscp:
					return ((TitanInteger_template)single_value).match(other_value.get_field_dscp(), legacy);
				case ALT_mtu__discover:
					return ((MTU__discover_template)single_value).match(other_value.get_field_mtu__discover(), legacy);
				case ALT_psk__options:
					return ((PSK__options_template)single_value).match(other_value.get_field_psk__options(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @IPL4asp_Types.Option.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Option) {
				return match((Option)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Option.");
		}

		public boolean ischosen(final Option.union_selection_type checked_selection) {
			if(checked_selection == Option.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.Option.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == Option.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @IPL4asp_Types.Option.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @IPL4asp_Types.Option containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).ischosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_reuseAddress:
				return ((ReuseAddress_template)single_value).is_value();
			case ALT_tcpKeepAlive:
				return ((TcpKeepAlive_template)single_value).is_value();
			case ALT_sctpEventHandle:
				return ((SctpEventHandle_template)single_value).is_value();
			case ALT_sslKeepAlive:
				return ((TcpKeepAlive_template)single_value).is_value();
			case ALT_sctpAdditionalLocalAddresses:
				return ((HostList_template)single_value).is_value();
			case ALT_sctpEINConfigGroup:
				return ((TitanInteger_template)single_value).is_value();
			case ALT_solinger:
				return ((Linger__opt_template)single_value).is_value();
			case ALT_ssl__support:
				return ((SSL__proto__support_template)single_value).is_value();
			case ALT_no__delay:
				return ((TitanBoolean_template)single_value).is_value();
			case ALT_dtlsSrtpProfiles:
				return ((TitanCharString_template)single_value).is_value();
			case ALT_cert__options:
				return ((SSL__cert__options_template)single_value).is_value();
			case ALT_freebind:
				return ((TitanBoolean_template)single_value).is_value();
			case ALT_alpn__list:
				return ((Option_alpn__list_template)single_value).is_value();
			case ALT_tls__hostname:
				return ((TitanCharString_template)single_value).is_value();
			case ALT_udp__encap:
				return ((UDP__ENCAP__Param_template)single_value).is_value();
			case ALT_dscp:
				return ((TitanInteger_template)single_value).is_value();
			case ALT_mtu__discover:
				return ((MTU__discover_template)single_value).is_value();
			case ALT_psk__options:
				return ((PSK__options_template)single_value).is_value();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @IPL4asp_Types.Option.");
			}
		}

		@Override
		public Option valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @IPL4asp_Types.Option.");
			}
			final Option ret_val = new Option();
			switch (single_value_union_selection) {
			case ALT_reuseAddress:
				ret_val.get_field_reuseAddress().operator_assign(((ReuseAddress_template)single_value).valueof());
				break;
			case ALT_tcpKeepAlive:
				ret_val.get_field_tcpKeepAlive().operator_assign(((TcpKeepAlive_template)single_value).valueof());
				break;
			case ALT_sctpEventHandle:
				ret_val.get_field_sctpEventHandle().operator_assign(((SctpEventHandle_template)single_value).valueof());
				break;
			case ALT_sslKeepAlive:
				ret_val.get_field_sslKeepAlive().operator_assign(((TcpKeepAlive_template)single_value).valueof());
				break;
			case ALT_sctpAdditionalLocalAddresses:
				ret_val.get_field_sctpAdditionalLocalAddresses().operator_assign(((HostList_template)single_value).valueof());
				break;
			case ALT_sctpEINConfigGroup:
				ret_val.get_field_sctpEINConfigGroup().operator_assign(((TitanInteger_template)single_value).valueof());
				break;
			case ALT_solinger:
				ret_val.get_field_solinger().operator_assign(((Linger__opt_template)single_value).valueof());
				break;
			case ALT_ssl__support:
				ret_val.get_field_ssl__support().operator_assign(((SSL__proto__support_template)single_value).valueof());
				break;
			case ALT_no__delay:
				ret_val.get_field_no__delay().operator_assign(((TitanBoolean_template)single_value).valueof());
				break;
			case ALT_dtlsSrtpProfiles:
				ret_val.get_field_dtlsSrtpProfiles().operator_assign(((TitanCharString_template)single_value).valueof());
				break;
			case ALT_cert__options:
				ret_val.get_field_cert__options().operator_assign(((SSL__cert__options_template)single_value).valueof());
				break;
			case ALT_freebind:
				ret_val.get_field_freebind().operator_assign(((TitanBoolean_template)single_value).valueof());
				break;
			case ALT_alpn__list:
				ret_val.get_field_alpn__list().operator_assign(((Option_alpn__list_template)single_value).valueof());
				break;
			case ALT_tls__hostname:
				ret_val.get_field_tls__hostname().operator_assign(((TitanCharString_template)single_value).valueof());
				break;
			case ALT_udp__encap:
				ret_val.get_field_udp__encap().operator_assign(((UDP__ENCAP__Param_template)single_value).valueof());
				break;
			case ALT_dscp:
				ret_val.get_field_dscp().operator_assign(((TitanInteger_template)single_value).valueof());
				break;
			case ALT_mtu__discover:
				ret_val.get_field_mtu__discover().operator_assign(((MTU__discover_template)single_value).valueof());
				break;
			case ALT_psk__options:
				ret_val.get_field_psk__options().operator_assign(((PSK__options_template)single_value).valueof());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @IPL4asp_Types.Option.");
			}
			return ret_val;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @IPL4asp_Types.Option.");
			}
			clean_up();
			set_selection(template_type);
			value_list = new ArrayList<Option_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new Option_template());
			}
		}

		@Override
		public Option_template list_item(final int list_index)  {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @IPL4asp_Types.Option.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.Option using a negative index ({0}).", list_index));
			} else if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @IPL4asp_Types.Option.");
			}
			return value_list.get(list_index);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public ReuseAddress_template get_field_reuseAddress() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_reuseAddress) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new ReuseAddress_template(template_sel.ANY_VALUE);
				} else {
					single_value = new ReuseAddress_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_reuseAddress;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (ReuseAddress_template)single_value;
		}

		public ReuseAddress_template constGet_field_reuseAddress() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reuseAddress in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_reuseAddress) {
				throw new TtcnError("Accessing non-selected field reuseAddress in a template of union type @IPL4asp_Types.Option.");
			}
			return (ReuseAddress_template)single_value;
		}

		public TcpKeepAlive_template get_field_tcpKeepAlive() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_tcpKeepAlive) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TcpKeepAlive_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TcpKeepAlive_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_tcpKeepAlive;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TcpKeepAlive_template)single_value;
		}

		public TcpKeepAlive_template constGet_field_tcpKeepAlive() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field tcpKeepAlive in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_tcpKeepAlive) {
				throw new TtcnError("Accessing non-selected field tcpKeepAlive in a template of union type @IPL4asp_Types.Option.");
			}
			return (TcpKeepAlive_template)single_value;
		}

		public SctpEventHandle_template get_field_sctpEventHandle() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_sctpEventHandle) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new SctpEventHandle_template(template_sel.ANY_VALUE);
				} else {
					single_value = new SctpEventHandle_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_sctpEventHandle;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (SctpEventHandle_template)single_value;
		}

		public SctpEventHandle_template constGet_field_sctpEventHandle() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctpEventHandle in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_sctpEventHandle) {
				throw new TtcnError("Accessing non-selected field sctpEventHandle in a template of union type @IPL4asp_Types.Option.");
			}
			return (SctpEventHandle_template)single_value;
		}

		public TcpKeepAlive_template get_field_sslKeepAlive() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_sslKeepAlive) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TcpKeepAlive_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TcpKeepAlive_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_sslKeepAlive;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TcpKeepAlive_template)single_value;
		}

		public TcpKeepAlive_template constGet_field_sslKeepAlive() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sslKeepAlive in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_sslKeepAlive) {
				throw new TtcnError("Accessing non-selected field sslKeepAlive in a template of union type @IPL4asp_Types.Option.");
			}
			return (TcpKeepAlive_template)single_value;
		}

		public HostList_template get_field_sctpAdditionalLocalAddresses() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_sctpAdditionalLocalAddresses) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new HostList_template(template_sel.ANY_VALUE);
				} else {
					single_value = new HostList_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_sctpAdditionalLocalAddresses;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (HostList_template)single_value;
		}

		public HostList_template constGet_field_sctpAdditionalLocalAddresses() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctpAdditionalLocalAddresses in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_sctpAdditionalLocalAddresses) {
				throw new TtcnError("Accessing non-selected field sctpAdditionalLocalAddresses in a template of union type @IPL4asp_Types.Option.");
			}
			return (HostList_template)single_value;
		}

		public TitanInteger_template get_field_sctpEINConfigGroup() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_sctpEINConfigGroup) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanInteger_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanInteger_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_sctpEINConfigGroup;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanInteger_template)single_value;
		}

		public TitanInteger_template constGet_field_sctpEINConfigGroup() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sctpEINConfigGroup in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_sctpEINConfigGroup) {
				throw new TtcnError("Accessing non-selected field sctpEINConfigGroup in a template of union type @IPL4asp_Types.Option.");
			}
			return (TitanInteger_template)single_value;
		}

		public Linger__opt_template get_field_solinger() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_solinger) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Linger__opt_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Linger__opt_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_solinger;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Linger__opt_template)single_value;
		}

		public Linger__opt_template constGet_field_solinger() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field solinger in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_solinger) {
				throw new TtcnError("Accessing non-selected field solinger in a template of union type @IPL4asp_Types.Option.");
			}
			return (Linger__opt_template)single_value;
		}

		public SSL__proto__support_template get_field_ssl__support() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_ssl__support) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new SSL__proto__support_template(template_sel.ANY_VALUE);
				} else {
					single_value = new SSL__proto__support_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_ssl__support;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (SSL__proto__support_template)single_value;
		}

		public SSL__proto__support_template constGet_field_ssl__support() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ssl_support in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_ssl__support) {
				throw new TtcnError("Accessing non-selected field ssl_support in a template of union type @IPL4asp_Types.Option.");
			}
			return (SSL__proto__support_template)single_value;
		}

		public TitanBoolean_template get_field_no__delay() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_no__delay) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanBoolean_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanBoolean_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_no__delay;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template constGet_field_no__delay() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field no_delay in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_no__delay) {
				throw new TtcnError("Accessing non-selected field no_delay in a template of union type @IPL4asp_Types.Option.");
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanCharString_template get_field_dtlsSrtpProfiles() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_dtlsSrtpProfiles) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_dtlsSrtpProfiles;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGet_field_dtlsSrtpProfiles() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field dtlsSrtpProfiles in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_dtlsSrtpProfiles) {
				throw new TtcnError("Accessing non-selected field dtlsSrtpProfiles in a template of union type @IPL4asp_Types.Option.");
			}
			return (TitanCharString_template)single_value;
		}

		public SSL__cert__options_template get_field_cert__options() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_cert__options) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new SSL__cert__options_template(template_sel.ANY_VALUE);
				} else {
					single_value = new SSL__cert__options_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_cert__options;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (SSL__cert__options_template)single_value;
		}

		public SSL__cert__options_template constGet_field_cert__options() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field cert_options in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_cert__options) {
				throw new TtcnError("Accessing non-selected field cert_options in a template of union type @IPL4asp_Types.Option.");
			}
			return (SSL__cert__options_template)single_value;
		}

		public TitanBoolean_template get_field_freebind() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_freebind) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanBoolean_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanBoolean_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_freebind;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanBoolean_template)single_value;
		}

		public TitanBoolean_template constGet_field_freebind() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field freebind in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_freebind) {
				throw new TtcnError("Accessing non-selected field freebind in a template of union type @IPL4asp_Types.Option.");
			}
			return (TitanBoolean_template)single_value;
		}

		public Option_alpn__list_template get_field_alpn__list() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_alpn__list) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Option_alpn__list_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Option_alpn__list_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_alpn__list;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Option_alpn__list_template)single_value;
		}

		public Option_alpn__list_template constGet_field_alpn__list() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field alpn_list in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_alpn__list) {
				throw new TtcnError("Accessing non-selected field alpn_list in a template of union type @IPL4asp_Types.Option.");
			}
			return (Option_alpn__list_template)single_value;
		}

		public TitanCharString_template get_field_tls__hostname() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_tls__hostname) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_tls__hostname;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGet_field_tls__hostname() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field tls_hostname in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_tls__hostname) {
				throw new TtcnError("Accessing non-selected field tls_hostname in a template of union type @IPL4asp_Types.Option.");
			}
			return (TitanCharString_template)single_value;
		}

		public UDP__ENCAP__Param_template get_field_udp__encap() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_udp__encap) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new UDP__ENCAP__Param_template(template_sel.ANY_VALUE);
				} else {
					single_value = new UDP__ENCAP__Param_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_udp__encap;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (UDP__ENCAP__Param_template)single_value;
		}

		public UDP__ENCAP__Param_template constGet_field_udp__encap() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field udp_encap in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_udp__encap) {
				throw new TtcnError("Accessing non-selected field udp_encap in a template of union type @IPL4asp_Types.Option.");
			}
			return (UDP__ENCAP__Param_template)single_value;
		}

		public TitanInteger_template get_field_dscp() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_dscp) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanInteger_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanInteger_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_dscp;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanInteger_template)single_value;
		}

		public TitanInteger_template constGet_field_dscp() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field dscp in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_dscp) {
				throw new TtcnError("Accessing non-selected field dscp in a template of union type @IPL4asp_Types.Option.");
			}
			return (TitanInteger_template)single_value;
		}

		public MTU__discover_template get_field_mtu__discover() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_mtu__discover) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new MTU__discover_template(template_sel.ANY_VALUE);
				} else {
					single_value = new MTU__discover_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_mtu__discover;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (MTU__discover_template)single_value;
		}

		public MTU__discover_template constGet_field_mtu__discover() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field mtu_discover in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_mtu__discover) {
				throw new TtcnError("Accessing non-selected field mtu_discover in a template of union type @IPL4asp_Types.Option.");
			}
			return (MTU__discover_template)single_value;
		}

		public PSK__options_template get_field_psk__options() {
			if (template_selection != template_sel.SPECIFIC_VALUE || single_value_union_selection != Option.union_selection_type.ALT_psk__options) {
				final template_sel old_selection = template_selection;
				clean_up();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new PSK__options_template(template_sel.ANY_VALUE);
				} else {
					single_value = new PSK__options_template();
				}
				single_value_union_selection = Option.union_selection_type.ALT_psk__options;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (PSK__options_template)single_value;
		}

		public PSK__options_template constGet_field_psk__options() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field psk_options in a non-specific template of union type @IPL4asp_Types.Option.");
			}
			if (single_value_union_selection != Option.union_selection_type.ALT_psk__options) {
				throw new TtcnError("Accessing non-selected field psk_options in a template of union type @IPL4asp_Types.Option.");
			}
			return (PSK__options_template)single_value;
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Option) {
				log_match((Option)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.Option.");
		}

		public void log_match(final Option match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_reuseAddress:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".reuseAddress");
						single_value.log_match(match_value.get_field_reuseAddress(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ reuseAddress := ");
						single_value.log_match(match_value.get_field_reuseAddress(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_tcpKeepAlive:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".tcpKeepAlive");
						single_value.log_match(match_value.get_field_tcpKeepAlive(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ tcpKeepAlive := ");
						single_value.log_match(match_value.get_field_tcpKeepAlive(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_sctpEventHandle:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".sctpEventHandle");
						single_value.log_match(match_value.get_field_sctpEventHandle(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ sctpEventHandle := ");
						single_value.log_match(match_value.get_field_sctpEventHandle(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_sslKeepAlive:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".sslKeepAlive");
						single_value.log_match(match_value.get_field_sslKeepAlive(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ sslKeepAlive := ");
						single_value.log_match(match_value.get_field_sslKeepAlive(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_sctpAdditionalLocalAddresses:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".sctpAdditionalLocalAddresses");
						single_value.log_match(match_value.get_field_sctpAdditionalLocalAddresses(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ sctpAdditionalLocalAddresses := ");
						single_value.log_match(match_value.get_field_sctpAdditionalLocalAddresses(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_sctpEINConfigGroup:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".sctpEINConfigGroup");
						single_value.log_match(match_value.get_field_sctpEINConfigGroup(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ sctpEINConfigGroup := ");
						single_value.log_match(match_value.get_field_sctpEINConfigGroup(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_solinger:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".solinger");
						single_value.log_match(match_value.get_field_solinger(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ solinger := ");
						single_value.log_match(match_value.get_field_solinger(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_ssl__support:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".ssl_support");
						single_value.log_match(match_value.get_field_ssl__support(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ ssl_support := ");
						single_value.log_match(match_value.get_field_ssl__support(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_no__delay:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".no_delay");
						single_value.log_match(match_value.get_field_no__delay(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ no_delay := ");
						single_value.log_match(match_value.get_field_no__delay(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_dtlsSrtpProfiles:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".dtlsSrtpProfiles");
						single_value.log_match(match_value.get_field_dtlsSrtpProfiles(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ dtlsSrtpProfiles := ");
						single_value.log_match(match_value.get_field_dtlsSrtpProfiles(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_cert__options:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".cert_options");
						single_value.log_match(match_value.get_field_cert__options(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ cert_options := ");
						single_value.log_match(match_value.get_field_cert__options(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_freebind:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".freebind");
						single_value.log_match(match_value.get_field_freebind(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ freebind := ");
						single_value.log_match(match_value.get_field_freebind(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_alpn__list:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".alpn_list");
						single_value.log_match(match_value.get_field_alpn__list(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ alpn_list := ");
						single_value.log_match(match_value.get_field_alpn__list(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_tls__hostname:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".tls_hostname");
						single_value.log_match(match_value.get_field_tls__hostname(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ tls_hostname := ");
						single_value.log_match(match_value.get_field_tls__hostname(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_udp__encap:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".udp_encap");
						single_value.log_match(match_value.get_field_udp__encap(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ udp_encap := ");
						single_value.log_match(match_value.get_field_udp__encap(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_dscp:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".dscp");
						single_value.log_match(match_value.get_field_dscp(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ dscp := ");
						single_value.log_match(match_value.get_field_dscp(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_mtu__discover:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".mtu_discover");
						single_value.log_match(match_value.get_field_mtu__discover(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ mtu_discover := ");
						single_value.log_match(match_value.get_field_mtu__discover(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_psk__options:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".psk_options");
						single_value.log_match(match_value.get_field_psk__options(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ psk_options := ");
						single_value.log_match(match_value.get_field_psk__options(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
					break;
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @IPL4asp_Types.Option.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().get_int();
				switch (temp) {
				case 0:
					single_value = new ReuseAddress_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new TcpKeepAlive_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new SctpEventHandle_template();
					single_value.decode_text(text_buf);
					break;
				case 3:
					single_value = new TcpKeepAlive_template();
					single_value.decode_text(text_buf);
					break;
				case 4:
					single_value = new HostList_template();
					single_value.decode_text(text_buf);
					break;
				case 5:
					single_value = new TitanInteger_template();
					single_value.decode_text(text_buf);
					break;
				case 6:
					single_value = new Linger__opt_template();
					single_value.decode_text(text_buf);
					break;
				case 7:
					single_value = new SSL__proto__support_template();
					single_value.decode_text(text_buf);
					break;
				case 8:
					single_value = new TitanBoolean_template();
					single_value.decode_text(text_buf);
					break;
				case 9:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				case 10:
					single_value = new SSL__cert__options_template();
					single_value.decode_text(text_buf);
					break;
				case 11:
					single_value = new TitanBoolean_template();
					single_value.decode_text(text_buf);
					break;
				case 12:
					single_value = new Option_alpn__list_template();
					single_value.decode_text(text_buf);
					break;
				case 13:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				case 14:
					single_value = new UDP__ENCAP__Param_template();
					single_value.decode_text(text_buf);
					break;
				case 15:
					single_value = new TitanInteger_template();
					single_value.decode_text(text_buf);
					break;
				case 16:
					single_value = new MTU__discover_template();
					single_value.decode_text(text_buf);
					break;
				case 17:
					single_value = new PSK__options_template();
					single_value.decode_text(text_buf);
					break;
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				value_list = new ArrayList<Option_template>(size);
				for (int i = 0; i < size; i++) {
					final Option_template temp2 = new Option_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @IPL4asp_Types.Option.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@IPL4asp_Types.Option");
				}
				if("reuseAddress".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("tcpKeepAlive".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("sctpEventHandle".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("sslKeepAlive".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("sctpAdditionalLocalAddresses".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("sctpEINConfigGroup".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("solinger".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("ssl_support".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("no_delay".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("dtlsSrtpProfiles".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("cert_options".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("freebind".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("alpn_list".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("tls_hostname".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("udp_encap".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("dscp".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("mtu_discover".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("psk_options".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@IPL4asp_Types.Option");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("reuseAddress".equals(last_name)) {
					get_field_reuseAddress().set_param(mp_last);
					break;
				}
				if("tcpKeepAlive".equals(last_name)) {
					get_field_tcpKeepAlive().set_param(mp_last);
					break;
				}
				if("sctpEventHandle".equals(last_name)) {
					get_field_sctpEventHandle().set_param(mp_last);
					break;
				}
				if("sslKeepAlive".equals(last_name)) {
					get_field_sslKeepAlive().set_param(mp_last);
					break;
				}
				if("sctpAdditionalLocalAddresses".equals(last_name)) {
					get_field_sctpAdditionalLocalAddresses().set_param(mp_last);
					break;
				}
				if("sctpEINConfigGroup".equals(last_name)) {
					get_field_sctpEINConfigGroup().set_param(mp_last);
					break;
				}
				if("solinger".equals(last_name)) {
					get_field_solinger().set_param(mp_last);
					break;
				}
				if("ssl_support".equals(last_name)) {
					get_field_ssl__support().set_param(mp_last);
					break;
				}
				if("no_delay".equals(last_name)) {
					get_field_no__delay().set_param(mp_last);
					break;
				}
				if("dtlsSrtpProfiles".equals(last_name)) {
					get_field_dtlsSrtpProfiles().set_param(mp_last);
					break;
				}
				if("cert_options".equals(last_name)) {
					get_field_cert__options().set_param(mp_last);
					break;
				}
				if("freebind".equals(last_name)) {
					get_field_freebind().set_param(mp_last);
					break;
				}
				if("alpn_list".equals(last_name)) {
					get_field_alpn__list().set_param(mp_last);
					break;
				}
				if("tls_hostname".equals(last_name)) {
					get_field_tls__hostname().set_param(mp_last);
					break;
				}
				if("udp_encap".equals(last_name)) {
					get_field_udp__encap().set_param(mp_last);
					break;
				}
				if("dscp".equals(last_name)) {
					get_field_dscp().set_param(mp_last);
					break;
				}
				if("mtu_discover".equals(last_name)) {
					get_field_mtu__discover().set_param(mp_last);
					break;
				}
				if("psk_options".equals(last_name)) {
					get_field_psk__options().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @IPL4asp_Types.Option.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@IPL4asp_Types.Option");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_reuseAddress:
					((ReuseAddress_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_tcpKeepAlive:
					((TcpKeepAlive_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_sctpEventHandle:
					((SctpEventHandle_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_sslKeepAlive:
					((TcpKeepAlive_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_sctpAdditionalLocalAddresses:
					((HostList_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_sctpEINConfigGroup:
					((TitanInteger_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_solinger:
					((Linger__opt_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_ssl__support:
					((SSL__proto__support_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_no__delay:
					((TitanBoolean_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_dtlsSrtpProfiles:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_cert__options:
					((SSL__cert__options_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_freebind:
					((TitanBoolean_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_alpn__list:
					((Option_alpn__list_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_tls__hostname:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_udp__encap:
					((UDP__ENCAP__Param_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_dscp:
					((TitanInteger_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_mtu__discover:
					((MTU__discover_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				case ALT_psk__options:
					((PSK__options_template)single_value).check_restriction(restriction, name == null ? "@IPL4asp_Types.Option" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @IPL4asp_Types.Option.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.Option" : name));
		}
	}
	public static class ro__charstring extends Socket__API__Definitions.ro__charstring { }
	public static class ro__charstring_template extends Socket__API__Definitions.ro__charstring_template { }
	public static class PortNumber extends TitanInteger { }
	public static class PortNumber_template extends TitanInteger_template { }
	public static class PSK__options extends Base_Type {
		private final Optional<TitanCharString> psk__identity;
		private final Optional<TitanCharString> psk__identity__hint;
		private final Optional<TitanCharString> psk__key;

		public PSK__options() {
			this.psk__identity = new Optional<TitanCharString>(TitanCharString.class);
			this.psk__identity__hint = new Optional<TitanCharString>(TitanCharString.class);
			this.psk__key = new Optional<TitanCharString>(TitanCharString.class);
		}

		public PSK__options(final Optional<TitanCharString> psk__identity, final Optional<TitanCharString> psk__identity__hint, final Optional<TitanCharString> psk__key ) {
			this.psk__identity = new Optional<TitanCharString>(TitanCharString.class);
			this.psk__identity.operator_assign( psk__identity );
			this.psk__identity__hint = new Optional<TitanCharString>(TitanCharString.class);
			this.psk__identity__hint.operator_assign( psk__identity__hint );
			this.psk__key = new Optional<TitanCharString>(TitanCharString.class);
			this.psk__key.operator_assign( psk__key );
		}

		public PSK__options( final PSK__options otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.PSK_options.");
			psk__identity = new Optional<TitanCharString>(TitanCharString.class);
			psk__identity__hint = new Optional<TitanCharString>(TitanCharString.class);
			psk__key = new Optional<TitanCharString>(TitanCharString.class);
			operator_assign( otherValue );
		}

		public PSK__options operator_assign(final PSK__options otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.PSK_options");
			if (otherValue != this) {
				if ( otherValue.get_field_psk__identity().is_bound() ) {
					this.psk__identity.operator_assign( otherValue.get_field_psk__identity() );
				} else {
					this.psk__identity.clean_up();
				}
				if ( otherValue.get_field_psk__identity__hint().is_bound() ) {
					this.psk__identity__hint.operator_assign( otherValue.get_field_psk__identity__hint() );
				} else {
					this.psk__identity__hint.clean_up();
				}
				if ( otherValue.get_field_psk__key().is_bound() ) {
					this.psk__key.operator_assign( otherValue.get_field_psk__key() );
				} else {
					this.psk__key.clean_up();
				}
			}

			return this;
		}

		@Override
		public PSK__options operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PSK__options ) {
				return operator_assign((PSK__options) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.PSK_options", otherValue));
		}

		@Override
		public void clean_up() {
			psk__identity.clean_up();
			psk__identity__hint.clean_up();
			psk__key.clean_up();
		}

		@Override
		public boolean is_bound() {
			return optional_sel.OPTIONAL_OMIT.equals(psk__identity.get_selection()) || psk__identity.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(psk__identity__hint.get_selection()) || psk__identity__hint.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(psk__key.get_selection()) || psk__key.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return (optional_sel.OPTIONAL_OMIT.equals(psk__identity.get_selection()) || psk__identity.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(psk__identity__hint.get_selection()) || psk__identity__hint.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(psk__key.get_selection()) || psk__key.is_value());
		}

		public boolean operator_equals( final PSK__options other_value) {
			return psk__identity.operator_equals( other_value.psk__identity )
					&& psk__identity__hint.operator_equals( other_value.psk__identity__hint )
					&& psk__key.operator_equals( other_value.psk__key );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PSK__options ) {
				return operator_equals((PSK__options) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.PSK_options", other_value));
		}

		public Optional<TitanCharString> get_field_psk__identity() {
			return psk__identity;
		}

		public Optional<TitanCharString> constGet_field_psk__identity() {
			return psk__identity;
		}

		public Optional<TitanCharString> get_field_psk__identity__hint() {
			return psk__identity__hint;
		}

		public Optional<TitanCharString> constGet_field_psk__identity__hint() {
			return psk__identity__hint;
		}

		public Optional<TitanCharString> get_field_psk__key() {
			return psk__key;
		}

		public Optional<TitanCharString> constGet_field_psk__key() {
			return psk__key;
		}

		public TitanInteger size_of() {
			int sizeof = 0;
			if (psk__identity.ispresent()) {
				sizeof++;
			}
			if (psk__identity__hint.ispresent()) {
				sizeof++;
			}
			if (psk__key.ispresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" psk_identity := ");
			psk__identity.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" psk_identity_hint := ");
			psk__identity__hint.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" psk_key := ");
			psk__key.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.PSK_options has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_psk__identity().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_psk__identity__hint().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_psk__key().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("psk_identity".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_psk__identity().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("psk_identity_hint".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_psk__identity__hint().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("psk_key".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_psk__key().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.PSK_options: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.PSK_options");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (psk__identity.is_bound()) {
				psk__identity.set_implicit_omit();
			} else {
				psk__identity.operator_assign(template_sel.OMIT_VALUE);
			}
			if (psk__identity__hint.is_bound()) {
				psk__identity__hint.set_implicit_omit();
			} else {
				psk__identity__hint.operator_assign(template_sel.OMIT_VALUE);
			}
			if (psk__key.is_bound()) {
				psk__key.set_implicit_omit();
			} else {
				psk__key.operator_assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			psk__identity.encode_text(text_buf);
			psk__identity__hint.encode_text(text_buf);
			psk__key.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			psk__identity.decode_text(text_buf);
			psk__identity__hint.decode_text(text_buf);
			psk__key.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class PSK__options_template extends Base_Template {
		private TitanCharString_template psk__identity;
		private TitanCharString_template psk__identity__hint;
		private TitanCharString_template psk__key;
		//originally value_list/list_value
		private List<PSK__options_template> list_value;


		public PSK__options_template() {
			// do nothing
		}

		public PSK__options_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public PSK__options_template( final PSK__options otherValue ) {
			copy_value(otherValue);
		}

		public PSK__options_template( final PSK__options_template otherValue ) {
			copy_template( otherValue );
		}

		public PSK__options_template( final Optional<PSK__options> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.PSK_options from an unbound optional field.");
			}
		}

		@Override
		public PSK__options_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public PSK__options_template operator_assign( final PSK__options otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public PSK__options_template operator_assign( final PSK__options_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PSK__options_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PSK__options) {
				return operator_assign((PSK__options) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PSK__options' can not be cast to {1}", otherValue));
		}

		@Override
		public PSK__options_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PSK__options_template) {
				return operator_assign((PSK__options_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PSK__options' can not be cast to {1}_template", otherValue));
		}

		public PSK__options_template operator_assign( final Optional<PSK__options> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.PSK_options.");
			}
			return this;
		}

		private void copy_value(final PSK__options other_value) {
			if (other_value.get_field_psk__identity().is_bound()) {
				if (other_value.get_field_psk__identity().ispresent()) {
					get_field_psk__identity().operator_assign(other_value.get_field_psk__identity().get());
				} else {
					get_field_psk__identity().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_psk__identity().clean_up();
			}
			if (other_value.get_field_psk__identity__hint().is_bound()) {
				if (other_value.get_field_psk__identity__hint().ispresent()) {
					get_field_psk__identity__hint().operator_assign(other_value.get_field_psk__identity__hint().get());
				} else {
					get_field_psk__identity__hint().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_psk__identity__hint().clean_up();
			}
			if (other_value.get_field_psk__key().is_bound()) {
				if (other_value.get_field_psk__key().ispresent()) {
					get_field_psk__key().operator_assign(other_value.get_field_psk__key().get());
				} else {
					get_field_psk__key().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_psk__key().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final PSK__options_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_psk__identity().get_selection()) {
					get_field_psk__identity().clean_up();
				} else {
					get_field_psk__identity().operator_assign(other_value.get_field_psk__identity());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_psk__identity__hint().get_selection()) {
					get_field_psk__identity__hint().clean_up();
				} else {
					get_field_psk__identity__hint().operator_assign(other_value.get_field_psk__identity__hint());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_psk__key().get_selection()) {
					get_field_psk__key().clean_up();
				} else {
					get_field_psk__key().operator_assign(other_value.get_field_psk__key());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PSK__options_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PSK__options_template temp = new PSK__options_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.PSK_options.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.PSK_options.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<PSK__options_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new PSK__options_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return psk__identity.is_omit() || psk__identity.is_bound()
					|| psk__identity__hint.is_omit() || psk__identity__hint.is_bound()
					|| psk__key.is_omit() || psk__key.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return (psk__identity.is_omit() || psk__identity.is_value())
					&& (psk__identity__hint.is_omit() || psk__identity__hint.is_value())
					&& (psk__key.is_omit() || psk__key.is_value());
		}
		public TitanCharString_template get_field_psk__identity() {
			set_specific();
			return psk__identity;
		}

		public TitanCharString_template constGet_field_psk__identity() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field psk_identity of a non-specific template of type @IPL4asp_Types.PSK_options.");
			}
			return psk__identity;
		}

		public TitanCharString_template get_field_psk__identity__hint() {
			set_specific();
			return psk__identity__hint;
		}

		public TitanCharString_template constGet_field_psk__identity__hint() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field psk_identity_hint of a non-specific template of type @IPL4asp_Types.PSK_options.");
			}
			return psk__identity__hint;
		}

		public TitanCharString_template get_field_psk__key() {
			set_specific();
			return psk__key;
		}

		public TitanCharString_template constGet_field_psk__key() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field psk_key of a non-specific template of type @IPL4asp_Types.PSK_options.");
			}
			return psk__key;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					psk__identity = new TitanCharString_template(template_sel.ANY_OR_OMIT);
					psk__identity__hint = new TitanCharString_template(template_sel.ANY_OR_OMIT);
					psk__key = new TitanCharString_template(template_sel.ANY_OR_OMIT);
				} else {
					psk__identity = new TitanCharString_template();
					psk__identity__hint = new TitanCharString_template();
					psk__key = new TitanCharString_template();
				}
			}
		}
		public boolean match(final PSK__options other_value) {
			return match(other_value, false);
		}

		public boolean match(final PSK__options other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_psk__identity().is_bound()) {
					return false;
				}
				if((other_value.get_field_psk__identity().ispresent() ? !psk__identity.match(other_value.get_field_psk__identity().get(), legacy) : !psk__identity.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_psk__identity__hint().is_bound()) {
					return false;
				}
				if((other_value.get_field_psk__identity__hint().ispresent() ? !psk__identity__hint.match(other_value.get_field_psk__identity__hint().get(), legacy) : !psk__identity__hint.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_psk__key().is_bound()) {
					return false;
				}
				if((other_value.get_field_psk__key().ispresent() ? !psk__key.match(other_value.get_field_psk__key().get(), legacy) : !psk__key.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.PSK_options.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PSK__options) {
				return match((PSK__options)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PSK__options.");
		}


		@Override
		public PSK__options valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.PSK_options.");
			}
			final PSK__options ret_val = new PSK__options();
			if (psk__identity.is_omit()) {
				ret_val.get_field_psk__identity().operator_assign(template_sel.OMIT_VALUE);
			} else if (psk__identity.is_bound()) {
				ret_val.get_field_psk__identity().operator_assign(psk__identity.valueof());
			}
			if (psk__identity__hint.is_omit()) {
				ret_val.get_field_psk__identity__hint().operator_assign(template_sel.OMIT_VALUE);
			} else if (psk__identity__hint.is_bound()) {
				ret_val.get_field_psk__identity__hint().operator_assign(psk__identity__hint.valueof());
			}
			if (psk__key.is_omit()) {
				ret_val.get_field_psk__key().operator_assign(template_sel.OMIT_VALUE);
			} else if (psk__key.is_bound()) {
				ret_val.get_field_psk__key().operator_assign(psk__key.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.PSK_options which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				int sizeof = 0;
				if (psk__identity.is_present()) {
					sizeof++;
				}
				if (psk__identity__hint.is_present()) {
					sizeof++;
				}
				if (psk__key.is_present()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.PSK_options containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.PSK_options containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.PSK_options containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.PSK_options containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.PSK_options containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.PSK_options.");
			}
		}

		@Override
		public PSK__options_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.PSK_options.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.PSK_options using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.PSK_options.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" psk_identity := ");
				psk__identity.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" psk_identity_hint := ");
				psk__identity__hint.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" psk_key := ");
				psk__key.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final PSK__options match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PSK__options) {
				log_match((PSK__options)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.PSK_options.");
		}

		public void log_match(final PSK__options match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if (match_value.constGet_field_psk__identity().ispresent()) {
							if( !psk__identity.match(match_value.constGet_field_psk__identity().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".psk_identity");
								psk__identity.log_match(match_value.constGet_field_psk__identity().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!psk__identity.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".psk_identity := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								psk__identity.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_psk__identity__hint().ispresent()) {
							if( !psk__identity__hint.match(match_value.constGet_field_psk__identity__hint().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".psk_identity_hint");
								psk__identity__hint.log_match(match_value.constGet_field_psk__identity__hint().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!psk__identity__hint.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".psk_identity_hint := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								psk__identity__hint.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_psk__key().ispresent()) {
							if( !psk__key.match(match_value.constGet_field_psk__key().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".psk_key");
								psk__key.log_match(match_value.constGet_field_psk__key().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!psk__key.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".psk_key := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								psk__key.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ psk_identity := ");
				psk__identity.log_match(match_value.constGet_field_psk__identity(), legacy);
				TTCN_Logger.log_event_str("{ psk_identity_hint := ");
				psk__identity__hint.log_match(match_value.constGet_field_psk__identity__hint(), legacy);
				TTCN_Logger.log_event_str("{ psk_key := ");
				psk__key.log_match(match_value.constGet_field_psk__key(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				psk__identity.encode_text(text_buf);
				psk__identity__hint.encode_text(text_buf);
				psk__key.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.PSK_options.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				psk__identity = new TitanCharString_template();
				psk__identity.decode_text(text_buf);
				psk__identity__hint = new TitanCharString_template();
				psk__identity__hint.decode_text(text_buf);
				psk__key = new TitanCharString_template();
				psk__key.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PSK__options_template>(size);
				for (int i = 0; i < size; i++) {
					final PSK__options_template temp = new PSK__options_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.PSK_options.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.PSK_options has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_psk__identity().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_psk__identity__hint().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_psk__key().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("psk_identity".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_psk__identity().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("psk_identity_hint".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_psk__identity__hint().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("psk_key".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_psk__key().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.PSK_options: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.PSK_options");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.psk__identity.check_restriction(restriction, name == null ? "@IPL4asp_Types.PSK_options" : name, legacy);
				this.psk__identity__hint.check_restriction(restriction, name == null ? "@IPL4asp_Types.PSK_options" : name, legacy);
				this.psk__key.check_restriction(restriction, name == null ? "@IPL4asp_Types.PSK_options" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.PSK_options" : name));
		}
	}
	public static class ASP__Event extends Socket__API__Definitions.PortEvent { }
	public static class ASP__Event_template extends Socket__API__Definitions.PortEvent_template { }
	public static class UserData extends TitanInteger { }
	public static class UserData_template extends TitanInteger_template { }
	public static class SctpShutDownEvent extends Socket__API__Definitions.SctpShutDownEvent { }
	public static class SctpShutDownEvent_template extends Socket__API__Definitions.SctpShutDownEvent_template { }
	public static class ConnectionOpenedEvent extends Socket__API__Definitions.ConnectionOpenedEvent { }
	public static class ConnectionOpenedEvent_template extends Socket__API__Definitions.ConnectionOpenedEvent_template { }
	public static class ConnectionId extends TitanInteger { }
	public static class ConnectionId_template extends TitanInteger_template { }
	public static class f__IPL4__getMsgLen extends Socket__API__Definitions.f__getMsgLen { }
	public static class f__IPL4__getMsgLen_template extends Socket__API__Definitions.f__getMsgLen_template { }
	public static class ro__AssociationId extends Socket__API__Definitions.ro__AssociationId { }
	public static class ro__AssociationId_template extends Socket__API__Definitions.ro__AssociationId_template { }
	public static class IPL4__SrtpKeysAndSalts extends Base_Type {
		private final TitanOctetString localKey;
		private final TitanOctetString remoteKey;
		private final TitanOctetString localSalt;
		private final TitanOctetString remoteSalt;

		public IPL4__SrtpKeysAndSalts() {
			this.localKey = new TitanOctetString();
			this.remoteKey = new TitanOctetString();
			this.localSalt = new TitanOctetString();
			this.remoteSalt = new TitanOctetString();
		}

		public IPL4__SrtpKeysAndSalts(final TitanOctetString localKey, final TitanOctetString remoteKey, final TitanOctetString localSalt, final TitanOctetString remoteSalt ) {
			this.localKey = new TitanOctetString( localKey );
			this.remoteKey = new TitanOctetString( remoteKey );
			this.localSalt = new TitanOctetString( localSalt );
			this.remoteSalt = new TitanOctetString( remoteSalt );
		}

		public IPL4__SrtpKeysAndSalts( final IPL4__SrtpKeysAndSalts otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			localKey = new TitanOctetString();
			remoteKey = new TitanOctetString();
			localSalt = new TitanOctetString();
			remoteSalt = new TitanOctetString();
			operator_assign( otherValue );
		}

		public IPL4__SrtpKeysAndSalts operator_assign(final IPL4__SrtpKeysAndSalts otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts");
			if (otherValue != this) {
				if ( otherValue.get_field_localKey().is_bound() ) {
					this.localKey.operator_assign( otherValue.get_field_localKey() );
				} else {
					this.localKey.clean_up();
				}
				if ( otherValue.get_field_remoteKey().is_bound() ) {
					this.remoteKey.operator_assign( otherValue.get_field_remoteKey() );
				} else {
					this.remoteKey.clean_up();
				}
				if ( otherValue.get_field_localSalt().is_bound() ) {
					this.localSalt.operator_assign( otherValue.get_field_localSalt() );
				} else {
					this.localSalt.clean_up();
				}
				if ( otherValue.get_field_remoteSalt().is_bound() ) {
					this.remoteSalt.operator_assign( otherValue.get_field_remoteSalt() );
				} else {
					this.remoteSalt.clean_up();
				}
			}

			return this;
		}

		@Override
		public IPL4__SrtpKeysAndSalts operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof IPL4__SrtpKeysAndSalts ) {
				return operator_assign((IPL4__SrtpKeysAndSalts) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.IPL4_SrtpKeysAndSalts", otherValue));
		}

		@Override
		public void clean_up() {
			localKey.clean_up();
			remoteKey.clean_up();
			localSalt.clean_up();
			remoteSalt.clean_up();
		}

		@Override
		public boolean is_bound() {
			return localKey.is_bound()
					|| remoteKey.is_bound()
					|| localSalt.is_bound()
					|| remoteSalt.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return localKey.is_value()
					&& remoteKey.is_value()
					&& localSalt.is_value()
					&& remoteSalt.is_value();
		}

		public boolean operator_equals( final IPL4__SrtpKeysAndSalts other_value) {
			return localKey.operator_equals( other_value.localKey )
					&& remoteKey.operator_equals( other_value.remoteKey )
					&& localSalt.operator_equals( other_value.localSalt )
					&& remoteSalt.operator_equals( other_value.remoteSalt );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof IPL4__SrtpKeysAndSalts ) {
				return operator_equals((IPL4__SrtpKeysAndSalts) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.IPL4_SrtpKeysAndSalts", other_value));
		}

		public TitanOctetString get_field_localKey() {
			return localKey;
		}

		public TitanOctetString constGet_field_localKey() {
			return localKey;
		}

		public TitanOctetString get_field_remoteKey() {
			return remoteKey;
		}

		public TitanOctetString constGet_field_remoteKey() {
			return remoteKey;
		}

		public TitanOctetString get_field_localSalt() {
			return localSalt;
		}

		public TitanOctetString constGet_field_localSalt() {
			return localSalt;
		}

		public TitanOctetString get_field_remoteSalt() {
			return remoteSalt;
		}

		public TitanOctetString constGet_field_remoteSalt() {
			return remoteSalt;
		}

		public TitanInteger size_of() {
			return new TitanInteger(4);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" localKey := ");
			localKey.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" remoteKey := ");
			remoteKey.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" localSalt := ");
			localSalt.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" remoteSalt := ");
			remoteSalt.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_localKey().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remoteKey().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_localSalt().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remoteSalt().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("localKey".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_localKey().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remoteKey".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remoteKey().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("localSalt".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_localSalt().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remoteSalt".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remoteSalt().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.IPL4_SrtpKeysAndSalts: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.IPL4_SrtpKeysAndSalts");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (localKey.is_bound()) {
				localKey.set_implicit_omit();
			}
			if (remoteKey.is_bound()) {
				remoteKey.set_implicit_omit();
			}
			if (localSalt.is_bound()) {
				localSalt.set_implicit_omit();
			}
			if (remoteSalt.is_bound()) {
				remoteSalt.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			localKey.encode_text(text_buf);
			remoteKey.encode_text(text_buf);
			localSalt.encode_text(text_buf);
			remoteSalt.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			localKey.decode_text(text_buf);
			remoteKey.decode_text(text_buf);
			localSalt.decode_text(text_buf);
			remoteSalt.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class IPL4__SrtpKeysAndSalts_template extends Base_Template {
		private TitanOctetString_template localKey;
		private TitanOctetString_template remoteKey;
		private TitanOctetString_template localSalt;
		private TitanOctetString_template remoteSalt;
		//originally value_list/list_value
		private List<IPL4__SrtpKeysAndSalts_template> list_value;


		public IPL4__SrtpKeysAndSalts_template() {
			// do nothing
		}

		public IPL4__SrtpKeysAndSalts_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public IPL4__SrtpKeysAndSalts_template( final IPL4__SrtpKeysAndSalts otherValue ) {
			copy_value(otherValue);
		}

		public IPL4__SrtpKeysAndSalts_template( final IPL4__SrtpKeysAndSalts_template otherValue ) {
			copy_template( otherValue );
		}

		public IPL4__SrtpKeysAndSalts_template( final Optional<IPL4__SrtpKeysAndSalts> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts from an unbound optional field.");
			}
		}

		@Override
		public IPL4__SrtpKeysAndSalts_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public IPL4__SrtpKeysAndSalts_template operator_assign( final IPL4__SrtpKeysAndSalts otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public IPL4__SrtpKeysAndSalts_template operator_assign( final IPL4__SrtpKeysAndSalts_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public IPL4__SrtpKeysAndSalts_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof IPL4__SrtpKeysAndSalts) {
				return operator_assign((IPL4__SrtpKeysAndSalts) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `IPL4__SrtpKeysAndSalts' can not be cast to {1}", otherValue));
		}

		@Override
		public IPL4__SrtpKeysAndSalts_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof IPL4__SrtpKeysAndSalts_template) {
				return operator_assign((IPL4__SrtpKeysAndSalts_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `IPL4__SrtpKeysAndSalts' can not be cast to {1}_template", otherValue));
		}

		public IPL4__SrtpKeysAndSalts_template operator_assign( final Optional<IPL4__SrtpKeysAndSalts> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
			return this;
		}

		private void copy_value(final IPL4__SrtpKeysAndSalts other_value) {
			if (other_value.get_field_localKey().is_bound()) {
				get_field_localKey().operator_assign(other_value.get_field_localKey());
			} else {
				get_field_localKey().clean_up();
			}
			if (other_value.get_field_remoteKey().is_bound()) {
				get_field_remoteKey().operator_assign(other_value.get_field_remoteKey());
			} else {
				get_field_remoteKey().clean_up();
			}
			if (other_value.get_field_localSalt().is_bound()) {
				get_field_localSalt().operator_assign(other_value.get_field_localSalt());
			} else {
				get_field_localSalt().clean_up();
			}
			if (other_value.get_field_remoteSalt().is_bound()) {
				get_field_remoteSalt().operator_assign(other_value.get_field_remoteSalt());
			} else {
				get_field_remoteSalt().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final IPL4__SrtpKeysAndSalts_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_localKey().get_selection()) {
					get_field_localKey().clean_up();
				} else {
					get_field_localKey().operator_assign(other_value.get_field_localKey());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_remoteKey().get_selection()) {
					get_field_remoteKey().clean_up();
				} else {
					get_field_remoteKey().operator_assign(other_value.get_field_remoteKey());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_localSalt().get_selection()) {
					get_field_localSalt().clean_up();
				} else {
					get_field_localSalt().operator_assign(other_value.get_field_localSalt());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_remoteSalt().get_selection()) {
					get_field_remoteSalt().clean_up();
				} else {
					get_field_remoteSalt().operator_assign(other_value.get_field_remoteSalt());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<IPL4__SrtpKeysAndSalts_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final IPL4__SrtpKeysAndSalts_template temp = new IPL4__SrtpKeysAndSalts_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<IPL4__SrtpKeysAndSalts_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new IPL4__SrtpKeysAndSalts_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return localKey.is_bound()
					|| remoteKey.is_bound()
					|| localSalt.is_bound()
					|| remoteSalt.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return localKey.is_value()
					&& remoteKey.is_value()
					&& localSalt.is_value()
					&& remoteSalt.is_value();
		}
		public TitanOctetString_template get_field_localKey() {
			set_specific();
			return localKey;
		}

		public TitanOctetString_template constGet_field_localKey() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field localKey of a non-specific template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
			return localKey;
		}

		public TitanOctetString_template get_field_remoteKey() {
			set_specific();
			return remoteKey;
		}

		public TitanOctetString_template constGet_field_remoteKey() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field remoteKey of a non-specific template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
			return remoteKey;
		}

		public TitanOctetString_template get_field_localSalt() {
			set_specific();
			return localSalt;
		}

		public TitanOctetString_template constGet_field_localSalt() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field localSalt of a non-specific template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
			return localSalt;
		}

		public TitanOctetString_template get_field_remoteSalt() {
			set_specific();
			return remoteSalt;
		}

		public TitanOctetString_template constGet_field_remoteSalt() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field remoteSalt of a non-specific template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
			return remoteSalt;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					localKey = new TitanOctetString_template(template_sel.ANY_VALUE);
					remoteKey = new TitanOctetString_template(template_sel.ANY_VALUE);
					localSalt = new TitanOctetString_template(template_sel.ANY_VALUE);
					remoteSalt = new TitanOctetString_template(template_sel.ANY_VALUE);
				} else {
					localKey = new TitanOctetString_template();
					remoteKey = new TitanOctetString_template();
					localSalt = new TitanOctetString_template();
					remoteSalt = new TitanOctetString_template();
				}
			}
		}
		public boolean match(final IPL4__SrtpKeysAndSalts other_value) {
			return match(other_value, false);
		}

		public boolean match(final IPL4__SrtpKeysAndSalts other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_localKey().is_bound()) {
					return false;
				}
				if(!localKey.match(other_value.get_field_localKey(), legacy)) {
					return false;
				}
				if(!other_value.get_field_remoteKey().is_bound()) {
					return false;
				}
				if(!remoteKey.match(other_value.get_field_remoteKey(), legacy)) {
					return false;
				}
				if(!other_value.get_field_localSalt().is_bound()) {
					return false;
				}
				if(!localSalt.match(other_value.get_field_localSalt(), legacy)) {
					return false;
				}
				if(!other_value.get_field_remoteSalt().is_bound()) {
					return false;
				}
				if(!remoteSalt.match(other_value.get_field_remoteSalt(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof IPL4__SrtpKeysAndSalts) {
				return match((IPL4__SrtpKeysAndSalts)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type IPL4__SrtpKeysAndSalts.");
		}


		@Override
		public IPL4__SrtpKeysAndSalts valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
			final IPL4__SrtpKeysAndSalts ret_val = new IPL4__SrtpKeysAndSalts();
			if (localKey.is_bound()) {
				ret_val.get_field_localKey().operator_assign(localKey.valueof());
			}
			if (remoteKey.is_bound()) {
				ret_val.get_field_remoteKey().operator_assign(remoteKey.valueof());
			}
			if (localSalt.is_bound()) {
				ret_val.get_field_localSalt().operator_assign(localSalt.valueof());
			}
			if (remoteSalt.is_bound()) {
				ret_val.get_field_remoteSalt().operator_assign(remoteSalt.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(4);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
		}

		@Override
		public IPL4__SrtpKeysAndSalts_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" localKey := ");
				localKey.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" remoteKey := ");
				remoteKey.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" localSalt := ");
				localSalt.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" remoteSalt := ");
				remoteSalt.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final IPL4__SrtpKeysAndSalts match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof IPL4__SrtpKeysAndSalts) {
				log_match((IPL4__SrtpKeysAndSalts)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
		}

		public void log_match(final IPL4__SrtpKeysAndSalts match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !localKey.match(match_value.constGet_field_localKey(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".localKey");
							localKey.log_match(match_value.constGet_field_localKey(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !remoteKey.match(match_value.constGet_field_remoteKey(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".remoteKey");
							remoteKey.log_match(match_value.constGet_field_remoteKey(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !localSalt.match(match_value.constGet_field_localSalt(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".localSalt");
							localSalt.log_match(match_value.constGet_field_localSalt(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !remoteSalt.match(match_value.constGet_field_remoteSalt(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".remoteSalt");
							remoteSalt.log_match(match_value.constGet_field_remoteSalt(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ localKey := ");
				localKey.log_match(match_value.constGet_field_localKey(), legacy);
				TTCN_Logger.log_event_str("{ remoteKey := ");
				remoteKey.log_match(match_value.constGet_field_remoteKey(), legacy);
				TTCN_Logger.log_event_str("{ localSalt := ");
				localSalt.log_match(match_value.constGet_field_localSalt(), legacy);
				TTCN_Logger.log_event_str("{ remoteSalt := ");
				remoteSalt.log_match(match_value.constGet_field_remoteSalt(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				localKey.encode_text(text_buf);
				remoteKey.encode_text(text_buf);
				localSalt.encode_text(text_buf);
				remoteSalt.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				localKey = new TitanOctetString_template();
				localKey.decode_text(text_buf);
				remoteKey = new TitanOctetString_template();
				remoteKey.decode_text(text_buf);
				localSalt = new TitanOctetString_template();
				localSalt.decode_text(text_buf);
				remoteSalt = new TitanOctetString_template();
				remoteSalt.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<IPL4__SrtpKeysAndSalts_template>(size);
				for (int i = 0; i < size; i++) {
					final IPL4__SrtpKeysAndSalts_template temp = new IPL4__SrtpKeysAndSalts_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_localKey().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remoteKey().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_localSalt().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_remoteSalt().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("localKey".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_localKey().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remoteKey".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remoteKey().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("localSalt".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_localSalt().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remoteSalt".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_remoteSalt().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.IPL4_SrtpKeysAndSalts: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.IPL4_SrtpKeysAndSalts");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.localKey.check_restriction(restriction, name == null ? "@IPL4asp_Types.IPL4_SrtpKeysAndSalts" : name, legacy);
				this.remoteKey.check_restriction(restriction, name == null ? "@IPL4asp_Types.IPL4_SrtpKeysAndSalts" : name, legacy);
				this.localSalt.check_restriction(restriction, name == null ? "@IPL4asp_Types.IPL4_SrtpKeysAndSalts" : name, legacy);
				this.remoteSalt.check_restriction(restriction, name == null ? "@IPL4asp_Types.IPL4_SrtpKeysAndSalts" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.IPL4_SrtpKeysAndSalts" : name));
		}
	}
	public static class anytype extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE };
		private union_selection_type union_selection;

		public anytype() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};

		public anytype(final anytype otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final anytype other_value) {
			union_selection = other_value.union_selection;
		}

		public anytype operator_assign( final anytype otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_value(otherValue);
			}

			return this;
		}

		@Override
		public anytype operator_assign( final Base_Type otherValue ) {
			if (otherValue instanceof anytype) {
				return operator_assign((anytype)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.anytype.");
		}

		@Override
		public void clean_up() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean ischosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.anytype.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean is_bound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean is_value() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		public boolean operator_equals( final anytype otherValue ) {
			must_bound( "The left operand of comparison is an unbound value of union type @IPL4asp_Types.anytype." );
			otherValue.must_bound( "The right operand of comparison is an unbound value of union type @IPL4asp_Types.anytype." );
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			default:
				return false;
			}
		}

		@Override
		public boolean operator_equals( final Base_Type otherValue ) {
			if (otherValue instanceof anytype) {
				return operator_equals((anytype)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.anytype.");
		}

		public boolean operator_not_equals( final anytype otherValue ) {
			return !operator_equals(otherValue);
		}

		public union_selection_type get_selection() {
			return union_selection;
		}

		@Override
		public void log() {
			switch (union_selection) {
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @IPL4asp_Types.anytype.", last_name));
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @IPL4asp_Types.anytype.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().get_int();
			switch (temp) {
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @IPL4asp_Types.anytype.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class anytype_template extends Base_Template {
		//if single value which value?
		private anytype.union_selection_type single_value_union_selection;
		// value_list part
		private ArrayList<anytype_template> value_list;

		private void copy_value(final anytype other_value) {
			single_value_union_selection = other_value.get_selection();
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final anytype_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<anytype_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final anytype_template temp = new anytype_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @IPL4asp_Types.anytype.");
			}
			set_selection(other_value);
		}

		public anytype_template() {
			// do nothing
		}
		public anytype_template(final template_sel other_value) {
			super(other_value);
			check_single_selection(other_value);
		}
		public anytype_template(final anytype other_value) {
			copy_value(other_value);
		}
		public anytype_template(final anytype_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		@Override
		public anytype_template operator_assign(final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public anytype_template operator_assign(final anytype otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public anytype_template operator_assign(final anytype_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public anytype_template operator_assign(final Base_Type otherValue ) {
			if (otherValue instanceof anytype) {
				return operator_assign((anytype)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to anytype.");
		}

		@Override
		public anytype_template operator_assign(final Base_Template otherValue ) {
			if (otherValue instanceof anytype_template) {
				return operator_assign((anytype_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to anytype_template.");
		}

		public boolean match(final anytype other_value) {
			return match(other_value, false);
		}

		public boolean match(final anytype other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final anytype.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == anytype.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @IPL4asp_Types.anytype.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof anytype) {
				return match((anytype)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type anytype.");
		}

		public boolean ischosen(final anytype.union_selection_type checked_selection) {
			if(checked_selection == anytype.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.anytype.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == anytype.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @IPL4asp_Types.anytype.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @IPL4asp_Types.anytype containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).ischosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @IPL4asp_Types.anytype.");
			}
		}

		@Override
		public anytype valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @IPL4asp_Types.anytype.");
			}
			switch (single_value_union_selection) {
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @IPL4asp_Types.anytype.");
			}
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @IPL4asp_Types.anytype.");
			}
			clean_up();
			set_selection(template_type);
			value_list = new ArrayList<anytype_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new anytype_template());
			}
		}

		@Override
		public anytype_template list_item(final int list_index)  {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @IPL4asp_Types.anytype.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.anytype using a negative index ({0}).", list_index));
			} else if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @IPL4asp_Types.anytype.");
			}
			return value_list.get(list_index);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof anytype) {
				log_match((anytype)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.anytype.");
		}

		public void log_match(final anytype match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
					break;
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @IPL4asp_Types.anytype.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().get_int();
				switch (temp) {
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				value_list = new ArrayList<anytype_template>(size);
				for (int i = 0; i < size; i++) {
					final anytype_template temp2 = new anytype_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @IPL4asp_Types.anytype.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@IPL4asp_Types.anytype");
				}
 else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@IPL4asp_Types.anytype");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @IPL4asp_Types.anytype.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@IPL4asp_Types.anytype");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @IPL4asp_Types.anytype.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.anytype" : name));
		}
	}
	public static class PortEvent extends Socket__API__Definitions.PortEvent { }
	public static class PortEvent_template extends Socket__API__Definitions.PortEvent_template { }
	public static class TcpKeepAlive extends Base_Type {
		private final Optional<TitanBoolean> enable;
		private final Optional<TitanInteger> count;
		private final Optional<TitanInteger> idle;
		private final Optional<TitanInteger> interval;

		public TcpKeepAlive() {
			this.enable = new Optional<TitanBoolean>(TitanBoolean.class);
			this.count = new Optional<TitanInteger>(TitanInteger.class);
			this.idle = new Optional<TitanInteger>(TitanInteger.class);
			this.interval = new Optional<TitanInteger>(TitanInteger.class);
		}

		public TcpKeepAlive(final Optional<TitanBoolean> enable, final Optional<TitanInteger> count, final Optional<TitanInteger> idle, final Optional<TitanInteger> interval ) {
			this.enable = new Optional<TitanBoolean>(TitanBoolean.class);
			this.enable.operator_assign( enable );
			this.count = new Optional<TitanInteger>(TitanInteger.class);
			this.count.operator_assign( count );
			this.idle = new Optional<TitanInteger>(TitanInteger.class);
			this.idle.operator_assign( idle );
			this.interval = new Optional<TitanInteger>(TitanInteger.class);
			this.interval.operator_assign( interval );
		}

		public TcpKeepAlive( final TcpKeepAlive otherValue) {
				otherValue.must_bound("Copying of an unbound value of type @IPL4asp_Types.TcpKeepAlive.");
			enable = new Optional<TitanBoolean>(TitanBoolean.class);
			count = new Optional<TitanInteger>(TitanInteger.class);
			idle = new Optional<TitanInteger>(TitanInteger.class);
			interval = new Optional<TitanInteger>(TitanInteger.class);
			operator_assign( otherValue );
		}

		public TcpKeepAlive operator_assign(final TcpKeepAlive otherValue ) {
			otherValue.must_bound( "Assignment of an unbound value of type @IPL4asp_Types.TcpKeepAlive");
			if (otherValue != this) {
				if ( otherValue.get_field_enable().is_bound() ) {
					this.enable.operator_assign( otherValue.get_field_enable() );
				} else {
					this.enable.clean_up();
				}
				if ( otherValue.get_field_count().is_bound() ) {
					this.count.operator_assign( otherValue.get_field_count() );
				} else {
					this.count.clean_up();
				}
				if ( otherValue.get_field_idle().is_bound() ) {
					this.idle.operator_assign( otherValue.get_field_idle() );
				} else {
					this.idle.clean_up();
				}
				if ( otherValue.get_field_interval().is_bound() ) {
					this.interval.operator_assign( otherValue.get_field_interval() );
				} else {
					this.interval.clean_up();
				}
			}

			return this;
		}

		@Override
		public TcpKeepAlive operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof TcpKeepAlive ) {
				return operator_assign((TcpKeepAlive) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.TcpKeepAlive", otherValue));
		}

		@Override
		public void clean_up() {
			enable.clean_up();
			count.clean_up();
			idle.clean_up();
			interval.clean_up();
		}

		@Override
		public boolean is_bound() {
			return optional_sel.OPTIONAL_OMIT.equals(enable.get_selection()) || enable.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(count.get_selection()) || count.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(idle.get_selection()) || idle.is_bound()
					|| optional_sel.OPTIONAL_OMIT.equals(interval.get_selection()) || interval.is_bound();
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_value() {
			return (optional_sel.OPTIONAL_OMIT.equals(enable.get_selection()) || enable.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(count.get_selection()) || count.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(idle.get_selection()) || idle.is_value())
					&& (optional_sel.OPTIONAL_OMIT.equals(interval.get_selection()) || interval.is_value());
		}

		public boolean operator_equals( final TcpKeepAlive other_value) {
			return enable.operator_equals( other_value.enable )
					&& count.operator_equals( other_value.count )
					&& idle.operator_equals( other_value.idle )
					&& interval.operator_equals( other_value.interval );
		}

		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof TcpKeepAlive ) {
				return operator_equals((TcpKeepAlive) other_value);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @IPL4asp_Types.TcpKeepAlive", other_value));
		}

		public Optional<TitanBoolean> get_field_enable() {
			return enable;
		}

		public Optional<TitanBoolean> constGet_field_enable() {
			return enable;
		}

		public Optional<TitanInteger> get_field_count() {
			return count;
		}

		public Optional<TitanInteger> constGet_field_count() {
			return count;
		}

		public Optional<TitanInteger> get_field_idle() {
			return idle;
		}

		public Optional<TitanInteger> constGet_field_idle() {
			return idle;
		}

		public Optional<TitanInteger> get_field_interval() {
			return interval;
		}

		public Optional<TitanInteger> constGet_field_interval() {
			return interval;
		}

		public TitanInteger size_of() {
			int sizeof = 0;
			if (enable.ispresent()) {
				sizeof++;
			}
			if (count.ispresent()) {
				sizeof++;
			}
			if (idle.ispresent()) {
				sizeof++;
			}
			if (interval.ispresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		@Override
		public void log() {
			if (!is_bound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" enable := ");
			enable.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" count := ");
			count.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" idle := ");
			idle.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" interval := ");
			interval.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record value of type @IPL4asp_Types.TcpKeepAlive has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_enable().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_count().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_idle().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_interval().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("enable".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_enable().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("count".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_count().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("idle".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_idle().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("interval".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_interval().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.TcpKeepAlive: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@IPL4asp_Types.TcpKeepAlive");
				break;
			}
		}

		@Override
		public void set_implicit_omit() {
			if (enable.is_bound()) {
				enable.set_implicit_omit();
			} else {
				enable.operator_assign(template_sel.OMIT_VALUE);
			}
			if (count.is_bound()) {
				count.set_implicit_omit();
			} else {
				count.operator_assign(template_sel.OMIT_VALUE);
			}
			if (idle.is_bound()) {
				idle.set_implicit_omit();
			} else {
				idle.operator_assign(template_sel.OMIT_VALUE);
			}
			if (interval.is_bound()) {
				interval.set_implicit_omit();
			} else {
				interval.operator_assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			enable.encode_text(text_buf);
			count.encode_text(text_buf);
			idle.encode_text(text_buf);
			interval.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			enable.decode_text(text_buf);
			count.decode_text(text_buf);
			idle.decode_text(text_buf);
			interval.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leave_context();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class TcpKeepAlive_template extends Base_Template {
		private TitanBoolean_template enable;
		private TitanInteger_template count;
		private TitanInteger_template idle;
		private TitanInteger_template interval;
		//originally value_list/list_value
		private List<TcpKeepAlive_template> list_value;


		public TcpKeepAlive_template() {
			// do nothing
		}

		public TcpKeepAlive_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		public TcpKeepAlive_template( final TcpKeepAlive otherValue ) {
			copy_value(otherValue);
		}

		public TcpKeepAlive_template( final TcpKeepAlive_template otherValue ) {
			copy_template( otherValue );
		}

		public TcpKeepAlive_template( final Optional<TcpKeepAlive> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @IPL4asp_Types.TcpKeepAlive from an unbound optional field.");
			}
		}

		@Override
		public TcpKeepAlive_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		public TcpKeepAlive_template operator_assign( final TcpKeepAlive otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		public TcpKeepAlive_template operator_assign( final TcpKeepAlive_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public TcpKeepAlive_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof TcpKeepAlive) {
				return operator_assign((TcpKeepAlive) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TcpKeepAlive' can not be cast to {1}", otherValue));
		}

		@Override
		public TcpKeepAlive_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof TcpKeepAlive_template) {
				return operator_assign((TcpKeepAlive_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TcpKeepAlive' can not be cast to {1}_template", otherValue));
		}

		public TcpKeepAlive_template operator_assign( final Optional<TcpKeepAlive> otherValue ) {
			clean_up();
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @IPL4asp_Types.TcpKeepAlive.");
			}
			return this;
		}

		private void copy_value(final TcpKeepAlive other_value) {
			if (other_value.get_field_enable().is_bound()) {
				if (other_value.get_field_enable().ispresent()) {
					get_field_enable().operator_assign(other_value.get_field_enable().get());
				} else {
					get_field_enable().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_enable().clean_up();
			}
			if (other_value.get_field_count().is_bound()) {
				if (other_value.get_field_count().ispresent()) {
					get_field_count().operator_assign(other_value.get_field_count().get());
				} else {
					get_field_count().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_count().clean_up();
			}
			if (other_value.get_field_idle().is_bound()) {
				if (other_value.get_field_idle().ispresent()) {
					get_field_idle().operator_assign(other_value.get_field_idle().get());
				} else {
					get_field_idle().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_idle().clean_up();
			}
			if (other_value.get_field_interval().is_bound()) {
				if (other_value.get_field_interval().ispresent()) {
					get_field_interval().operator_assign(other_value.get_field_interval().get());
				} else {
					get_field_interval().operator_assign(template_sel.OMIT_VALUE);
				}
			} else {
				get_field_interval().clean_up();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copy_template(final TcpKeepAlive_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_enable().get_selection()) {
					get_field_enable().clean_up();
				} else {
					get_field_enable().operator_assign(other_value.get_field_enable());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_count().get_selection()) {
					get_field_count().clean_up();
				} else {
					get_field_count().operator_assign(other_value.get_field_count());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_idle().get_selection()) {
					get_field_idle().clean_up();
				} else {
					get_field_idle().operator_assign(other_value.get_field_idle());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.get_field_interval().get_selection()) {
					get_field_interval().clean_up();
				} else {
					get_field_interval().operator_assign(other_value.get_field_interval());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TcpKeepAlive_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TcpKeepAlive_template temp = new TcpKeepAlive_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @IPL4asp_Types.TcpKeepAlive.");
			}
			set_selection(other_value);
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @IPL4asp_Types.TcpKeepAlive.");
			}
			clean_up();
			set_selection(template_type);
			list_value = new ArrayList<TcpKeepAlive_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TcpKeepAlive_template());
			}
		}


		@Override
		public boolean is_bound() {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			return enable.is_omit() || enable.is_bound()
					|| count.is_omit() || count.is_bound()
					|| idle.is_omit() || idle.is_bound()
					|| interval.is_omit() || interval.is_bound();
		}

		@Override
		public boolean is_present(final boolean legacy) {
			return is_present_(legacy);
		}

		private boolean is_present_(final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return template_selection==template_sel.VALUE_LIST;
						}
					}
					return template_selection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return (enable.is_omit() || enable.is_value())
					&& (count.is_omit() || count.is_value())
					&& (idle.is_omit() || idle.is_value())
					&& (interval.is_omit() || interval.is_value());
		}
		public TitanBoolean_template get_field_enable() {
			set_specific();
			return enable;
		}

		public TitanBoolean_template constGet_field_enable() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field enable of a non-specific template of type @IPL4asp_Types.TcpKeepAlive.");
			}
			return enable;
		}

		public TitanInteger_template get_field_count() {
			set_specific();
			return count;
		}

		public TitanInteger_template constGet_field_count() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field count of a non-specific template of type @IPL4asp_Types.TcpKeepAlive.");
			}
			return count;
		}

		public TitanInteger_template get_field_idle() {
			set_specific();
			return idle;
		}

		public TitanInteger_template constGet_field_idle() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field idle of a non-specific template of type @IPL4asp_Types.TcpKeepAlive.");
			}
			return idle;
		}

		public TitanInteger_template get_field_interval() {
			set_specific();
			return interval;
		}

		public TitanInteger_template constGet_field_interval() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field interval of a non-specific template of type @IPL4asp_Types.TcpKeepAlive.");
			}
			return interval;
		}

		private void set_specific() {
			if (template_selection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = template_selection;
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					enable = new TitanBoolean_template(template_sel.ANY_OR_OMIT);
					count = new TitanInteger_template(template_sel.ANY_OR_OMIT);
					idle = new TitanInteger_template(template_sel.ANY_OR_OMIT);
					interval = new TitanInteger_template(template_sel.ANY_OR_OMIT);
				} else {
					enable = new TitanBoolean_template();
					count = new TitanInteger_template();
					idle = new TitanInteger_template();
					interval = new TitanInteger_template();
				}
			}
		}
		public boolean match(final TcpKeepAlive other_value) {
			return match(other_value, false);
		}

		public boolean match(final TcpKeepAlive other_value, final boolean legacy) {
			if (!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.get_field_enable().is_bound()) {
					return false;
				}
				if((other_value.get_field_enable().ispresent() ? !enable.match(other_value.get_field_enable().get(), legacy) : !enable.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_count().is_bound()) {
					return false;
				}
				if((other_value.get_field_count().ispresent() ? !count.match(other_value.get_field_count().get(), legacy) : !count.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_idle().is_bound()) {
					return false;
				}
				if((other_value.get_field_idle().ispresent() ? !idle.match(other_value.get_field_idle().get(), legacy) : !idle.match_omit(legacy))) {
					return false;
				}
				if(!other_value.get_field_interval().is_bound()) {
					return false;
				}
				if((other_value.get_field_interval().ispresent() ? !interval.match(other_value.get_field_interval().get(), legacy) : !interval.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @IPL4asp_Types.TcpKeepAlive.");
			}
		}


		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TcpKeepAlive) {
				return match((TcpKeepAlive)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TcpKeepAlive.");
		}


		@Override
		public TcpKeepAlive valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.TcpKeepAlive.");
			}
			final TcpKeepAlive ret_val = new TcpKeepAlive();
			if (enable.is_omit()) {
				ret_val.get_field_enable().operator_assign(template_sel.OMIT_VALUE);
			} else if (enable.is_bound()) {
				ret_val.get_field_enable().operator_assign(enable.valueof());
			}
			if (count.is_omit()) {
				ret_val.get_field_count().operator_assign(template_sel.OMIT_VALUE);
			} else if (count.is_bound()) {
				ret_val.get_field_count().operator_assign(count.valueof());
			}
			if (idle.is_omit()) {
				ret_val.get_field_idle().operator_assign(template_sel.OMIT_VALUE);
			} else if (idle.is_bound()) {
				ret_val.get_field_idle().operator_assign(idle.valueof());
			}
			if (interval.is_omit()) {
				ret_val.get_field_interval().operator_assign(template_sel.OMIT_VALUE);
			} else if (interval.is_bound()) {
				ret_val.get_field_interval().operator_assign(interval.valueof());
			}
			return ret_val;
		}

		public TitanInteger size_of() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive which has an ifpresent attribute.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				int sizeof = 0;
				if (enable.is_present()) {
					sizeof++;
				}
				if (count.is_present()) {
					sizeof++;
				}
				if (idle.is_present()) {
					sizeof++;
				}
				if (interval.is_present()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive containing an empty list.");
				}
				final int item_size = list_value.get(0).size_of().get_int();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).size_of().get_int() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.TcpKeepAlive.");
			}
		}

		@Override
		public TcpKeepAlive_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @IPL4asp_Types.TcpKeepAlive.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @IPL4asp_Types.TcpKeepAlive using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @IPL4asp_Types.TcpKeepAlive.");
			}
			return list_value.get(list_index);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" enable := ");
				enable.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" count := ");
				count.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" idle := ");
				idle.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" interval := ");
				interval.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TcpKeepAlive match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TcpKeepAlive) {
				log_match((TcpKeepAlive)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @IPL4asp_Types.TcpKeepAlive.");
		}

		public void log_match(final TcpKeepAlive match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if (match_value.constGet_field_enable().ispresent()) {
							if( !enable.match(match_value.constGet_field_enable().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".enable");
								enable.log_match(match_value.constGet_field_enable().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!enable.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".enable := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								enable.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_count().ispresent()) {
							if( !count.match(match_value.constGet_field_count().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".count");
								count.log_match(match_value.constGet_field_count().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!count.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".count := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								count.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_idle().ispresent()) {
							if( !idle.match(match_value.constGet_field_idle().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".idle");
								idle.log_match(match_value.constGet_field_idle().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!idle.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".idle := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								idle.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGet_field_interval().ispresent()) {
							if( !interval.match(match_value.constGet_field_interval().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".interval");
								interval.log_match(match_value.constGet_field_interval().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!interval.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".interval := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								interval.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ enable := ");
				enable.log_match(match_value.constGet_field_enable(), legacy);
				TTCN_Logger.log_event_str("{ count := ");
				count.log_match(match_value.constGet_field_count(), legacy);
				TTCN_Logger.log_event_str("{ idle := ");
				idle.log_match(match_value.constGet_field_idle(), legacy);
				TTCN_Logger.log_event_str("{ interval := ");
				interval.log_match(match_value.constGet_field_interval(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				enable.encode_text(text_buf);
				count.encode_text(text_buf);
				idle.encode_text(text_buf);
				interval.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.TcpKeepAlive.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				enable = new TitanBoolean_template();
				enable.decode_text(text_buf);
				count = new TitanInteger_template();
				count.decode_text(text_buf);
				idle = new TitanInteger_template();
				idle.decode_text(text_buf);
				interval = new TitanInteger_template();
				interval.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<TcpKeepAlive_template>(size);
				for (int i = 0; i < size; i++) {
					final TcpKeepAlive_template temp = new TcpKeepAlive_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.TcpKeepAlive.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record template of type @IPL4asp_Types.TcpKeepAlive has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_enable().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_count().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_idle().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					get_field_interval().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("enable".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_enable().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("count".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_count().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("idle".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_idle().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("interval".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_field_interval().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @IPL4asp_Types.TcpKeepAlive: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@IPL4asp_Types.TcpKeepAlive");
				break;
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.enable.check_restriction(restriction, name == null ? "@IPL4asp_Types.TcpKeepAlive" : name, legacy);
				this.count.check_restriction(restriction, name == null ? "@IPL4asp_Types.TcpKeepAlive" : name, legacy);
				this.idle.check_restriction(restriction, name == null ? "@IPL4asp_Types.TcpKeepAlive" : name, legacy);
				this.interval.check_restriction(restriction, name == null ? "@IPL4asp_Types.TcpKeepAlive" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@IPL4asp_Types.TcpKeepAlive" : name));
		}
	}
	public static class AssociationId extends TitanInteger { }
	public static class AssociationId_template extends TitanInteger_template { }
	public void pre_init_module()
	{
		if (pre_init_called) {
			return;
		}
		pre_init_called = true;
Module_List.pre_init_module("Socket_API_Definitions");
SSL__proto__support_descr_.oftype_descr = SSL__protocols_descr_;
HostList_descr_.oftype_descr = Base_Type.TitanCharString_descr_;
Option_alpn__list_descr_.oftype_descr = Base_Type.TitanCharString_descr_;
OptionList_descr_.oftype_descr = Option_descr_;
/* IPL4asp_Types.ttcn, line 549 */
IPL4__ERROR__GENERAL.operator_assign(Socket__API__Definitions.PortError.enum_type.ERROR__GENERAL);
/* IPL4asp_Types.ttcn, line 550 */
IPL4__ERROR__INSUFFICIENT__MEMORY.operator_assign(Socket__API__Definitions.PortError.enum_type.ERROR__INSUFFICIENT__MEMORY);
/* IPL4asp_Types.ttcn, line 551 */
IPL4__ERROR__INVALID__INPUT__PARAMETER.operator_assign(Socket__API__Definitions.PortError.enum_type.ERROR__INVALID__INPUT__PARAMETER);
/* IPL4asp_Types.ttcn, line 552 */
IPL4__ERROR__UNSUPPORTED__TRANSPORT.operator_assign(Socket__API__Definitions.PortError.enum_type.ERROR__UNSUPPORTED__PROTOCOL);
/* IPL4asp_Types.ttcn, line 553 */
IPL4__ERROR__SOCKET.operator_assign(Socket__API__Definitions.PortError.enum_type.ERROR__SOCKET);
/* IPL4asp_Types.ttcn, line 554 */
IPL4__ERROR__HOSTNAME.operator_assign(Socket__API__Definitions.PortError.enum_type.ERROR__HOSTNAME);
/* IPL4asp_Types.ttcn, line 555 */
IPL4__ERROR__INVALID__CONNECTION.operator_assign(Socket__API__Definitions.PortError.enum_type.ERROR__INVALID__CONNECTION);
/* IPL4asp_Types.ttcn, line 556 */
IPL4__ERROR__TEMPORARILY__UNAVAILABLE.operator_assign(Socket__API__Definitions.PortError.enum_type.ERROR__TEMPORARILY__UNAVAILABLE);
/* IPL4asp_Types.ttcn, line 557 */
IPL4__ERROR__AVAILABLE.operator_assign(Socket__API__Definitions.PortError.enum_type.ERROR__AVAILABLE);
/* IPL4asp_Types.ttcn, line 628 */
c__IPL4__DTLS__SRTP__AES128__CM__SHA1__32__Profile.operator_assign("SRTP_AES128_CM_SHA1_32");
/* IPL4asp_Types.ttcn, line 629 */
c__IPL4__DTLS__SRTP__AES128__CM__SHA1__80__Profile.operator_assign("SRTP_AES128_CM_SHA1_80");
/* IPL4asp_Types.ttcn, line 630 */
c__IPL4__DTLS__SRTP__AES128__F8__SHA1__80__Profile.operator_assign("SRTP_AES128_F8_SHA1_80");
/* IPL4asp_Types.ttcn, line 631 */
c__IPL4__DTLS__SRTP__AES128__F8__SHA1__32__Profile.operator_assign("SRTP_AES128_F8_SHA1_32");
/* IPL4asp_Types.ttcn, line 632 */
c__IPL4__DTLS__SRTP__NULL__SHA1__80__Profile.operator_assign("SRTP_NULL_SHA1_80");
/* IPL4asp_Types.ttcn, line 633 */
c__IPL4__DTLS__SRTP__NULL__SHA1__32__Profile.operator_assign("SRTP_NULL_SHA1_32");
/* IPL4asp_Types.ttcn, line 635 */
c__IPL4__DTLS__SRTP__ALL__KNOWN__Profile.operator_assign("SRTP_AES128_CM_SHA1_32:SRTP_AES128_CM_SHA1_80");
	}

	public void post_init_module()
	{
		if (post_init_called) {
			return;
		}
		post_init_called = true;
		TTCN_Logger.log_module_init(module_name, false);
Module_List.post_init_module("Socket_API_Definitions");
		TTCN_Logger.log_module_init(module_name, true);
	}

}
