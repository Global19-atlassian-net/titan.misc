/*
//-----------------------------------------------------------------------------
//AUTHOR:      Gyorgy Rethy, L.M. Ericsson (SF296, STF270, STF246, STF196, STF166)
//DATE:        September 2007
//VERSION:     4.2.1
//
//DTS/MTS 0097-3
//
//Methods for Testing and Specification (MTS);
//Conformance Test Specification for SIP (RFC32361);
//Part 3: Abstract Test Suite (TTCN-3 code)
//
//(c) European Telecommunications Standards Institute 2001.
//All rights reserved.
//
//-----------------------------------------------------------------------------
//HISTORY: ---> see History in SIP_MainModule.ttcn
//
//References
//The following documents contain provisions which, through reference in this text, constitute provisions of the present document.
//- References are either specific (identified by date of publication, edition number, version number, etc.) or non-specific.
//- For a specific reference, subsequent revisions do not apply.
//- For a non-specific reference, the latest version applies.
//- A non-specific reference to an ETS shall also be taken to refer to later versions published as an EN with the same number.
//[1]  RFC 3261, "Session Description Protocol", SDP: Session Description Protocol. M. Handley, V. Jacobson. April 1998. (Status: PROPOSED STANDARD).
//[3]  ISO/IEC 9646-1: "Information technology - Open Systems Interconnection - Conformance testing methodology and framework - Part 1: General concepts
//[4]  ISO/IEC 9646-2: "Information technology - Open Systems Interconnection - Conformance testing methodology and framework - Part 2: Abstract Test Suite specification".
//[5] ISO/IEC 9646-3: "Information technology - Open Systems Interconnection - Conformance testing methodology and framework - Part 3: The Tree and Tabular Combined Notation".
//[6]  ETS 300 406: "Methods for Testing and Specification (MTS); Protocol and profile conformance testing specifications; Standardization methodology".
*/

//**************************************************************************************************
//compiled with Titan 5 R4C 2016.02.22 Elemer Lelik
//**************************************************************************************************


module SIP_Registration {


import from SIPmsg_Types all;
import from SIP_TypesAndConf all;
import from SIP_Templates all;
import from SIP_Steps all;

group TestPurposesforRegistration {
  group Registrant {
    // GroupSelection:  Registration being listed as an option, the test purpose is appl
    // icable if the IUT is declared as supporting periodic registration and can behave
    //  as User Agent.
    group ValidBehaviour {
      testcase SIP_RG_RT_V_001() runs on SipComponent system SipInterfaces
      // Ref: 10.2 [1]
      // Purpose : Ensure that the IUT, in order to be registered, sends a REGISTER requ
      // est to its registrar, without user name in the Request-URI and with a SIP-URI as
      //  request-URI.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER");
        TWait.start (PX_TWAIT);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          [] SIPP.receive (
            REGISTER_Request_r_2) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, in order to be registered, sends a REGISTER requ est to its registrar, without user name in the Request-URI and with a SIP-URI as  request-URI.";
        extension "Reference: 10.2 [1]";
        extension "FailCause: Received REGISTER_Request which contain Request-URI with a user name OR received REGISTER_Request with missing mandatory message header";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_001
      testcase SIP_RG_RT_V_002() runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT having sent a REGISTER request is able to receive
      //  a Success (200 OK) response containing its current registration list in the Contact
      // header and an expires parameter in the header.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER");
        TWait.start (PX_TWAIT);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          [] SIPP.receive (
            REGISTER_Request_r_2) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_1(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date,
                int2str (
                  float2int (SHORT_REGISTRATION)))) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
        
        // Check that IUT doesn't send any further message
        checkNoFurtherMessages();
        
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT having sent a REGISTER request is able to receive  a Success (200 OK) response containing its current registration list in the Contact header and an expires parameter in the header.";
        extension "Reference: 10.3 [1] ";
        extension "FailCause: Received REGISTER_Request with missing registration list in the Contact header OR received REGISTER_Request with missing expires parameter";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_002
      testcase SIP_RG_RT_V_003() runs on SipComponent system SipInterfaces
      // Ref: 10.2.6 [1]
      // Purpose : Ensure that the IUT, in order to be registered, sends a REGISTER request
      // to the its pre-configured registrar address and without username.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER");
        TWait.start (PX_TWAIT);
        alt {
          [] SIPP.receive (
            REGISTER_Request_r_5) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, in order to be registered, sends a REGISTER request to the its pre-configured registrar address and without username.";
        extension "Reference: 10.2.6 [1]";
        extension "FailCause: Received REGISTER_Request with wrong pre-configured registrar (PX_ETS_LOCAL_DOMAIN)";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_003
      testcase SIP_RG_RT_V_004() runs on SipComponent system SipInterfaces
      // Ref: 10.2.6 [1]
      // Purpose : Ensure that the IUT, in order to be registered, sends a REGISTER request
      // to host part of address of record as the Request-URI and without username.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER");
        TWait.start (PX_TWAIT);
        alt {
          [] SIPP.receive (
            REGISTER_Request_r_6) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, in order to be registered, sends a REGISTER request to host part of address of record as the Request-URI and without username.";
        extension "Reference: 10.2.6 [1]";
        extension "FailCause: Received REGISTER_Request with request URI addressed to address of record PX_IUT_HOME_DOMAIN";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_004
      testcase SIP_RG_RT_V_005() runs on SipComponent system SipInterfaces
      // Ref: 10.2.6 [1]
      // Purpose : Ensure that the IUT, in order to be registered, sends a REGISTER request
      // to the well-known "all SIP servers" multicast address "sip.mcast.net" (224.0
      // .1.75) and without username.
      {
        var REGISTER_Request vl_REGISTER_Request;
        var charstring vl_host_address;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER on Multi cast address");
        
        TWait.start (PX_TWAIT);
        alt {
          [] SIPP.receive (
            REGISTER_Request_r_2) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            vl_host_address :=
            valueof (
              vl_REGISTER_Request
              .requestLine
              .requestUri
              .hostPort
              .host);
            if (vl_host_address == MCAST_SIP_IPADDR
              or vl_host_address == "sip.mcast.net") {
              setverdict (pass);
            } else {
              log ("BEGIN_TRACE_INFO No valid multicast address in request Uri. END_TRACE_INFO");
              setverdict (fail);
              SIPP.send (
                Response_400_s_1(
                  v_CallId,
                  v_CSeq,
                  v_From,
                  v_To,
                  v_Via)) to v_sent_label;
              
              stop
            }
            
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_1(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date,
                int2str (
                  float2int (SHORT_REGISTRATION)))) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, in order to be registered, sends a REGISTER request to the well-known ""all SIP servers"" multicast address ""sip.mcast.net"" (224.0 .1.75) and without username.";
        extension "Reference: 10.2.6 [1]";
        extension "FailCause: Received REGISTER_Request with no valid multicast address in Request URI";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_005
      testcase SIP_RG_RT_V_006() runs on SipComponent system SipInterfaces
      // Ref: 10.2.4 [1]
      // Purpose : Ensure that the IUT, already registered, sends at least one REGISTER
      // request, during the shortest lifetime indicated in the Contact parameters of the
      //  Success (200 OK) response it has received.
      {
        var REGISTER_Request vl_REGISTER_Request;
        var float vl_timer := SHORT_REGISTRATION;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        iUTRegistration2();
        TRept.start (vl_timer);
        alt {
          // the same REGISTER message is repeated with UDP (not a new registration) -> ignored
          [] SIPP.receive (
            REGISTER_Request_r_7(
              v_CallId,
              v_CSeq,
              v_From,
              v_To,
              v_Contact)) -> value vl_REGISTER_Request sender v_sent_label {
            repeat;
          }
          // REGISTER message can be either received on multicast or unicast address
          [] SIPP.receive (
            REGISTER_Request_r_2) -> value vl_REGISTER_Request sender v_sent_label {
            TRept.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TRept.timeout {
            setverdict (fail);
            stop;
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, already registered, sends at least one REGISTER  request, during the shortest lifetime indicated in the Contact parameters of the  Success (200 OK) response it has received.";
        extension "Reference: 10.2.4 [1]";
        extension "FailCause: Invalid REGISTER_Request received OR second REGISTER request not received during the shortest lifetime indicated in the Contact parameters of the  Success (200 OK) response";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_006
      testcase SIP_RG_RT_V_007() runs on SipComponent system SipInterfaces
      // Ref: 8.1.3.5 [1], 22.2 [1]
      // Purpose : Ensure that the IUT having sent a REGISTER message, on receipt of an
      // Unauthorized (401 Unauthorized) response including a WWW-Authenticate header, re
      // peats its REGISTER request with an Authorization header and with an incremented
      // Cseq value.
      {
        var REGISTER_Request vl_REGISTER_Request;
        var CSeq vl_first_CSeq;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        havingSentARegister(vl_REGISTER_Request);
        vl_first_CSeq := v_CSeq;
        
        // Send a Unauthorized (401 Unauthorized) response
        SIPP.send (
          Response_401_s_1(
            v_CallId,
            v_CSeq,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        TAck.start (PX_TACK);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          // REGISTER including an Authorization header and with an incremented
          // Cseq value.
          [] SIPP.receive (
            REGISTER_Request_r_4) -> value vl_REGISTER_Request sender v_sent_label {
            TAck.stop;
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            if (v_CSeq.seqNumber > vl_first_CSeq.seqNumber) {
              setverdict (pass);
            } else {
              log ("BEGIN_TRACE_INFO Cseq value not incremented. END_TRACE_INFO");
              setverdict (fail);
              SIPP.send (
                Response_400_s_1(
                  v_CallId,
                  v_CSeq,
                  v_From,
                  v_To,
                  v_Via)) to v_sent_label;
              
              stop
            }
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TAck.timeout {
            setverdict (fail);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT having sent a REGISTER message, on receipt of an  Unauthorized (401 Unauthorized) response including a WWW-Authenticate header, re peats its REGISTER request with an Authorization header and with an incremented  Cseq value.";
        extension "Reference: 8.1.3.5 [1], 22.2 [1]";
        extension "FailCause: Invalid first REGISTER_Request received OR second REGISTER request does not include an Authorization header and an incremented Cseq value";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_007
      testcase SIP_RG_RT_V_008() runs on SipComponent system SipInterfaces
      // Ref: 10.2 [1]
      // Purpose : Ensure that the IUT, in order to be registered, sends a REGISTER request
      //  to its registrar, with an address-of-record in the To header of type SIP URI.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER");
        TWait.start (PX_TWAIT);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          [] SIPP.receive (
            REGISTER_Request_r_2) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            if ((ischosen (v_To.addressField.nameAddr)
                and (v_To
                  .addressField
                  .nameAddr
                  .addrSpec
                  .hostPort
                  .host
                  == PX_IUT_HOME_DOMAIN))
              or (ischosen (v_To.addressField.addrSpecUnion)
                and (v_To
                  .addressField
                  .addrSpecUnion
                  .hostPort
                  .host
                  == PX_IUT_HOME_DOMAIN))) {
              setverdict (pass);
            } else {
              log ("BEGIN_TRACE_INFO No valid IUT Home Domain in To header field. END_TRACE_INFO");
              setverdict (fail);
              SIPP.send (
                Response_400_s_1(
                  v_CallId,
                  v_CSeq,
                  v_From,
                  v_To,
                  v_Via)) to v_sent_label;
              
              stop
            }
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, in order to be registered, sends a REGISTER request  to its registrar, with an address-of-record in the To header of type SIP URI.";
        extension "Reference: 10.2 [1]";
        extension "FailCause: REGISTER_Request which does not contain valid IUT Home Domain in To header field received";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_008
      testcase SIP_RG_RT_V_009() runs on SipComponent system SipInterfaces
      // Ref: 10.2 [1]
      // Purpose : Ensure that the IUT, in order to be registered, sends a REGISTER request
      // to its registrar, wit the same URI in the From and the To header.
      {
        var REGISTER_Request vl_REGISTER_Request;
        var SipUrl vl_To_SipUrl;
        var SipUrl vl_From_SipUrl;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER");
        TWait.start (PX_TWAIT);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          [] SIPP.receive (
            REGISTER_Request_r_2) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            
            if (ischosen (v_To.addressField.nameAddr)) {
              vl_To_SipUrl :=
              v_To.addressField.nameAddr.addrSpec;
            } else {
              vl_To_SipUrl := v_To.addressField.addrSpecUnion;
            };
            
            if (ischosen (v_From.addressField.nameAddr)) {
              vl_From_SipUrl :=
              v_From.addressField.nameAddr.addrSpec;
            } else {
              vl_From_SipUrl :=
              v_From.addressField.addrSpecUnion;
            }
            
            if (eqURIs(vl_To_SipUrl,
                vl_From_SipUrl)) {
              setverdict (pass);
            } else {
              log ("BEGIN_TRACE_INFO URI in To header unequal to URI in From header. END_TRACE_INFO");
              setverdict (fail);
              SIPP.send (
                Response_400_s_1(
                  v_CallId,
                  v_CSeq,
                  v_From,
                  v_To,
                  v_Via)) to v_sent_label;
              
              stop
            };
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, in order to be registered, sends a REGISTER request to its registrar, wit the same URI in the From and the To header.";
        extension "Reference: 10.2 [1]";
        extension "FailCause: REGISTER_Request received which does not contain same URI in the From and To header field";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_009
      testcase SIP_RG_RT_V_010() runs on SipComponent system SipInterfaces
      // Ref: 10.2 [1]
      // Purpose : Ensure that the IUT having sent a REGISTER request, does not send a new
      // registration before the REGISTER request has timed out in case of no final response
      //  is received.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        havingSentARegister(vl_REGISTER_Request);
        
        // Timer F  (non-Invite request timeout timer) is equal to T1*64
        TRept.start ((PX_T1 * 64.0) * 90.0 / 100.0);
        alt {
          // the same REGISTER message is repeated with UDP (not a new registration) -> ignored
          [] SIPP.receive (
            REGISTER_Request_r_7(
              v_CallId,
              v_CSeq,
              v_From,
              v_To,
              v_Contact)) -> value vl_REGISTER_Request sender v_sent_label {
            repeat;
          }
          // REGISTER message can be either received on multicast or unicast address
          // New Registration before timeout TF
          [] SIPP.receive (
            REGISTER_Request_r_1) -> value vl_REGISTER_Request sender v_sent_label {
            TRept.stop;
            setverdict (fail);
            SIPP.send (
              Response_400_s_1(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via)) to v_sent_label;
          }
          [] TRept.timeout {
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT having sent a REGISTER request, does not send a new registration before the REGISTER request has timed out in case of no final response  is received.";
        extension "Reference: 10.2 [1]";
        extension "FailCause: Invalid REGISTER_Request received OR Second REGISTER request was send before the first REGISTER request has timed out";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_010
      testcase SIP_RG_RT_V_011() runs on SipComponent system SipInterfaces
      // Ref: 10.2 [1]
      // Purpose : Ensure that the IUT having sent a REGISTER request, will increment the
      //  CSeq value by one in the next new REGISTER request with the same CALL-id.
      {
        var REGISTER_Request vl_REGISTER_Request;
        var CSeq vl_first_CSeq;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        iUTRegistration2();
        vl_first_CSeq := v_CSeq;
        
        action ("Please REGISTER with new contacts");
        
        TWait.start (PX_TWAIT);
        alt {
          // the same REGISTER message is repeated or refreshed (not a new registration) -> ignored
          [] SIPP.receive (
            REGISTER_Request_r_7(
              v_CallId,
              v_CSeq,
              v_From,
              v_To,
              v_Contact)) -> value vl_REGISTER_Request sender v_sent_label {
            repeat;
          }
          // REGISTER message can be either received on multicast or unicast address
          [] SIPP.receive (
            REGISTER_Request_r_8(v_CallId)) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            if (v_CSeq.seqNumber
              == vl_first_CSeq.seqNumber + 1) {
              setverdict (pass);
            } else {
              log ("BEGIN_TRACE_INFO Cseq value not incremented. END_TRACE_INFO");
              setverdict (fail);
              SIPP.send (
                Response_400_s_1(
                  v_CallId,
                  v_CSeq,
                  v_From,
                  v_To,
                  v_Via)) to v_sent_label;
              
              stop
            }
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          // No new registration
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT having sent a REGISTER request, will increment the  CSeq value by one in the next new REGISTER request with the same CALL-id.";
        extension "Reference: 10.2 [1]";
        extension "FailCause: Invalid REGISTER_Request received OR Second REGISTER request does not contain new Contact List OR Second REGISTER request does not contain incremented CSeq value or same Call-ID";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_011
      testcase SIP_RG_RT_V_012() runs on SipComponent system SipInterfaces
      // Ref: 10.2.4 [1]
      // Purpose : Ensure that the IUT, already registered, sends at least one REGISTER
      // request, during the shortest lifetime indicated in the Contact parameters of the
      //  Success (200 OK) response it has received, using the same Call-ID as in the pre
      // vious REGISTER request.
      {
        var REGISTER_Request vl_REGISTER_Request;
        var CSeq vl_first_CSeq;
        var float vl_timer := SHORT_REGISTRATION;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        iUTRegistration2();
        vl_first_CSeq := v_CSeq;
        
        TRept.start (vl_timer);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          [] SIPP.receive (
            REGISTER_Request_r_8(v_CallId)) -> value vl_REGISTER_Request sender v_sent_label {
            TRept.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          // No new registration
          [] TRept.timeout {
            setverdict (fail);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, already registered, sends at least one REGISTER  request, during the shortest lifetime indicated in the Contact parameters of the  Success (200 OK) response it has received, using the same Call-ID as in the pre vious REGISTER request.";
        extension "Reference: 10.2.4 [1]";
        extension "FailCause: Invalid REGISTER_Request received OR Second REGISTER_Request not received during the shortest lifetime indicated in the Contact parameters of the Success (200 OK) response.";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_012
      testcase SIP_RG_RT_V_013() runs on SipComponent system SipInterfaces
      // Ref: 10.2.2 [1]
      // Purpose : Ensure that the IUT, in order to remove an existing binding sends a
      // REGISTER request, with Expires parameter set to zero in the Contact headers or an
      // Expires header set to 0 when Contact field is set to "*".
      {
        var REGISTER_Request vl_REGISTER_Request;
        var CSeq vl_first_CSeq;
        var Contact vl_Contact_wild := {
          fieldName := CONTACT_E,
          contactBody := { wildcard := "*" }
        };
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        iUTRegistration3();
        vl_first_CSeq := v_CSeq;
        
        action ("Please remove REGISTRATION");
        
        TWait.start (PX_TWAIT);
        alt {
          // REGISTER message containing Contact set to * and Expires header set to 0
          [] SIPP.receive (
            REGISTER_Request_r_9) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            // set correct Contact
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                vl_Contact_wild,
                v_date)) to v_sent_label;
            setverdict (pass);
          }
          // REGISTER message containing Contact with expires parameter set to 0
          [] SIPP.receive (
            REGISTER_Request_r_2) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            if (checkExpiresContactAddresses(v_Contact
                .contactBody
                .contactAddresses,
                charstring_0)) {
              setverdict (pass);
            } else {
              setverdict (fail);
              log ("BEGIN_TRACE_INFO Invalid Expired parameter in Contact header field (should be 0). END_TRACE_INFO");
              SIPP.send (
                Response_400_s_1(
                  v_CallId,
                  v_CSeq,
                  v_From,
                  v_To,
                  v_Via)) to v_sent_label;
              
              stop
            }
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          // No new registration
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, in order to remove an existing binding sends a REGISTER request, with Expires parameter set to zero in the Contact headers or an Expires header set to 0 when Contact field is set to ""*"".";
        extension "Reference: 10.2.2 [1]";
        extension "FailCause: Invalid REGISTER_Request received OR Second REGISTER_Request does not contain Expires header set to 0 when Contact field is set to ""*"".";
        extension "InconcCause: No REGISTER_Request received";
      } // end testcase SIP_RG_RT_V_013
      testcase SIP_RG_RT_V_014() runs on SipComponent system SipInterfaces
      // Ref: 10.2.1 [1]
      // Purpose : Ensure that the IUT, in order to get its registered contacts, sends a REGISTER request to its
      // registrar without Contact header.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER");
        TWait.start (PX_TWAIT);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          [] SIPP.receive (
            REGISTER_Request_r_2) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_1(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date,
                int2str (
                  float2int (SHORT_REGISTRATION)))) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
        action ("Please check registered contacts, by sending REGISTER Request without sending Contact header");
        alt {
          // REGISTER message can be either received on multicast or unicast address
          [] SIPP.receive (
            REGISTER_Request_r_10) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the old already send contact list
            SIPP.send (
              Response_Register_200_s_1(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date,
                int2str (
                  float2int (SHORT_REGISTRATION)))) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (fail);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, in order to get its registered contacts, sends a REGISTER request to its registrar without Contact header.";
        extension "Reference: 10.2.1 [1]";
        
      } // end testcase SIP_RG_RT_V_014
      testcase SIP_RG_RT_V_015() runs on SipComponent system SipInterfaces
      // Ref: 10.2.1.1.
      // Purpose : Ensure that the IUT, in order to suggest an expiration interval for its binding, sends a REGISTER
      // request to its registrar with either an Expires header field or "expires" Contact header parameter.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER");
        TWait.start (PX_TWAIT);
        alt {
          [] SIPP.receive (
            REGISTER_Request_r_11) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] SIPP.receive (
            REGISTER_Request_r_12) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, in order to suggest an expiration interval for its binding, sends a REGISTER request to its registrar with either an Expires header field or ""expires"" Contact header parameter.";
        extension "Reference: 10.2.1.1 [1]";
        
      } // end testcase SIP_RG_RT_V_015
      testcase SIP_RG_RT_V_016() runs on SipComponent system SipInterfaces
      // Ref: 10.2.1.2
      // Purpose :Ensure that the IUT, in order to order its bindings, to indicate a relative preference for the list in
      // the Contact header field value, sends a REGISTER request to its registrar with "q" Contact header
      // parameter.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER");
        TWait.start (PX_TWAIT);
        alt {
          [] SIPP.receive (
            REGISTER_Request_r_13) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, in order to order its bindings, to indicate a relative preference for the list in the Contact header field value, sends a REGISTER request to its registrar with ""q"" Contact header parameter.";
        extension "Reference: 10.2.1.2 [1]";
        
      } // end testcase SIP_RG_RT_V_016
      testcase SIP_RG_RT_V_017() runs on SipComponent system SipInterfaces
      // Ref: 10.2.5
      // Purpose :Ensure that the IUT having sent a REGISTER request is able to receive a Success (200 OK)
      // response containing a Date header field.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        action ("Please REGISTER");
        TWait.start (PX_TWAIT);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          [] SIPP.receive (
            REGISTER_Request_r_2) -> value vl_REGISTER_Request sender v_sent_label {
            TWait.stop;
            setverdict (pass);
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TWait.timeout {
            setverdict (inconc);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT having sent a REGISTER request is able to receive a Success (200 OK) response containing a Date header field.";
        extension "Reference: 10.2.5 [1]";
        
      } // end testcase SIP_RG_RT_V_017
      testcase SIP_RG_RT_V_018() runs on SipComponent system SipInterfaces
      // Ref: 8.1.3.5 and 22.2
      // Purpose : Ensure that the IUT having sent a REGISTER request, on receipt of an Unauthorized (401
      // Unauthorized) response including a WWW-Authenticate header, repeats its REGISTER request
      // with an Authorization header including proper values for username, realm nonce, digest-uri and
      // response HTTP parameters.
      {
        var REGISTER_Request vl_REGISTER_Request;
        var CSeq vl_first_CSeq;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        havingSentARegister(vl_REGISTER_Request);
        vl_first_CSeq := v_CSeq;
        
        // Send a Unauthorized (401 Unauthorized) response
        SIPP.send (
          Response_401_s_1(
            v_CallId,
            v_CSeq,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        TAck.start (PX_TACK);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          // REGISTER including an Authorization header and with an incremented
          // Cseq value.
          [] SIPP.receive (
            REGISTER_Request_r_14) -> value vl_REGISTER_Request sender v_sent_label {
            var charstring vl_myinput;
            TAck.stop;
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            // check if values for username, realm, nonce, digest-uri and response HTTP parameters
            // are included
            // vl_myinput := vl_REGISTER_Request.msgHeader.authorization.body;

            vl_myinput := f_convertCredentials(vl_REGISTER_Request.msgHeader.authorization.body);
            if (not (match(vl_myinput,
                  pattern "*username:*"))) {
              log ("Username missing in credentials.");
              setverdict (fail);
            }
            if (not (match(vl_myinput,
                  pattern "*realm:*"))) {
              log ("Realm missing in credentials.");
              setverdict (fail);
            }
            if (not (match(vl_myinput,
                  pattern "*nonce:*"))) {
              log ("Nonce missing in credentials.");
              setverdict (fail);
            }
            if (not (match(vl_myinput,
                  pattern "*uri:*"))) {
              log ("Digest-URI missing in credentials.");
              setverdict (fail);
            }
            if (not (match(vl_myinput,
                  pattern "*response:*"))) {
              log ("Response param missing in credentials.");
              setverdict (fail);
            }
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TAck.timeout {
            setverdict (fail);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT having sent a REGISTER request, on receipt of an Unauthorized (401 Unauthorized) response including a WWW-Authenticate header, repeats its REGISTER request with an Authorization header including proper values for username, realm nonce, digest-uri and response HTTP parameters.";
        extension "Reference: 8.1.3.5 and 22.2 [1]";
        
      } // end testcase SIP_RG_RT_V_018
      testcase SIP_RG_RT_V_019() runs on SipComponent system SipInterfaces
      // Ref: 8.1.3.5 and 22.2
      // Purpose : Ensure that the IUT having sent a REGISTER message, on receipt of a Proxy Authentication
      // Required (407 Proxy Authentication Required) response including a Proxy-Authenticate header,
      // repeats its REGISTER request with a Proxy-Authorization header and with an incremented Cseq
      //value.
      {
        var REGISTER_Request vl_REGISTER_Request;
        var CSeq vl_first_CSeq;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        havingSentARegister(vl_REGISTER_Request);
        vl_first_CSeq := v_CSeq;
        
        // Send a Unauthorized (407 Proxy Authentication Required) response
        SIPP.send (
          Response_407_s_1(
            v_CallId,
            v_CSeq,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        TAck.start (PX_TACK);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          // REGISTER including an Authorization header and with an incremented
          // Cseq value.
          [] SIPP.receive (
            REGISTER_Request_r_15) -> value vl_REGISTER_Request sender v_sent_label {
            TAck.stop;
            // Catch and prepare informations to answer
            setHeadersOnReceiptOfRegister(vl_REGISTER_Request);
            if (v_CSeq.seqNumber > vl_first_CSeq.seqNumber) {
              setverdict (pass);
            } else {
              log ("BEGIN_TRACE_INFO Cseq value not incremented. END_TRACE_INFO");
              setverdict (fail);
              SIPP.send (
                Response_400_s_1(
                  v_CallId,
                  v_CSeq,
                  v_From,
                  v_To,
                  v_Via)) to v_sent_label;
              
              stop
            }
            // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TAck.timeout {
            setverdict (fail);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT having sent a REGISTER message, on receipt of a Proxy Authentication Required (407 Proxy Authentication Required) response including a Proxy-Authenticate header, repeats its REGISTER request with a Proxy-Authorization header and with an incremented Cseq value. ";
        extension "Reference: 8.1.3.5 and 22.2 [1]";
        
      } // end testcase SIP_RG_RT_V_020
      testcase SIP_RG_RT_V_020() runs on SipComponent system SipInterfaces
      // Ref: 8.1.3.5 and 22.2
      // Purpose : Ensure that the IUT having sent a REGISTER message, on receipt of a Proxy Authentication
      // Required (407 Proxy Authentication Required) response including a Proxy-Authenticate header,
      // repeats its REGISTER request with a Proxy-Authorization header including proper values for
      // username, realm nonce, digest-uri and response HTTP parameters.
      {
        var REGISTER_Request vl_REGISTER_Request;
        var CSeq vl_first_CSeq;
        var charstring vl_mystring := "";
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        havingSentARegister(vl_REGISTER_Request);
        vl_first_CSeq := v_CSeq;
        
        // Send a Unauthorized (407 Proxy Authentication Required) response
        SIPP.send (
          Response_407_s_1(
            v_CallId,
            v_CSeq,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        TAck.start (PX_TACK);
        alt {
          // REGISTER message can be either received on multicast or unicast address
          // REGISTER including an Authorization header and with an incremented
          // Cseq value.
          [] SIPP.receive (
            REGISTER_Request_r_16) -> value vl_REGISTER_Request sender v_sent_label {
            var charstring vl_myinput;
            TAck.stop;
            setverdict (pass);
            
            // check if values for username, realm, nonce, digest-uri and response HTTP parameters
            // are included
            vl_myinput :=
            f_convertCredentials(vl_REGISTER_Request
              .msgHeader
              .proxyAuthorization
              .credentials);
            if (not (match(vl_myinput,
                  pattern "*username:*"))) {
              log ("Username missing in credentials.");
              setverdict (fail);
            }
            if (not (match(vl_myinput,
                  pattern "*realm:*"))) {
              log ("Realm missing in credentials.");
              setverdict (fail);
            }
            if (not (match(vl_myinput,
                  pattern "*nonce:*"))) {
              log ("Nonce missing in credentials.");
              setverdict (fail);
            }
            if (not (match(vl_myinput,
                  pattern "*uri:*"))) {
              log ("Digest-URI missing in credentials.");
              setverdict (fail);
            }
            if (not (match(vl_myinput,
                  pattern "*response:*"))) {
              log ("Response param missing in credentials.");
              setverdict (fail);
            }
            //              Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
            updateContactAddress_List(
              v_Contact,
              int2str (float2int (SHORT_REGISTRATION)));
            // Get current Date in format rfc1123-Date
            v_date := getCurrentGMTDate();
            // Send an Answer to the UA with a Date field
            // and the updated contact list
            SIPP.send (
              Response_Register_200_s_2(
                v_CallId,
                v_CSeq,
                v_From,
                v_To,
                v_Via,
                v_Contact,
                v_date)) to v_sent_label;
          }
          [] TAck.timeout {
            setverdict (fail);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT having sent a REGISTER message, on receipt of a Proxy Authentication Required (407 Proxy Authentication Required) response including a Proxy-Authenticate header, repeats its REGISTER request with a Proxy-Authorization header including proper values for username, realm nonce, digest-uri and response HTTP parameters. ";
        extension "Reference: 8.1.3.5 and 22.2 [1]";
        
      } // end testcase SIP_RG_RT_V_020
    } // end group ValidBehaviour
    group Timers {
      testcase SIP_RG_RT_TI_001() runs on SipComponent system SipInterfaces
      // Ref: Annex A and section 17.1.2.2
      // Purpose : If an unreliable transport is used, ensure that the IUT, having sent a REGISTER request, repeats its
      // request after timer E set to T1 value expires.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        havingSentARegister(vl_REGISTER_Request);
        repeatREGISTER(v_CallId, v_CSeq, PX_T1);
        
        // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
        updateContactAddress_List(
          v_Contact,
          int2str (float2int (SHORT_REGISTRATION)));
        // Get current Date in format rfc1123-Date
        v_date := getCurrentGMTDate();
        // Send an Answer to the UA with a Date field
        // and the updated contact list
        SIPP.send (
          Response_Register_200_s_2(
            v_CallId,
            v_CSeq,
            v_From,
            v_To,
            v_Via,
            v_Contact,
            v_date)) to v_sent_label;
        
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: If an unreliable transport is used, ensure that the IUT, having sent a REGISTER request, repeats its request after timer E set to T1 value expires.";
        extension "Reference: Annex A and section 17.1.2.2 [1]";
        
      } // end testcase SIP_RG_RT_TI_001
      testcase SIP_RG_RT_TI_002() runs on SipComponent system SipInterfaces
      // Ref: Annex A and section 17.1.3
      // Purpose : If an unreliable transport is used, ensure that the IUT, having sent twice times a REGISTER
      // request, repeats its request after timer E set to the MIN(2*T1,T2) value expires.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        havingSentARegister(vl_REGISTER_Request);
        repeatREGISTER(v_CallId, v_CSeq, PX_T1);
        SIPP.clear;
        notRepeatREGISTER(
          v_CallId,
          v_CSeq,
          2.0 * PX_T1 * 90.0 / 100.0);
        repeatREGISTER(
          v_CallId,
          v_CSeq,
          2.0 * PX_T1 * 20.0 / 100.0);
        
        // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
        updateContactAddress_List(
          v_Contact,
          int2str (float2int (SHORT_REGISTRATION)));
        // Get current Date in format rfc1123-Date
        v_date := getCurrentGMTDate();
        // Send an Answer to the UA with a Date field
        // and the updated contact list
        SIPP.send (
          Response_Register_200_s_2(
            v_CallId,
            v_CSeq,
            v_From,
            v_To,
            v_Via,
            v_Contact,
            v_date)) to v_sent_label;
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: If an unreliable transport is used, ensure that the IUT, having sent twice times a REGISTER request, repeats its request after timer E set to the MIN(2*T1,T2) value expires.";
        extension "Reference: Annex A and section 17.1.3 [1]";
        
      } // end testcase SIP_RG_RT_TI_002
      testcase SIP_RG_RT_TI_003() runs on SipComponent system SipInterfaces
      // Ref: Annex A and section 17.1.3
      // Purpose : If an unreliable transport is used, ensure that the IUT, having sent three times a REGISTER
      // request, repeats its request after timer E set to the MIN(4*T1,T2) value expires.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        havingSentARegister(vl_REGISTER_Request);
        repeatREGISTER(v_CallId, v_CSeq, PX_T1);
        SIPP.clear;
        notRepeatREGISTER(
          v_CallId,
          v_CSeq,
          2.0 * PX_T1 * 90.0 / 100.0);
        repeatREGISTER(
          v_CallId,
          v_CSeq,
          2.0 * PX_T1 * 20.0 / 100.0);
        SIPP.clear;
        notRepeatREGISTER(
          v_CallId,
          v_CSeq,
          4.0 * PX_T1 * 90.0 / 100.0);
        repeatREGISTER(
          v_CallId,
          v_CSeq,
          4.0 * PX_T1 * 20.0 / 100.0);
        
        // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
        updateContactAddress_List(
          v_Contact,
          int2str (float2int (SHORT_REGISTRATION)));
        // Get current Date in format rfc1123-Date
        v_date := getCurrentGMTDate();
        // Send an Answer to the UA with a Date field
        // and the updated contact list
        SIPP.send (
          Response_Register_200_s_2(
            v_CallId,
            v_CSeq,
            v_From,
            v_To,
            v_Via,
            v_Contact,
            v_date)) to v_sent_label;
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: If an unreliable transport is used, ensure that the IUT, having sent three times a REGISTER request, repeats its request after timer E set to the MIN(4*T1,T2) value expires.";
        extension "Reference: Annex A and section 17.1.3. [1]";
        
      } // end testcase SIP_RG_RT_TI_003
      testcase SIP_RG_RT_TI_004() runs on SipComponent system SipInterfaces
      // Ref: Annex A and section 17.1.3
      // Purpose : If an unreliable transport is used, ensure that the IUT does not repeat a REGISTER request, after
      // timer F set to 64*T1 expires.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        havingSentARegister(vl_REGISTER_Request);
        waitForTimeout_Register(64.0 * PX_T1);
        notRepeatREGISTER(
          v_CallId,
          v_CSeq,
          2.0 * PX_T1 * 90.0 / 100.0);
        
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: If an unreliable transport is used, ensure that the IUT does not repeat a REGISTER request, after timer F set to 64*T1 expires.";
        extension "Reference: Annex A and section 17.1.3. [1]";
        
      } // end testcase SIP_RG_RT_TI_004
      testcase SIP_RG_RT_TI_005() runs on SipComponent system SipInterfaces
      // Ref: Annex A and section 17.1.3
      // Purpose : Ensure that the IUT, when a REGISTER client transaction is in the Proceeding state, repeats its
      // REGISTER request after timer E set to T1 value expires.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        
        havingSentARegisterProceeding(vl_REGISTER_Request);
        repeatREGISTER(v_CallId, v_CSeq, PX_T1);
        
        // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
        updateContactAddress_List(
          v_Contact,
          int2str (float2int (SHORT_REGISTRATION)));
        // Get current Date in format rfc1123-Date
        v_date := getCurrentGMTDate();
        // Send an Answer to the UA with a Date field
        // and the updated contact list
        SIPP.send (
          Response_Register_200_s_2(
            v_CallId,
            v_CSeq,
            v_From,
            v_To,
            v_Via,
            v_Contact,
            v_date)) to v_sent_label;
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, when a REGISTER client transaction is in the Proceeding state, repeats its REGISTER request after timer E set to T1 value expires.";
        extension "Reference: Annex A and section 17.1.3. [1]";
        
      } // end testcase SIP_RG_RT_TI_005
      testcase SIP_RG_RT_TI_006() runs on SipComponent system SipInterfaces
      // Ref: Annex A and section 17.1.3.
      // Purpose : Ensure that the IUT, when a REGISTER client transaction is in the Proceeding state and
      // REGISTER request have been already repeated in this state, repeats its REGISTER request after
      // timer E set to T2 value expires.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        TWait.start (PX_TWAIT);
        havingSentARegisterProceeding(vl_REGISTER_Request);
        repeatREGISTER(v_CallId, v_CSeq, PX_T1);
        repeatREGISTER(v_CallId, v_CSeq, PX_T2);
        
        // Update contact list to set expiration of each contact to SHORT_REGISTRATION delay
        updateContactAddress_List(
          v_Contact,
          int2str (float2int (SHORT_REGISTRATION)));
        // Get current Date in format rfc1123-Date
        v_date := getCurrentGMTDate();
        // Send an Answer to the UA with a Date field
        // and the updated contact list
        SIPP.send (
          Response_Register_200_s_2(
            v_CallId,
            v_CSeq,
            v_From,
            v_To,
            v_Via,
            v_Contact,
            v_date)) to v_sent_label;
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, when a REGISTER client transaction is in the Proceeding state and REGISTER request have been already repeated in this state, repeats its REGISTER request after timer E set to T2 value expires.";
        extension "Reference: Annex A and section 17.1.3. [1]";
        
      } // end testcase SIP_RG_RT_TI_006
      testcase SIP_RG_RT_TI_007() runs on SipComponent system SipInterfaces
      // Ref: Annex A and section 17.1.3.
      // Purpose : Ensure that the IUT, when a REGISTER client transaction is in the Proceeding state, does not
      // repeat its REGISTER request, after timer F set to 64*T1 expires.
      {
        var REGISTER_Request vl_REGISTER_Request;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRT());
        havingSentARegisterProceeding(vl_REGISTER_Request);
        waitForTimeout_Register(64.0 * PX_T1);
        notRepeatREGISTER(
          v_CallId,
          v_CSeq,
          2.0 * PX_T1 * 90.0 / 100.0);
      }
      with {
        extension "Preconditions: IUT is declared as supporting periodic registration and can behave as User Agent";
        extension "Description: Ensure that the IUT, when a REGISTER client transaction is in the Proceeding state, does not repeat its REGISTER request, after timer F set to 64*T1 expires.";
        extension "Reference: Annex A and section 17.1.3. [1]";
        
      } // end testcase SIP_RG_RT_TI_007
    } //end group Timers
  } // end group Registrant
  group Registrar {
    // GroupSelection: IUT is a proxy or a redirect server entity.
    //
    group ValidBehaviour {
      testcase SIP_RG_RR_V_001(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER and without user name in
      //  the Request-URI, sends a Success (200 OK) response, containing all current bindings
      // listed in the Contact header, with the expires parameter for each Contact values.
      {
        var Response vl_Response;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        setHeadersForRegister(loc_CSeq_s);
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        if (ispresent (vl_Response.msgHeader.contact)) {
          var Contact vl_contact :=
          valueof (vl_Response.msgHeader.contact);
          if (checkExpiresContactAddresses(vl_contact
              .contactBody
              .contactAddresses,
              charstring_any_value)) {
            setverdict (pass)
          } else {
            log ("BEGIN_TRACE_INFO Missing Expires Parameters in Contact Header field. END_TRACE_INFO");
            setverdict (fail)
          }
        } else {
          log ("BEGIN_TRACE_INFO Missing Contact Header field. END_TRACE_INFO");
          setverdict (fail)
        };
        
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER and without user name in  the Request-URI, sends a Success (200 OK) response, containing all current bindings listed in the Contact header, with the expires parameter for each Contact values.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR Success (200 OK) response does not contain all current bindings listed in the Contact header OR Success (200 OK) response does not contain expired parameters for each Contact value OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_001
      testcase SIP_RG_RR_V_002(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER request including multiple
      // Contact header sends a Success (200 OK) response, and adds these addresses to
      //  the current bindings list.
      {
        var Response vl_Response;
        var UserInfo vl_userInfo := {
          userOrTelephoneSubscriber := PX_ETS_LOCAL_USER,
          password := omit
        };
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        // add an additional contact
        v_Contact.contactBody.contactAddresses[1] := {
          addressField := {
            nameAddr := {
              displayName := "ETSI ETS",
              addrSpec := { // SipUrl
                scheme := SIP_SCHEME,
                // contains "sip"
                userInfo := vl_userInfo,
                hostPort := {
                  host := PX_ETS_LOCAL_DOMAIN,
                  portField := omit },
                urlParameters := omit,
                //RGy (2007-09-14) headers field is added to complete the variable def. 
                headers := omit }
            }
          },
          contactParams := omit
        }
        
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        }
        v_From := {
          fieldName := FROM_E,
          addressField := v_To.addressField,
          fromParams := vl_params
        };
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        if (ispresent (vl_Response.msgHeader.contact)) {
          var Contact vl_contact :=
          valueof (vl_Response.msgHeader.contact);
          if (sizeof (vl_contact.contactBody.contactAddresses)
            == 2) {
            setverdict (pass)
          } else {
            log ("BEGIN_TRACE_INFO Number of ContactAddresses invalid (should be 2) END_TRACE_INFO");
            setverdict (fail)
          }
        } else {
          log ("BEGIN_TRACE_INFO Missing ContactAddresses. END_TRACE_INFO");
          setverdict (fail)
        };
        
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request including multiple Contact header sends a Success (200 OK) response, and adds these addresses to  the current bindings list.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR Success (200 OK) response does not contain two ContactAddresses OR Success (200 OK) response does not contain COntact Addresses at all OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_002
      testcase SIP_RG_RR_V_003(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref:  10.2 [1], 10.3 [1]
      // Purpose : Ensure that the IUT on receipt of a successive REGISTER with the same
      //  Call-ID but with different Contact header answers successively each of them with
      //  a Success (200 OK) response, and adds these addresses to the current bindings
      // list.
      {
        var Response vl_Response;
        var UserInfo vl_userInfo := {
          userOrTelephoneSubscriber := PX_ETS_LOCAL_USER,
          password := omit
        };
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        
        // First REGISTER wit one contact
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
        // Additional REGISTER with a new contact
        /////////////////////////////////////////
        // incremented CSeq
        loc_CSeq_s.seqNumber := loc_CSeq_s.seqNumber + 1;
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        }
        v_From.fromParams := vl_params;
        
        v_Contact.contactBody.contactAddresses[0] := {
          addressField := {
            nameAddr := {
              displayName := "ETSI ETS",
              addrSpec := { // SipUrl
                scheme := SIP_SCHEME,
                // contains "sip"
                userInfo := vl_userInfo,
                hostPort := {
                  host := PX_ETS_LOCAL_DOMAIN,
                  portField := omit },
                urlParameters := omit,
                //RGy (2007-09-14) headers field is added to complete the variable def. 
                headers := omit }
            }
          },
          contactParams := omit
        }
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        if (ispresent (vl_Response.msgHeader.contact)) {
          var Contact vl_contact :=
          valueof (vl_Response.msgHeader.contact);
          if (sizeof (vl_contact.contactBody.contactAddresses)
            == 2) {
            setverdict (pass)
          } else {
            log ("BEGIN_TRACE_INFO Number of Contact Addresses invalid (should be 2) END_TRACE_INFO");
            setverdict (fail)
          }
        } else {
          log ("BEGIN_TRACE_INFO Missing Contact Addresses. END_TRACE_INFO");
          setverdict (fail)
        };
        
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a successive REGISTER with the same  Call-ID but with different Contact header answers successively each of them with  a Success (200 OK) response, and adds these addresses to the current bindings  list.";
        extension "Reference:  10.2 [1], 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR Success (200 OK) response does not contain all current bindings listed in the Contact header OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_003
      testcase SIP_RG_RR_V_004(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.2 [1] , 10.3 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER request including a From
      //  header addressing a different entity than that addressed by the To header (third
      //  party registration), sends a Success (200 OK) response.
      {
        var Response vl_Response;
        var UserInfo vl_userInfo := {
          userOrTelephoneSubscriber := PX_ETS_LOCAL_THIRD_USER,
          password := omit
        };
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        // modify the From
        v_From.addressField.nameAddr := {
          displayName := "ETSI ETS VISITOR",
          addrSpec := { // SipUrl
            scheme := SIP_SCHEME, // contains "sip"
            userInfo := vl_userInfo,
            hostPort := {
              host := PX_ETS_LOCAL_DOMAIN,
              portField := omit },
            urlParameters := omit,
            //RGy (2007-11-21) headers field is added & set to omit
            headers := omit  
          }
        };
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request including a From  header addressing a different entity than that addressed by the To header (third  party registration), sends a Success (200 OK) response.";
        extension "Reference: 10.2 [1] , 10.3 [1] ";
        extension "FailCause: Invalid Success (200 OK) response received OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_004
      testcase SIP_RG_RR_V_005(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.2 [1] , 10.3 [1]
      // Purpose : Ensure that the IUT on receipt of periodic REGISTER request with the
      // same Call-ID and Contact header, and with an increasing CSeq number answers each
      //  of them with a Success (200 OK) response.
      {
        var Response vl_Response;
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        
        // First REGISTER wit one contact
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
        // Additional identical REGISTER
        /////////////////////////////////
        // incremented CSeq
        loc_CSeq_s.seqNumber := loc_CSeq_s.seqNumber + 1;
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        }
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
        // Additional identical REGISTER
        /////////////////////////////////
        // incremented CSeq
        loc_CSeq_s.seqNumber := loc_CSeq_s.seqNumber + 1;
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of periodic REGISTER request with the  same Call-ID and Contact header, and with an increasing CSeq number answers each  of them with a Success (200 OK) response.";
        extension "Reference: 10.2 [1] , 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) response received for each Request OR No Success (200 OK) response received for any Request";
      } // end testcase SIP_RG_RR_V_005
      testcase SIP_RG_RR_V_006(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref:  10.3[1], 10.2[1]
      // Purpose : Ensure that the IUT when the UA is already registered, on receipt of
      // REGISTER request without Contact header, sends a Success (200 OK) response including
      // the expiration time of the registration in an expires parameter in the Contact
      // header.
      {
        var Response vl_Response;
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        
        // First REGISTER wit one contact
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
        // Additional REGISTER  without contact
        ///////////////////////////////////////
        // incremented CSeq
        loc_CSeq_s.seqNumber := loc_CSeq_s.seqNumber + 1;
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_3(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_3(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        if (ispresent (vl_Response.msgHeader.contact)) {
          var Contact vl_contact :=
          valueof (vl_Response.msgHeader.contact);
          if (checkExpiresContactAddresses(vl_contact
              .contactBody
              .contactAddresses,
              charstring_any_value)) {
            setverdict (pass)
          } else {
            log ("BEGIN_TRACE_INFO Missing Expires Parameters in Contact Header field. END_TRACE_INFO");
            setverdict (fail)
          }
        } else {
          log ("BEGIN_TRACE_INFO Missing Contact Header field. END_TRACE_INFO");
          setverdict (fail)
        };
        
        removeRegistration(loc_CSeq_s);
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when the UA is already registered, on receipt of  REGISTER request without Contact header, sends a Success (200 OK) response including the expiration time of the registration in an expires parameter in the Contact header.";
        extension "Reference:  10.3[1], 10.2[1]";
        extension "FailCause: Invalid Success (200 OK) response received OR Success (200 OK) response received with missing Contact Header field or missing Expired Parameters in Contact Header field OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_006
      testcase SIP_RG_RR_V_007(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1], 10.2 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER request including an Expires
      // header, sends a Success (200 OK) response.
      {
        var Response vl_Response;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        
        SIPP.send (
          REGISTER_Request_s_2(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via,
            int2str (
              float2int (SHORT_REGISTRATION)))) to v_sent_label;
        
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_2(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via,
            int2str (float2int (SHORT_REGISTRATION))),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request including an Expires header, sends a Success (200 OK) response.";
        extension "Reference: 10.3 [1], 10.2 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_007
      testcase SIP_RG_RR_V_008(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1], 10.2 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER request including an Expires
      // parameter in the Contact header, sends a Success (200 OK) response.
      {
        var Response vl_Response;
        var SemicolonParam_List vl_params := {
          {
            id := EXPIRES_ID,
            paramValue :=
            int2str (float2int (SHORT_REGISTRATION))
          }
        };
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        
        // Update contact parameter
        v_Contact.contactBody.contactAddresses[0].contactParams :=
        vl_params;
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request including an Expires parameter in the Contact header, sends a Success (200 OK) response.";
        extension "Reference: 10.3 [1], 10.2 [1] ";
        extension "FailCause: Invalid Success (200 OK) response received OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_008
      testcase SIP_RG_RR_V_009(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1], 20.10 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER request including a Contact
      // header without display name, sends a Success (200 OK) response.
      {
        var Response vl_Response;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        
        // Update contact parameter
        v_Contact
        .contactBody
        .contactAddresses[0]
        .addressField
        .nameAddr
        .displayName :=
        omit;
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request including a Contact header without display name, sends a Success (200 OK) response.";
        extension "Reference: 10.3 [1], 20.10 [1] ";
        extension "FailCause: Invalid Success (200 OK) response received OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_009
      testcase SIP_RG_RR_V_010(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a binding already registered, on receipt of
      // a REGISTER request including a Contact header set to * and an Expires header set
      // to zero, and Call-ID is the same as the stored Call-ID value and CSeq is greater
      // than the stored CSeq value of that binding, removes that binding and sends a Sucess
      // (200 OK) response.
      {
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        contactRegistration(loc_CSeq_s);
        
        v_Contact := {
          fieldName := CONTACT_E,
          contactBody := { wildcard := "*" }
        };
        
        // incremented CSeq
        loc_CSeq_s.method := "REGISTER";
        loc_CSeq_s.seqNumber := loc_CSeq_s.seqNumber + 1;
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_2(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via,
            "0")) to v_sent_label;
        if (PX_REGISTRATION_AUTHENTICATION_ENABLED) {
          // Re-send request with Authorization header after
          // receiving 401 Unauthorized response.
          v_Branch := BRANCH_COOKIE & getRndTag();
          v_Via := {
            fieldName := VIA_E,
            viaBody := {
              valueof (ViaBody_ETS_IPADDR(v_Branch))}
          };
          awaitingUnauthorizedResponse(
            loc_CSeq_s,
            REGISTER_Request_s_2(
              v_RequestUri,
              v_CallIdReg,
              loc_CSeq_s,
              v_Contact,
              v_From,
              v_To,
              v_Via,
              "0"),
            PX_RFC2617_USERNAME,
            PX_RFC2617_PASSWD);
        } else {
          awaitingOkResponse(loc_CSeq_s);
        }
        
        // Additional REGISTER  without contact to check empty list in binding
        //////////////////////////////////////////////////////////////////////
        checkRemoveBinding(v_CallIdReg, loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a binding already registered, on receipt of  a REGISTER request including a Contact header set to * and an Expires header set to zero, and Call-ID is the same as the stored Call-ID value and CSeq is greater than the stored CSeq value of that binding, removes that binding and sends a Sucess (200 OK) response.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR Second Success (200 OK) response received with no empty contact list OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_010
      testcase SIP_RG_RR_V_011(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a binding already registered, on receipt of
      // a REGISTER request including a Contact header set to * and an Expires header set
      //  to zero, and Call-ID is different from the stored Call-ID value of that binding
      // , removes that binding and sends a Success (200 OK) response.
      {
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        contactRegistration(loc_CSeq_s);
        
        // New Call-ID
        v_CallId := {
          fieldName := CALL_ID_E,
          callid := getRndCallId() & AT & PX_ETS_IPADDR
        };
        
        v_Contact := {
          fieldName := CONTACT_E,
          contactBody := { wildcard := "*" }
        };
        
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_2(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via,
            "0")) to v_sent_label;
        
        if (PX_REGISTRATION_AUTHENTICATION_ENABLED) {
          // Re-send request with Authorization header after
          // receiving 401 Unauthorized response.
          v_Branch := BRANCH_COOKIE & getRndTag();
          v_Via := {
            fieldName := VIA_E,
            viaBody := {
              valueof (ViaBody_ETS_IPADDR(v_Branch))}
          };
          awaitingUnauthorizedResponse(
            loc_CSeq_s,
            REGISTER_Request_s_2(
              v_RequestUri,
              v_CallId,
              loc_CSeq_s,
              v_Contact,
              v_From,
              v_To,
              v_Via,
              "0"),
            PX_RFC2617_USERNAME,
            PX_RFC2617_PASSWD);
        } else {
          awaitingOkResponse(loc_CSeq_s);
        }
        // Additional REGISTER  without contact to check empty list in binding
        //////////////////////////////////////////////////////////////////////
        checkRemoveBinding(v_CallIdReg, loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a binding already registered, on receipt of  a REGISTER request including a Contact header set to * and an Expires header set  to zero, and Call-ID is different from the stored Call-ID value of that binding , removes that binding and sends a Success (200 OK) response.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR Second Success (200 OK) response received with no empty contact list OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_011
      
      testcase SIP_RG_RR_V_012(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a binding already registered, on receipt of
      // a REGISTER request including a Contact header set to an address which is not in
      // the bindings list, and the received expiration time other than zero, and Call-ID
      // is different from the stored Call-ID value of that binding adds that
      // binding to the list and sends a Success (200 OK) response.
      {
        var Response vl_Response;
        var UserInfo vl_userInfo := {
          userOrTelephoneSubscriber := PX_ETS_LOCAL_USER,
          password := omit
        };
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        contactRegistration(loc_CSeq_s);
        
        // Additional REGISTER with a new contact
        /////////////////////////////////////////
        // New Call-ID
        v_CallId := {
          fieldName := CALL_ID_E,
          callid := getRndCallId() & AT & PX_ETS_IPADDR
        };
        v_CallIdReg := v_CallId;
        vl_params := {
          {
            id := EXPIRES_ID,
            paramValue :=
            int2str (float2int (SHORT_REGISTRATION))
          }
        };
        v_Contact.contactBody.contactAddresses[0] := {
          addressField := {
            nameAddr := {
              displayName := "ETSI ETS",
              addrSpec := { // SipUrl
                scheme := SIP_SCHEME,
                // contains "sip"
                userInfo := vl_userInfo,
                hostPort := {
                  host := PX_ETS_LOCAL_DOMAIN,
                  portField := omit },
                urlParameters := omit,
                //RGy (2007-09-14) headers field is added to complete the variable def. 
                headers := omit  }
            }
          },
          contactParams := vl_params
        };
        
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallId,
          loc_CSeq_s,
          vl_Response);
        // STF296 - CR3 V. M. Puro 24/01/2005 11:21
        // Check that v_CallId instead of v_CallIdReg is used in awaitingRegisterOkResponse
        if (ispresent (vl_Response.msgHeader.contact)) {
          var Contact vl_contact :=
          valueof (vl_Response.msgHeader.contact);
          if (sizeof (vl_contact.contactBody.contactAddresses)
            == 2) {
            setverdict (pass)
          } else {
            log ("BEGIN_TRACE_INFO Number of Contact Addresses invalid (should be 2) END_TRACE_INFO");
            setverdict (fail)
          }
        } else {
          log ("BEGIN_TRACE_INFO Missing Contact Addresses. END_TRACE_INFO");
          setverdict (fail)
        };
        
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a binding already registered, on receipt of  a REGISTER request including a Contact header set to an address which is not in  the bindings list, and the received expiration time other than zero, and Call-ID  is different from the stored Call-ID value of that binding adds that binding to the list and sends a Success (200 OK) response.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR Second Success (200 OK) response received with incorrect number of Contact Addresses OR Second Success (200 OK) response received with no Contact Header OR  No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_012
      testcase SIP_RG_RR_V_013(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a binding already registered, on receipt of
      // a REGISTER request including a Contact header set to an address which is in the
      // bindings list with a Call-ID different from the value stored for that binding,
      // and an expiration time other than zero, sends a Success (200 OK) response.
      {
        var Response vl_Response;
        var SemicolonParam_List vl_params := {
          {
            id := EXPIRES_ID,
            paramValue :=
            int2str (float2int (SHORT_REGISTRATION))
          }
        };
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        contactRegistration(loc_CSeq_s);
        
        // Additional REGISTER with a new contact
        /////////////////////////////////////////
        // New Call-ID
        v_CallId := {
          fieldName := CALL_ID_E,
          callid := getRndCallId() & AT & PX_ETS_IPADDR
        };
        v_CallIdReg := v_CallId;
        v_Contact.contactBody.contactAddresses[0].contactParams :=
        vl_params;
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallId,
          loc_CSeq_s,
          vl_Response);
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a binding already registered, on receipt of  a REGISTER request including a Contact header set to an address which is in the  bindings list with a Call-ID different from the value stored for that binding, and an expiration time other than zero, sends a Success (200 OK) response.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_013
      testcase SIP_RG_RR_V_014(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a binding already registered, on receipt of
      // a REGISTER request including a Contact header set to an address which is in the
      // bindings list with a Call-ID different from the value stored for that binding, and
      // an expiration time set to zero, deletes that binding and sends a Success (200
      // OK) response.
      {
        var Response vl_Response;
        var UserInfo vl_userInfo := {
          userOrTelephoneSubscriber := PX_ETS_LOCAL_USER,
          password := omit
        };
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        // Registration of two contacts
        ///////////////////////////////
        setHeadersForRegister(loc_CSeq_s);
        // add an additional contact
        v_Contact.contactBody.contactAddresses[1] := {
          addressField := {
            nameAddr := {
              displayName := "ETSI ETS",
              addrSpec := { // SipUrl
                scheme := SIP_SCHEME,
                // contains "sip"
                userInfo := vl_userInfo,
                hostPort := {
                  host := PX_ETS_LOCAL_DOMAIN,
                  portField := omit },
                urlParameters := omit,
                //RGy (2007-09-14) headers field is added to complete the variable def. 
                headers := omit  }
            }
          },
          contactParams := omit
        };
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
        // Registration of one of the contact with expires set to 0 and a new call-ID
        /////////////////////////////////////////////////////////////////////////////
        vl_params := {
          {
            id := EXPIRES_ID,
            paramValue := "0"
          }
        };
        v_Contact.contactBody.contactAddresses := {
          {
            addressField := {
              nameAddr := {
                displayName := "ETSI ETS",
                addrSpec := { // SipUrl
                  scheme := SIP_SCHEME,
                  // contains "sip"
                  userInfo := vl_userInfo,
                  hostPort := {
                    host := PX_ETS_LOCAL_DOMAIN,
                    portField := omit },
                  urlParameters := omit,
                  //RGy (2007-09-14) headers field is added to complete the variable def. 
                  headers := omit  }
              }
            },
            contactParams := vl_params
          }
        }
        // New Call-ID
        v_CallId := {
          fieldName := CALL_ID_E,
          callid := getRndCallId() & AT & PX_ETS_IPADDR
        };
        v_CallIdReg := v_CallId;
        // incremented CSeq
        loc_CSeq_s.seqNumber := loc_CSeq_s.seqNumber + 1;
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallId,
          loc_CSeq_s,
          vl_Response);
        
        // Check that the IUT has removed the binding
        //////////////////////////////////////////////
        checkNumberOfBinding(v_CallId, loc_CSeq_s, 1);
        
        removeRegistration(loc_CSeq_s);
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a binding already registered, on receipt of  a REGISTER request including a Contact header set to an address which is in the  bindings list with a Call-ID different from the value stored for that binding, and an expiration time set to zero, deletes that binding and sends a Success (200  OK) response.";
        extension "Reference: 10.3 [1] ";
        extension "FailCause: Invalid Success (200 OK) response received OR Second Success (200 OK) response received with no removed contact Address from the contact list OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_014
      testcase SIP_RG_RR_V_015(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a binding already registered, on receipt of
      // a REGISTER request including a Contact header set to an address which is in the
      // bindings list with the same Call-ID as the value stored for that binding, CSeq is
      // greater than the stored CSeq value of that binding,  and an expiration time other
      //  than zero, sends a Success (200 OK) response.
      {
        var Response vl_Response;
        var SemicolonParam_List vl_params := {
          {
            id := EXPIRES_ID,
            paramValue :=
            int2str (float2int (SHORT_REGISTRATION))
          }
        };
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        contactRegistration(loc_CSeq_s);
        
        // Additional REGISTER with same contact and same Call-ID and a non null expiration parameter
        ////////////////////////////////////////////////////////////////////////////////////////////
        v_Contact.contactBody.contactAddresses[0].contactParams :=
        vl_params;
        
        // incremented CSeq
        loc_CSeq_s.seqNumber := loc_CSeq_s.seqNumber + 1;
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a binding already registered, on receipt of  a REGISTER request including a Contact header set to an address which is in the  bindings list with the same Call-ID as the value stored for that binding, CSeq is greater than the stored CSeq value of that binding,  and an expiration time other  than zero, sends a Success (200 OK) response.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: First or second Invalid Success (200 OK) response received OR No first or second Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_015
      testcase SIP_RG_RR_V_016(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a binding already registered, on receipt of
      // a REGISTER request including a Contact header set to an address which is in the
      // bindings list with the same Call-ID as the value stored for that binding, CSeq
      // is greater than the stored CSeq value of that binding,  and an expiration time
      // equal to zero, deletes that binding and sends a Success (200 OK) response.
      {
        var Response vl_Response;
        var SemicolonParam_List vl_params := {
          {
            id := EXPIRES_ID,
            paramValue := "0"
          }
        };
        var UserInfo vl_userInfo := {
          userOrTelephoneSubscriber := PX_ETS_LOCAL_USER,
          password := omit
        };
        var ContactAddress vl_contactAddress;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        // Registration of two contacts
        ///////////////////////////////
        setHeadersForRegister(loc_CSeq_s);
        // add an additional contact
        v_Contact.contactBody.contactAddresses[1] := {
          addressField := {
            nameAddr := {
              displayName := "ETSI ETS",
              addrSpec := { // SipUrl
                scheme := SIP_SCHEME,
                // contains "sip"
                userInfo := vl_userInfo,
                hostPort := {
                  host := PX_ETS_LOCAL_DOMAIN,
                  portField := omit },
                urlParameters := omit,
                //RGy (2007-09-14) headers field is added to complete the variable def. 
                headers := omit  }
            }
          },
          contactParams := omit
        };
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
        // Additional REGISTER with same contact and same Call-ID and a null expiration parameter
        ////////////////////////////////////////////////////////////////////////////////////////////
        vl_contactAddress :=
        v_Contact.contactBody.contactAddresses[0];
        vl_contactAddress.contactParams := vl_params;
        v_Contact.contactBody.contactAddresses := {
          vl_contactAddress
        };
        
        // incremented CSeq
        loc_CSeq_s.seqNumber := loc_CSeq_s.seqNumber + 1;
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
        // Check that the IUT has removed the binding
        //////////////////////////////////////////////
        checkNumberOfBinding(v_CallIdReg, loc_CSeq_s, 1);
        
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a binding already registered, on receipt of  a REGISTER request including a Contact header set to an address which is in the  bindings list with the same Call-ID as the value stored for that binding, CSeq  is greater than the stored CSeq value of that binding,  and an expiration time equal to zero, deletes that binding and sends a Success (200 OK) response.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) received OR Second Success (200 OK) response received with no removed contact Address from the contact list OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_016
      testcase SIP_RG_RR_V_017(
        inout CSeq loc_CSeq_s,
        inout CSeq loc_CSeq_ptc_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a call is currently established, on receipt
      // of a REGISTER request, sends a Success (200 OK) response.
      {
        var SipComponent vl_ptc := SipComponent.create;
        
        initConfig1(mtc, vl_ptc, system);
        v_reg_done := true;
        TGuard.start (PX_TGUARD);
        
        vl_ptc.start (ptc_RG_RR_V_017(loc_CSeq_ptc_s));
        
        //**************************************************
        //*******   MTC   Behaviour
        //**************************************************
        initMTC(loc_CSeq_s);
        v_Default := activate (defaultRGRR());
        
        establishACall(loc_CSeq_s);
        synchroniseCheck();
        terminateCall(
          v_CallId,
          loc_CSeq_s,
          v_caller_From,
          v_caller_To,
          v_reqHostPort,
          v_Route);
        synchroniseCheckDone();
        // free the call
        // wait the end of PTC
        wait_end_ptc(vl_ptc);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a call is currently established, on receipt  of a REGISTER request, sends a Success (200 OK) response.";
        extension "Reference: 10.3 [1] ";
        extension "FailCause: Invalid established Call (receive non INVITE Success (200 OK) response) OR Invalid REGISTER Success (200 OK) response received OR No REGISTER Success (200 OK) response received";
      } // end testcase SIP_RG_RR_V_017
      testcase SIP_RG_RR_V_018(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1] item 3 and 22.2 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER request not including an
      //  Authorization header field, sends an Unauthorized (401 Unauthorized) response or
      //  Proxy Authentication Requires (407), containg a WWW-Authenticate header or a Proxy
      //  Authenticate header.
      {
        var Response vl_Response;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        // Registration without Authorization field
        ///////////////////////////////////////////
        setHeadersForRegister(loc_CSeq_s);
        
        SIPP.send (
          REGISTER_Request_s_4(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        TAck.start (PX_TACK);
        alt {
          [] SIPP.receive (
            Response_401_r_1(v_CallIdReg, loc_CSeq_s)) {
            TAck.stop;
            setverdict (pass);
          }
          [
            not (PC_STATELESS)] SIPP.receive (
            Response_1XX_r_1(v_CallIdReg, loc_CSeq_s)) {
            repeat;
          }
          [] SIPP.receive (
            Response_407_r_1(v_CallId, loc_CSeq_s)) {
            TAck.stop;
            setverdict (pass);
          }
          [] SIPP.receive {
            all timer.stop;
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
          [] TAck.timeout {
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request not including an  Authorization header field, sends an Unauthorized (401 Unauthorized) response, or Proxy Authentication Requires (407), containg a WWW-Authenticate header or a Proxy Authenticate header.";
        extension "Reference: 10.3 [1] item 3 and 22.2 [1]";
        extension "FailCause: Invalid Unauthorized (401 Unauthorized) response received OR Authorization header field missing in received Invalid Unauthorized (401 Unauthorized) response OR No Unauthorized (401 Unauthorized) response received";
      } // end testcase SIP_RG_RR_V_018
      testcase SIP_RG_RR_V_019(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1] item 4
      // Purpose : Ensure that the IUT on receipt of a REGISTER request, but the authenticated
      // user not authorized to modify this address-of record, sends a Forbidden
      // (403 Forbidden) response.
      {
        var Response vl_Response;
        var SemicolonParam_List vl_params;
        var UserInfo vl_userInfo := {
          userOrTelephoneSubscriber := PX_ETS_UNAUTHORIZED_USER,
          password := omit
        };
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        
        // Update To to a not authorized address-of-record
        v_To := {
          fieldName := TO_E,
          addressField := {
            nameAddr := { displayName := "ETSI Tester",
              // optional charstring
              addrSpec := { // SipUrl
                scheme := SIP_SCHEME,
                // contains "sip"
                userInfo := vl_userInfo,
                hostPort := {
                  host := PX_ETS_LOCAL_DOMAIN,
                  portField := omit },
                urlParameters := omit,
                headers := omit }
            }
          }, //addressField
          toParams := omit // optional set of GenericParam
        }; // v_To
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        }
        v_From := {
          fieldName := FROM_E,
          addressField := v_To.addressField,
          fromParams := vl_params
        };
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        if (PX_REGISTRATION_AUTHENTICATION_ENABLED) {
          var CommaParam_List vl_challenge;
          //var charstring vl_Credentials;
          var Credentials vl_Credentials;
          var Request vl_Request :=
          valueof (
            REGISTER_Request_s_1(
              v_RequestUri,
              v_CallIdReg,
              loc_CSeq_s,
              v_Contact,
              v_From,
              v_To,
              v_Via));
          
          TAck.start (PX_TACK);
          alt {
            [] SIPP.receive (
              Response_401_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Authorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .wwwAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .wwwAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
                
              } else {
                log ("No scheme in www-Authenticate header !!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              vl_Request.msgHeader.cSeq.seqNumber :=
              loc_CSeq_s.seqNumber;
              vl_Request.msgHeader.authorization.fieldName :=
              AUTHORIZATION_E;
              vl_Request.msgHeader.authorization.body :=
              vl_Credentials;
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (vl_Request) to v_sent_label;
            }
            [] SIPP.receive (
              Response_407_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Proxyauthorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .proxyAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .proxyAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
              } else {
                log ("No scheme in Proxy Authenticate header!!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              vl_Request.msgHeader.cSeq.seqNumber :=
              loc_CSeq_s.seqNumber;
              vl_Request
              .msgHeader
              .proxyAuthorization
              .fieldName :=
              PROXY_AUTHORIZATION_E;
              vl_Request
              .msgHeader
              .proxyAuthorization
              .credentials :=
              vl_Credentials;
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (vl_Request) to v_sent_label;
            }
            [(not (PC_STATELESS))
              and mandatory] SIPP.receive (
              Response_1XX_r_1(v_CallId, loc_CSeq_s)) {
              repeat;
            }
            [] SIPP.receive (
              Response_200_r_1(v_CallId, loc_CSeq_s)) {
              TAck.stop;
              log ("Authorization was not requested as expected");
              setverdict (inconc);
              stop
            }
            [] SIPP.receive {
              all timer.stop;
              setverdict (inconc);
              stop
            }
            [] TAck.timeout {
              setverdict (inconc);
              stop
            }
          }
        };
        
        TAck.start (PX_TACK);
        alt {
          [] SIPP.receive (
            Response_403_r_1(v_CallIdReg, loc_CSeq_s)) {
            TAck.stop;
            setverdict (pass);
          }
          
          [
            not (PC_STATELESS)] SIPP.receive (
            Response_1XX_r_1(v_CallIdReg, loc_CSeq_s)) {
            repeat;
          }
          [] SIPP.receive {
            all timer.stop;
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
          [] TAck.timeout {
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request, but the authenticated user not authorized to modify this address-of record, sends a Forbidden  (403 Forbidden) response.";
        extension "Reference: 10.3 [1] item 4";
        extension "FailCause: Invalid Forbidden (403 Forbidden) response received OR No Forbidden (403 Forbidden) response received";
      } // end testcase SIP_RG_RR_V_019
      testcase SIP_RG_RR_V_020(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.2.1.2
      // Purpose: Ensure that the IUT on receipt of a REGISTER and including "q" Contact header parameter, sends
      // a Success (200 OK) response.
      {
        var Response vl_Response;
        var UserInfo vl_userInfo := {
          userOrTelephoneSubscriber := PX_ETS_LOCAL_USER,
          password := omit
        };
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        
        v_Contact.contactBody.contactAddresses[0].contactParams := {
          {
            id := "q",
            paramValue := "0.5"
          }
        };
        
        // First REGISTER with one contact
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER and including ""q"" Contact header parameter, sends a Success (200 OK) response.";
        extension "Reference: 10.2.1.2 [1]";
        
      } // end testcase SIP_RG_RR_V_020
      testcase SIP_RG_RR_V_021(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3, item 3 and 22.2
      // Purpose: Ensure that the IUT on receipt of a REGISTER request not including an Authorization or a
      // Proxy-Authorization header fields, sends an Unauthorized (401 Unauthorized) or Proxy
      // Authentication Required (407 Proxy Authentication Required) response, containing a WWWAuthenticate
      // or a Proxy-Authenticate header including proper value for realm and nonce HTTP
      // parameters.
      {
        var Response vl_Response;
        var charstring vl_nonce;
        var charstring vl_realm;
        var CommaParam_List vl_challenge;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        // Registration without Authorization field
        ///////////////////////////////////////////
        setHeadersForRegister(loc_CSeq_s);
        
        SIPP.send (
          REGISTER_Request_s_4(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        TAck.start (PX_TACK);
        alt {
          [] SIPP.receive (
            Response_401_r_1(
              v_CallIdReg,
              loc_CSeq_s)) -> value vl_Response {
            setverdict (pass);
            //  check if values for realm and nonce are included
            if (ischosen (vl_Response
                .msgHeader
                .wwwAuthenticate
                .challenge[0]
                .digestCln)) {
              vl_challenge :=
              vl_Response
              .msgHeader
              .wwwAuthenticate
              .challenge[0]
              .digestCln;
              vl_nonce :=
              extractParamValueFromChallenge(
                vl_challenge,
                "nonce");
              if (vl_nonce == "") {
                setverdict (fail);
                stop;
              }
              vl_realm :=
              extractParamValueFromChallenge(
                vl_challenge,
                "realm");
              if (vl_realm == "") {
                setverdict (fail);
              }
            } else {
              log ("No scheme in www-Authenticate header !!");
              setverdict (inconc);
              stop;
            }
            TAck.stop;
            setverdict (pass);
          }
          [
            not (PC_STATELESS)] SIPP.receive (
            Response_1XX_r_1(v_CallIdReg, loc_CSeq_s)) {
            repeat;
          }
          [] SIPP.receive (
            Response_407_r_1(
              v_CallId,
              loc_CSeq_s)) -> value vl_Response {
            setverdict (pass);
            // check if values for realm and nonce are included
            if (ischosen (vl_Response
                .msgHeader
                .proxyAuthenticate
                .challenge[0]
                .digestCln)) {
              vl_challenge :=
              vl_Response
              .msgHeader
              .proxyAuthenticate
              .challenge[0]
              .digestCln;
              vl_nonce :=
              extractParamValueFromChallenge(
                vl_challenge,
                "nonce");
              if (vl_nonce == "") {
                setverdict (fail);
                stop;
              }
              vl_realm :=
              extractParamValueFromChallenge(
                vl_challenge,
                "realm");
              if (vl_realm == "") {
                setverdict (fail);
              }
            } else {
              log ("No scheme in Proxy-Authenticate header !!");
              setverdict (inconc);
              stop;
            }
            TAck.stop;
            setverdict (pass);
          }
          [] SIPP.receive {
            all timer.stop;
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
          [] TAck.timeout {
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request not including an Authorization or a Proxy-Authorization header fields, sends an Unauthorized (401 Unauthorized) or Proxy Authentication Required (407 Proxy Authentication Required) response, containing a WWWAuthenticate or a Proxy-Authenticate header including proper value for realm and nonce HTTP parameters.";
        extension "Reference: 10.3, item 3 and 22.2 [1]";
        
      } // end testcase SIP_RG_RR_V_021
      testcase SIP_RG_RR_V_022(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3, item 3 and 22.2.
      // Purpose: Ensure that the IUT having sent an Unauthorized (401 Unauthorized ) or a Proxy Authentication
      // Required (407 Proxy Authentication Required) response to a REGISTER request, on receipt of a
      // REGISTER request including a valid Authorization or Proxy-Authorization header field, sends a
      // Success (200 OK) response.
      {
        var CommaParam_List vl_challenge;
        //var charstring vl_Credentials;
        var Credentials vl_Credentials;
        var Request vl_Request :=
        valueof (
          REGISTER_Request_s_4(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via));
        
        var Response vl_Response;
        var charstring vl_nonce;
        var charstring vl_realm;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        // Registration without Authorization field
        ///////////////////////////////////////////
        setHeadersForRegister(loc_CSeq_s);
        
        SIPP.send (
          REGISTER_Request_s_4(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        TAck.start (PX_TACK);
        alt {
          [] SIPP.receive (
            Response_401_r_1(
              v_CallId,
              loc_CSeq_s)) -> value vl_Response {
            TAck.stop;
            setverdict (pass);
            // resent the REGISTER message with Authorization header include
            // Extract challenge and calculate credentials for a response.
            if (ischosen (vl_Response
                .msgHeader
                .wwwAuthenticate
                .challenge[0]
                .digestCln)) {
              vl_challenge :=
              vl_Response
              .msgHeader
              .wwwAuthenticate
              .challenge[0]
              .digestCln;
              vl_Credentials :=
              calculateCredentials(
                "REGISTER",
                vl_challenge,
                PX_RFC2617_USERNAME,
                PX_RFC2617_PASSWD);
              
            } else {
              log ("No scheme in www-Authenticate header !!");
              setverdict (inconc);
              stop;
            }
            
            // Increment CSeq sequence number of and add the credentials
            // to the original saved REGEISTER message.
            loc_CSeq_s.seqNumber := loc_CSeq_s.seqNumber + 1;
            vl_Request.msgHeader.cSeq.seqNumber :=
            loc_CSeq_s.seqNumber;
            vl_Request.msgHeader.authorization.fieldName :=
            AUTHORIZATION_E;
            vl_Request.msgHeader.authorization.body :=
            vl_Credentials;
            
            // Re-send the saved REGISTER with Authorization header
            // included.
            SIPP.send (vl_Request) to v_sent_label;
          }
          [] SIPP.receive (
            Response_407_r_1(
              v_CallId,
              loc_CSeq_s)) -> value vl_Response {
            TAck.stop;
            setverdict (pass);
            // resent the REGISTER message with Proxyauthorization header include
            // Extract challenge and calculate credentials for a response.
            if (ischosen (vl_Response
                .msgHeader
                .proxyAuthenticate
                .challenge[0]
                .digestCln)) {
              vl_challenge :=
              vl_Response
              .msgHeader
              .proxyAuthenticate
              .challenge[0]
              .digestCln;
              vl_Credentials :=
              calculateCredentials(
                "REGISTER",
                vl_challenge,
                PX_RFC2617_USERNAME,
                PX_RFC2617_PASSWD);
            } else {
              log ("No scheme in Proxy Authenticate header!!");
              setverdict (inconc);
              stop;
            }
            
            // Increment CSeq sequence number of and add the credentials
            // to the original saved REGEISTER message.
            loc_CSeq_s.seqNumber := loc_CSeq_s.seqNumber + 1;
            vl_Request.msgHeader.cSeq.seqNumber :=
            loc_CSeq_s.seqNumber;
            vl_Request.msgHeader.proxyAuthorization.fieldName :=
            PROXY_AUTHORIZATION_E;
            vl_Request.msgHeader.proxyAuthorization.credentials :=
            vl_Credentials;
            
            // Re-send the saved REGISTER with Authorization header
            // included.
            SIPP.send (vl_Request) to v_sent_label;
          }
          [(not (PC_STATELESS))
            and mandatory] SIPP.receive (
            Response_1XX_r_1(v_CallId, loc_CSeq_s)) {
            repeat;
          }
          [] SIPP.receive (
            Response_200_r_1(v_CallId, loc_CSeq_s)) {
            TAck.stop;
            log ("Authorization was not requested as expected");
            setverdict (inconc);
            stop
          }
          [] SIPP.receive {
            all timer.stop;
            setverdict (inconc);
            stop
          }
          [] TAck.timeout {
            setverdict (inconc);
            stop
          }
        }
        TAck.start (PX_TACK);
        alt {
          [] SIPP.receive (
            Response_200_r_1(v_CallIdReg, loc_CSeq_s)) {
            TAck.stop;
            setverdict (pass);
          }
          [
            not (PC_STATELESS)] SIPP.receive (
            Response_1XX_r_1(v_CallIdReg, loc_CSeq_s)) {
            repeat;
          }
          [] SIPP.receive {
            all timer.stop;
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
          [] TAck.timeout {
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT having sent an Unauthorized (401 Unauthorized ) or a Proxy Authentication Required (407 Proxy Authentication Required) response to a REGISTER request, on receipt of a REGISTER request including a valid Authorization or Proxy-Authorization header field, sends a Success (200 OK) response.";
        extension "Reference: 10.3, item 3 and 22.2 [1]";
        
      } // end testcase SIP_RG_RR_V_022
    } // end group ValidBehaviour
    group InvalidBehaviour {
      testcase SIP_RG_RR_I_001(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER request including a To
      // header from which the extracted address-of-record is not valid for the domain in
      // the Request-URI, sends a Request Failure (404 Not Found) response.
      {
        var Response vl_Response;
        var UserInfo vl_userInfo := {
          userOrTelephoneSubscriber := PX_ETS_LOCAL_USER,
          password := omit
        };
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        // Registration with an invalid To field
        ///////////////////////////////////////////
        setHeadersForRegister(loc_CSeq_s);
        
        // Update To to an unknown address-of-record
        v_To := {
          fieldName := TO_E,
          addressField := {
            nameAddr := { displayName := "ETSI Tester",
              // optional charstring
              addrSpec := { // SipUrl
                scheme := SIP_SCHEME,
                // contains "sip"
                userInfo := vl_userInfo,
                hostPort := {
                  host := PX_UNKNOWN_DOMAIN,
                  portField := omit },
                urlParameters := omit,
                headers := omit }
            }
          }, //addressField
          toParams := omit // optional set of GenericParam
        }; // v_To
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        
        if (PX_REGISTRATION_AUTHENTICATION_ENABLED) {
          var CommaParam_List vl_challenge;
          //var charstring vl_Credentials;
          var Credentials vl_Credentials;
          var Request vl_Request :=
          valueof (
            REGISTER_Request_s_1(
              v_RequestUri,
              v_CallIdReg,
              loc_CSeq_s,
              v_Contact,
              v_From,
              v_To,
              v_Via));
          
          TAck.start (PX_TACK);
          alt {
            [] SIPP.receive (
              Response_401_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Authorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .wwwAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .wwwAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
                
              } else {
                log ("No scheme in www-Authenticate header !!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              vl_Request.msgHeader.cSeq.seqNumber :=
              loc_CSeq_s.seqNumber;
              vl_Request.msgHeader.authorization.fieldName :=
              AUTHORIZATION_E;
              vl_Request.msgHeader.authorization.body :=
              vl_Credentials;
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (vl_Request) to v_sent_label;
            }
            [] SIPP.receive (
              Response_407_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Proxyauthorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .proxyAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .proxyAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
              } else {
                log ("No scheme in Proxy Authenticate header!!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              vl_Request.msgHeader.cSeq.seqNumber :=
              loc_CSeq_s.seqNumber;
              vl_Request
              .msgHeader
              .proxyAuthorization
              .fieldName :=
              PROXY_AUTHORIZATION_E;
              vl_Request
              .msgHeader
              .proxyAuthorization
              .credentials :=
              vl_Credentials;
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (vl_Request) to v_sent_label;
            }
            [(not (PC_STATELESS))
              and mandatory] SIPP.receive (
              Response_1XX_r_1(v_CallId, loc_CSeq_s)) {
              repeat;
            }
            [] SIPP.receive (
              Response_200_r_1(v_CallId, loc_CSeq_s)) {
              TAck.stop;
              log ("Authorization was not requested as expected");
              setverdict (inconc);
              stop
            }
            [] SIPP.receive {
              all timer.stop;
              setverdict (inconc);
              stop
            }
            [] TAck.timeout {
              setverdict (inconc);
              stop
            }
          }
        };
        
        TAck.start (PX_TACK);
        alt {
          [] SIPP.receive (
            Response_404_r_1(v_CallIdReg, loc_CSeq_s)) {
            TAck.stop;
            setverdict (pass);
          }
          [
            not (PC_STATELESS)] SIPP.receive (
            Response_1XX_r_1(v_CallIdReg, loc_CSeq_s)) {
            repeat;
          }
          [] SIPP.receive {
            all timer.stop;
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
          [] TAck.timeout {
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request including a To  header from which the extracted address-of-record is not valid for the domain in  the Request-URI, sends a Request Failure (404 Not Found) response.";
        extension "Reference: 10.3 [1] ";
        extension "FailCause: Invalid Request-Failure (404 Not Found) response received OR No Request-Failure (404 Not Found)  response received";
      } // end testcase SIP_RG_RR_I_001
      testcase SIP_RG_RR_I_002(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1] , 19.1.1 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER request including a user
      //  name in the SIP URI as the Request-URI, sends a Success (200 OK) response.
      {
        var Response vl_Response;
        var UserInfo vl_userInfo := {
          userOrTelephoneSubscriber := "IUT",
          password := omit
        };
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        
        // Update v_RequestUri
        v_RequestUri := {
          scheme := SIP_SCHEME,
          userInfo := vl_userInfo,
          hostPort := {
            host := PX_IUT_HOME_DOMAIN,
            portField := PX_IUT_PORT },
          urlParameters := omit,
          headers := omit
        };
        
        SIPP.send (
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via)) to v_sent_label;
        v_Branch := BRANCH_COOKIE & getRndTag();
        v_Via := {
          fieldName := VIA_E,
          viaBody := { valueof (ViaBody_ETS_IPADDR(v_Branch))}
        };
        
        awaitingRegisterOkResponse(
          REGISTER_Request_s_1(
            v_RequestUri,
            v_CallIdReg,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via),
          v_CallIdReg,
          loc_CSeq_s,
          vl_Response);
        
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request including a user  name in the SIP URI as the Request-URI, sends a Success (200 OK) response. ";
        extension "Reference: 10.3 [1] , 19.1.1 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_I_002
      testcase SIP_RG_RR_I_003(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER request including a Contact
      // header set to "*" together with an additional Contact header, sends a Client
      //  error (400 Bad Request) response.
      {
        var Response vl_Response;
        var charstring vl_Raw_Star_Contact;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        // raw headers are built
        v_Raw_CallId := buildRaw_CallIdHeader(v_CallId);
        v_Raw_CSeq := buildRaw_CSeqHeader(v_CSeq);
        v_Raw_From := buildRaw_FromHeader(v_From);
        v_Raw_To := buildRaw_ToHeader(v_To);
        v_Raw_Via := buildRaw_ViaHeader(v_Via);
        vl_Raw_Star_Contact := "Contact: *" & CRLF;
        v_Raw_Contact := buildRaw_ContactHeader(v_Contact);
        v_Raw_Contact := vl_Raw_Star_Contact & v_Raw_Contact;
        v_Raw_RequestUri := buildRaw_SipURL(v_RequestUri);
        
        SIPP.send (
          Raw_REGISTER_Request_s_1(
            v_Raw_RequestUri,
            v_Raw_CallId,
            v_Raw_CSeq,
            v_Raw_Contact,
            v_Raw_From,
            v_Raw_To,
            v_Raw_Via)) to v_sent_label;
        if (PX_REGISTRATION_AUTHENTICATION_ENABLED) {
          var CommaParam_List vl_challenge;
          //var charstring vl_Credentials;
          var Credentials vl_Credentials;           
          TAck.start (PX_TACK);
          alt {
            [] SIPP.receive (
              Response_401_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Authorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .wwwAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .wwwAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
              } else {
                log ("No scheme in www-Authenticate header !!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.method := "REGISTER";
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              v_CSeq := loc_CSeq_s;
              v_Raw_CSeq := buildRaw_CSeqHeader(v_CSeq);
              
              v_Raw_Authorization :=
              //    "Authorization: " & vl_Credentials;
              "Authorization: " & f_convertCredentials(vl_Credentials);
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (
                Raw_REGISTER_Request_s_1a(
                  v_Raw_RequestUri,
                  v_Raw_CallId,
                  v_Raw_CSeq,
                  v_Raw_Contact,
                  v_Raw_From,
                  v_Raw_To,
                  v_Raw_Via,
                  v_Raw_Authorization)) to v_sent_label;
            }
            [] SIPP.receive (
              Response_407_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Authorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .proxyAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .proxyAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
                
              } else {
                log ("No scheme in Proxy-Authenticate header !!");
                setverdict (inconc);
                stop;
              }
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.method := "REGISTER";
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              v_CSeq := loc_CSeq_s;
              v_Raw_CSeq := buildRaw_CSeqHeader(v_CSeq);
              
              v_Raw_Authorization :=
              //       "Proxy-Authorization: " & vl_Credentials;

              "Proxy-Authorization: " & f_convertCredentials(vl_Credentials);
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (
                Raw_REGISTER_Request_s_1a(
                  v_Raw_RequestUri,
                  v_Raw_CallId,
                  v_Raw_CSeq,
                  v_Raw_Contact,
                  v_Raw_From,
                  v_Raw_To,
                  v_Raw_Via,
                  v_Raw_Authorization)) to v_sent_label;
            }
            [(not (PC_STATELESS))
              and mandatory] SIPP.receive (
              Response_1XX_r_1(v_CallId, loc_CSeq_s)) {
              repeat;
            }
            [] SIPP.receive (
              Response_200_r_1(v_CallId, loc_CSeq_s)) {
              TAck.stop;
              log ("Authorization was not requested as expected");
              setverdict (inconc);
              stop
            }
            [] SIPP.receive {
              all timer.stop;
              setverdict (inconc);
              stop
            }
            [] TAck.timeout {
              setverdict (inconc);
              stop
            }
          }
        }
        
        TAck.start (PX_TACK);
        alt {
          [] SIPP.receive (
            Response_400_r_1(v_CallIdReg, loc_CSeq_s)) {
            TAck.stop;
            setverdict (pass);
          }
          [
            not (PC_STATELESS)] SIPP.receive (
            Response_1XX_r_1(v_CallIdReg, loc_CSeq_s)) {
            repeat;
          }
          [] SIPP.receive {
            all timer.stop;
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop;
          }
          [] TAck.timeout {
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop;
          }
        }
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request including a Contact header set to ""*"" together with an additional Contact header, sends a Client error (400 Bad Request) response.";
        extension "Reference: 10.3 [1] ";
        extension "FailCause: Invalid Client error (400 Bad Request) response received OR No Client error (400 Bad Request) response received";
      } // end testcase SIP_RG_RR_I_003
      testcase SIP_RG_RR_I_004(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT on receipt of a REGISTER request including a Contact
      // header set to "*", and an Expires header with an expiration time set to other
      // than zero, sends a Client error (400 Bad Request) response.
      {
        var Response vl_Response;
        var Contact vl_Contact_wild := {
          fieldName := CONTACT_E,
          contactBody := { wildcard := "*" }
        };
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        setHeadersForRegister(loc_CSeq_s);
        
        SIPP.send (
          REGISTER_Request_s_2(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            vl_Contact_wild,
            v_From,
            v_To,
            v_Via,
            "3600")) to v_sent_label;
        if (PX_REGISTRATION_AUTHENTICATION_ENABLED) {
          var CommaParam_List vl_challenge;
          //var charstring vl_Credentials;
          var Credentials vl_Credentials;
          var Request vl_Request;
          
          v_Branch := BRANCH_COOKIE & getRndTag();
          v_Via := {
            fieldName := VIA_E,
            viaBody := {
              valueof (ViaBody_ETS_IPADDR(v_Branch))}
          };
          vl_Request :=
          valueof (
            REGISTER_Request_s_2(
              v_RequestUri,
              v_CallId,
              loc_CSeq_s,
              vl_Contact_wild,
              v_From,
              v_To,
              v_Via,
              "3600"));
          
          TAck.start (PX_TACK);
          alt {
            [] SIPP.receive (
              Response_401_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Authorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .wwwAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .wwwAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
                
              } else {
                log ("No scheme in www-Authenticate header !!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              vl_Request.msgHeader.cSeq.seqNumber :=
              loc_CSeq_s.seqNumber;
              vl_Request.msgHeader.authorization.fieldName :=
              AUTHORIZATION_E;
              vl_Request.msgHeader.authorization.body :=
              vl_Credentials;
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (vl_Request) to v_sent_label;
            }
            [] SIPP.receive (
              Response_407_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Proxyauthorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .proxyAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .proxyAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
              } else {
                log ("No scheme in Proxy Authenticate header!!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              vl_Request.msgHeader.cSeq.seqNumber :=
              loc_CSeq_s.seqNumber;
              vl_Request
              .msgHeader
              .proxyAuthorization
              .fieldName :=
              PROXY_AUTHORIZATION_E;
              vl_Request
              .msgHeader
              .proxyAuthorization
              .credentials :=
              vl_Credentials;
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (vl_Request) to v_sent_label;
            }
            [(not (PC_STATELESS))
              and mandatory] SIPP.receive (
              Response_1XX_r_1(v_CallId, loc_CSeq_s)) {
              repeat;
            }
            [] SIPP.receive (
              Response_200_r_1(v_CallId, loc_CSeq_s)) {
              TAck.stop;
              log ("Authorization was not requested as expected");
              setverdict (inconc);
              stop
            }
            [] SIPP.receive {
              all timer.stop;
              setverdict (inconc);
              stop
            }
            [] TAck.timeout {
              setverdict (inconc);
              stop
            }
          }
        };
        
        TAck.start (PX_TACK);
        alt {
          [] SIPP.receive (
            Response_400_r_1(v_CallIdReg, loc_CSeq_s)) {
            TAck.stop;
            setverdict (pass);
          }
          [
            not (PC_STATELESS)] SIPP.receive (
            Response_1XX_r_1(v_CallIdReg, loc_CSeq_s)) {
            repeat;
          }
          [] SIPP.receive {
            all timer.stop;
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
          [] TAck.timeout {
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
        }
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT on receipt of a REGISTER request including a Contact header set to ""*"", and an Expires header with an expiration time set to other than zero, sends a Client error (400 Bad Request) response.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: Invalid Client error (400 Bad Request) response received OR No Client error (400 Bad Request) response received";
      } // end testcase SIP_RG_RR_I_004
    } // end group InvalidBehaviour
    group InopportuneBehaviour {
      testcase SIP_RG_RR_O_001(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a binding already registered, on receipt of
      // a REGISTER request including a Contact header set to * and an Expires header set
      //  to zero, and Call-ID is the same as the stored Call-ID value and CSeq is equal
      // to the stored CSeq value of that binding, does not remove that binding and sends a
      //  Success (200 OK) response.
      {
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        contactRegistration(loc_CSeq_s);
        v_Contact := {
          fieldName := CONTACT_E,
          contactBody := { wildcard := "*" }
        };
        
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        // Same CSeq
        SIPP.send (
          REGISTER_Request_s_2(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via,
            "0")) to v_sent_label;
        if (PX_REGISTRATION_AUTHENTICATION_ENABLED) {
          // Re-send request with Authorization header after
          // receiving 401 Unauthorized response.
          v_Branch := BRANCH_COOKIE & getRndTag();
          v_Via := {
            fieldName := VIA_E,
            viaBody := {
              valueof (ViaBody_ETS_IPADDR(v_Branch))}
          };
          awaitingUnauthorizedResponse(
            loc_CSeq_s,
            REGISTER_Request_s_2(
              v_RequestUri,
              v_CallId,
              loc_CSeq_s,
              v_Contact,
              v_From,
              v_To,
              v_Via,
              "0"),
            PX_RFC2617_USERNAME,
            PX_RFC2617_PASSWD);
        } else {
          awaitingOkResponse(loc_CSeq_s);
        }
        
        // Check that the IUT has not removed the binding
        //////////////////////////////////////////////
        checkNumberOfBinding(v_CallIdReg, loc_CSeq_s, 1);
        
        removeRegistration(loc_CSeq_s);
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a binding already registered, on receipt of  a REGISTER request including a Contact header set to * and an Expires header set  to zero, and Call-ID is the same as the stored Call-ID value and CSeq is equal  to the stored CSeq value of that binding, does not remove that binding and sends a  Success (200 OK) response.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR Second Success (200 OK) response received with removed binding in the contact list OR No Success (200 OK) response received";
      } // end testcase SIP_RG_RR_O_001
      testcase SIP_RG_RR_O_002(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a binding already registered, on receipt of
      // a REGISTER request including a Contact header set to an address which is in the
      // bindings list with the same Call-ID as the value stored for that binding, CSeq is
      // equal to the stored CSeq value of that binding,  and an expiration time other
      // than zero, sends a Server Failure (500 Server Error) response.
      {
        var Response vl_Response;
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        contactRegistration(loc_CSeq_s);
        
        // Additional REGISTER with same CSeq
        /////////////////////////////////////////
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_2(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via,
            int2str (
              float2int (SHORT_REGISTRATION)))) to v_sent_label;
        
        if (PX_REGISTRATION_AUTHENTICATION_ENABLED) {
          var CommaParam_List vl_challenge;
          // var charstring vl_Credentials;
          var Credentials vl_Credentials;
          var Request vl_Request;
          
          v_Branch := BRANCH_COOKIE & getRndTag();
          v_Via := {
            fieldName := VIA_E,
            viaBody := {
              valueof (ViaBody_ETS_IPADDR(v_Branch))}
          };
          vl_Request :=
          valueof (
            REGISTER_Request_s_2(
              v_RequestUri,
              v_CallId,
              loc_CSeq_s,
              v_Contact,
              v_From,
              v_To,
              v_Via,
              int2str (float2int (SHORT_REGISTRATION))));
          
          TAck.start (PX_TACK);
          alt {
            [] SIPP.receive (
              Response_401_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Authorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .wwwAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .wwwAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
                
              } else {
                log ("No scheme in www-Authenticate header !!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              vl_Request.msgHeader.cSeq.seqNumber :=
              loc_CSeq_s.seqNumber;
              vl_Request.msgHeader.authorization.fieldName :=
              AUTHORIZATION_E;
              vl_Request.msgHeader.authorization.body :=
              vl_Credentials;
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (vl_Request) to v_sent_label;
            }
            [] SIPP.receive (
              Response_407_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Proxyauthorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .proxyAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .proxyAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
              } else {
                log ("No scheme in Proxy Authenticate header!!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              vl_Request.msgHeader.cSeq.seqNumber :=
              loc_CSeq_s.seqNumber;
              vl_Request
              .msgHeader
              .proxyAuthorization
              .fieldName :=
              PROXY_AUTHORIZATION_E;
              vl_Request
              .msgHeader
              .proxyAuthorization
              .credentials :=
              vl_Credentials;
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (vl_Request) to v_sent_label;
            }
            [(not (PC_STATELESS))
              and mandatory] SIPP.receive (
              Response_1XX_r_1(v_CallId, loc_CSeq_s)) {
              repeat;
            }
            [] SIPP.receive (
              Response_200_r_1(v_CallId, loc_CSeq_s)) {
              TAck.stop;
              log ("Authorization was not requested as expected");
              setverdict (inconc);
              stop
            }
            [] SIPP.receive {
              all timer.stop;
              setverdict (inconc);
              stop
            }
            [] TAck.timeout {
              setverdict (inconc);
              stop
            }
          }
        };
        
        TAck.start (PX_TACK);
        alt {
          [] SIPP.receive (
            Response_500_r_0(v_CallIdReg, loc_CSeq_s)) {
            TAck.stop;
            setverdict (pass);
          }
          [
            not (PC_STATELESS)] SIPP.receive (
            Response_1XX_r_1(v_CallIdReg, loc_CSeq_s)) {
            repeat;
          }
          [] SIPP.receive {
            all timer.stop;
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
          [] TAck.timeout {
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
        }
        
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a binding already registered, on receipt of  a REGISTER request including a Contact header set to an address which is in the  bindings list with the same Call-ID as the value stored for that binding, CSeq is equal to the stored CSeq value of that binding,  and an expiration time other  than zero, sends a Server Failure (500 Server Error) response.";
        extension "Reference: 10.3 [1] ";
        extension "FailCause: Invalid first Success (200 OK) response received OR Second Server Failure (500 Server Error) received OR No Server Failure (500 Server Error) response received";
      } // end testcase SIP_RG_RR_O_002
      testcase SIP_RG_RR_O_003(inout CSeq loc_CSeq_s) runs on SipComponent system SipInterfaces
      // Ref: 10.3 [1]
      // Purpose : Ensure that the IUT when a binding already registered, on receipt of
      // a REGISTER request including a Contact header set to an address which is in the
      // bindings list with the same Call-ID as the value stored for that binding, CSeq
      // is equal to the stored CSeq value of that binding,  and an expiration time equal
      // to zero, does not remove that binding and sends a Server Failure (500 Server Error)
      //  response.
      {
        var Response vl_Response;
        var SemicolonParam_List vl_params;
        
        initPort(mtc, system);
        v_Default := activate (defaultRGRR());
        
        contactRegistration(loc_CSeq_s);
        
        // Additional REGISTER with same CSeq
        /////////////////////////////////////////
        //new BranchId
        vl_params := valueof (v_Via.viaBody[0].viaParams);
        vl_params[0] := {
          id := BRANCH_ID,
          paramValue := BRANCH_COOKIE & getRndTag()
        };
        v_Via.viaBody[0].viaParams := vl_params;
        // New Tag for FROM
        vl_params := {
          {
            id := TAG_ID,
            paramValue := getRndTag()
          }
        };
        v_From.fromParams := vl_params;
        
        SIPP.send (
          REGISTER_Request_s_2(
            v_RequestUri,
            v_CallId,
            loc_CSeq_s,
            v_Contact,
            v_From,
            v_To,
            v_Via,
            "0")) to v_sent_label;
        
        if (PX_REGISTRATION_AUTHENTICATION_ENABLED) {
          var CommaParam_List vl_challenge;
          //var charstring vl_Credentials;
          var Credentials vl_Credentials;
          var Request vl_Request;
          
          v_Branch := BRANCH_COOKIE & getRndTag();
          v_Via := {
            fieldName := VIA_E,
            viaBody := {
              valueof (ViaBody_ETS_IPADDR(v_Branch))}
          };
          vl_Request :=
          valueof (
            REGISTER_Request_s_2(
              v_RequestUri,
              v_CallId,
              loc_CSeq_s,
              v_Contact,
              v_From,
              v_To,
              v_Via,
              "0"));
          
          TAck.start (PX_TACK);
          alt {
            [] SIPP.receive (
              Response_401_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Authorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .wwwAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .wwwAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
                
              } else {
                log ("No scheme in www-Authenticate header !!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              vl_Request.msgHeader.cSeq.seqNumber :=
              loc_CSeq_s.seqNumber;
              vl_Request.msgHeader.authorization.fieldName :=
              AUTHORIZATION_E;
              vl_Request.msgHeader.authorization.body :=
              vl_Credentials;
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (vl_Request) to v_sent_label;
            }
            [] SIPP.receive (
              Response_407_r_1(
                v_CallId,
                loc_CSeq_s)) -> value vl_Response {
              TAck.stop;
              // resent the REGISTER message with Proxyauthorization header include
              // Extract challenge and calculate credentials for a response.
              if (ischosen (vl_Response
                  .msgHeader
                  .proxyAuthenticate
                  .challenge[0]
                  .digestCln)) {
                vl_challenge :=
                vl_Response
                .msgHeader
                .proxyAuthenticate
                .challenge[0]
                .digestCln;
                vl_Credentials :=
                calculateCredentials(
                  "REGISTER",
                  vl_challenge,
                  PX_RFC2617_USERNAME,
                  PX_RFC2617_PASSWD);
              } else {
                log ("No scheme in Proxy Authenticate header!!");
                setverdict (inconc);
                stop;
              }
              
              // Increment CSeq sequence number of and add the credentials
              // to the original saved REGEISTER message.
              loc_CSeq_s.seqNumber :=
              loc_CSeq_s.seqNumber + 1;
              vl_Request.msgHeader.cSeq.seqNumber :=
              loc_CSeq_s.seqNumber;
              vl_Request
              .msgHeader
              .proxyAuthorization
              .fieldName :=
              PROXY_AUTHORIZATION_E;
              vl_Request
              .msgHeader
              .proxyAuthorization
              .credentials :=
              vl_Credentials;
              
              // Re-send the saved REGISTER with Authorization header
              // included.
              SIPP.send (vl_Request) to v_sent_label;
            }
            [(not (PC_STATELESS))
              and mandatory] SIPP.receive (
              Response_1XX_r_1(v_CallId, loc_CSeq_s)) {
              repeat;
            }
            [] SIPP.receive (
              Response_200_r_1(v_CallId, loc_CSeq_s)) {
              TAck.stop;
              log ("Authorization was not requested as expected");
              setverdict (inconc);
              stop
            }
            [] SIPP.receive {
              all timer.stop;
              setverdict (inconc);
              stop
            }
            [] TAck.timeout {
              setverdict (inconc);
              stop
            }
          }
        };
        
        TAck.start (PX_TACK);
        alt {
          [] SIPP.receive (
            Response_500_r_0(v_CallIdReg, loc_CSeq_s)) {
            TAck.stop;
            setverdict (pass);
          }
          [
            not (PC_STATELESS)] SIPP.receive (
            Response_1XX_r_1(v_CallIdReg, loc_CSeq_s)) {
            repeat;
          }
          [] SIPP.receive {
            all timer.stop;
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
          [] TAck.timeout {
            setverdict (fail);
            removeRegistration(loc_CSeq_s);
            stop
          }
        }
        
        // Check that the IUT has not removed the binding
        //////////////////////////////////////////////
        checkNumberOfBinding(v_CallIdReg, loc_CSeq_s, 1);
        
        removeRegistration(loc_CSeq_s);
        
      }
      with {
        extension "Preconditions: IUT is a proxy or a redirect server entity";
        extension "Description: Ensure that the IUT when a binding already registered, on receipt of  a REGISTER request including a Contact header set to an address which is in the  bindings list with the same Call-ID as the value stored for that binding, CSeq  is equal to the stored CSeq value of that binding, and an expiration time equal to zero, does not remove that binding and sends a Server Failure (500 Server Error) response.";
        extension "Reference: 10.3 [1]";
        extension "FailCause: Invalid Success (200 OK) response received OR No Success (200 OK) response received OR No Second Server Failure (500 Server Error) response OR Second Server Failure (500 Server Error) response received with removed binding in the contact list";
      } // end testcase SIP_RG_RR_O_003
      // end testcase SIP_RG_RR_O_003
    } // end group InopportuneBehaviour
  } // end group Registrar
} // end group TestPurposesforRegistration
}
